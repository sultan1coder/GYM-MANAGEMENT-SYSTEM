
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserSession
 * 
 */
export type UserSession = $Result.DefaultSelection<Prisma.$UserSessionPayload>
/**
 * Model UserAccessLog
 * 
 */
export type UserAccessLog = $Result.DefaultSelection<Prisma.$UserAccessLogPayload>
/**
 * Model UserIPRestriction
 * 
 */
export type UserIPRestriction = $Result.DefaultSelection<Prisma.$UserIPRestrictionPayload>
/**
 * Model UserAddress
 * 
 */
export type UserAddress = $Result.DefaultSelection<Prisma.$UserAddressPayload>
/**
 * Model UserEmergencyContact
 * 
 */
export type UserEmergencyContact = $Result.DefaultSelection<Prisma.$UserEmergencyContactPayload>
/**
 * Model UserSocialMedia
 * 
 */
export type UserSocialMedia = $Result.DefaultSelection<Prisma.$UserSocialMediaPayload>
/**
 * Model UserPreferences
 * 
 */
export type UserPreferences = $Result.DefaultSelection<Prisma.$UserPreferencesPayload>
/**
 * Model UserNotificationSettings
 * 
 */
export type UserNotificationSettings = $Result.DefaultSelection<Prisma.$UserNotificationSettingsPayload>
/**
 * Model UserPrivacySettings
 * 
 */
export type UserPrivacySettings = $Result.DefaultSelection<Prisma.$UserPrivacySettingsPayload>
/**
 * Model Member
 * 
 */
export type Member = $Result.DefaultSelection<Prisma.$MemberPayload>
/**
 * Model MemberCheckIn
 * 
 */
export type MemberCheckIn = $Result.DefaultSelection<Prisma.$MemberCheckInPayload>
/**
 * Model MemberAttendance
 * 
 */
export type MemberAttendance = $Result.DefaultSelection<Prisma.$MemberAttendancePayload>
/**
 * Model MemberFitnessGoal
 * 
 */
export type MemberFitnessGoal = $Result.DefaultSelection<Prisma.$MemberFitnessGoalPayload>
/**
 * Model Address
 * 
 */
export type Address = $Result.DefaultSelection<Prisma.$AddressPayload>
/**
 * Model EmergencyContact
 * 
 */
export type EmergencyContact = $Result.DefaultSelection<Prisma.$EmergencyContactPayload>
/**
 * Model MedicalInfo
 * 
 */
export type MedicalInfo = $Result.DefaultSelection<Prisma.$MedicalInfoPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model MembershipPlan
 * 
 */
export type MembershipPlan = $Result.DefaultSelection<Prisma.$MembershipPlanPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model Equipment
 * 
 */
export type Equipment = $Result.DefaultSelection<Prisma.$EquipmentPayload>
/**
 * Model MaintenanceLog
 * 
 */
export type MaintenanceLog = $Result.DefaultSelection<Prisma.$MaintenanceLogPayload>
/**
 * Model SystemIntegration
 * 
 */
export type SystemIntegration = $Result.DefaultSelection<Prisma.$SystemIntegrationPayload>
/**
 * Model AutomationWorkflow
 * 
 */
export type AutomationWorkflow = $Result.DefaultSelection<Prisma.$AutomationWorkflowPayload>
/**
 * Model DataSyncJob
 * 
 */
export type DataSyncJob = $Result.DefaultSelection<Prisma.$DataSyncJobPayload>
/**
 * Model WebhookEndpoint
 * 
 */
export type WebhookEndpoint = $Result.DefaultSelection<Prisma.$WebhookEndpointPayload>
/**
 * Model APIManagement
 * 
 */
export type APIManagement = $Result.DefaultSelection<Prisma.$APIManagementPayload>
/**
 * Model ThreatDetection
 * 
 */
export type ThreatDetection = $Result.DefaultSelection<Prisma.$ThreatDetectionPayload>
/**
 * Model AnomalyDetection
 * 
 */
export type AnomalyDetection = $Result.DefaultSelection<Prisma.$AnomalyDetectionPayload>
/**
 * Model ComplianceReport
 * 
 */
export type ComplianceReport = $Result.DefaultSelection<Prisma.$ComplianceReportPayload>
/**
 * Model SecurityWorkflow
 * 
 */
export type SecurityWorkflow = $Result.DefaultSelection<Prisma.$SecurityWorkflowPayload>
/**
 * Model SecurityIntegration
 * 
 */
export type SecurityIntegration = $Result.DefaultSelection<Prisma.$SecurityIntegrationPayload>
/**
 * Model AdministrativeProfile
 * 
 */
export type AdministrativeProfile = $Result.DefaultSelection<Prisma.$AdministrativeProfilePayload>
/**
 * Model CustomRole
 * 
 */
export type CustomRole = $Result.DefaultSelection<Prisma.$CustomRolePayload>
/**
 * Model Permission
 * 
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model RoleHierarchy
 * 
 */
export type RoleHierarchy = $Result.DefaultSelection<Prisma.$RoleHierarchyPayload>
/**
 * Model PermissionAudit
 * 
 */
export type PermissionAudit = $Result.DefaultSelection<Prisma.$PermissionAuditPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const MemberShipType: {
  MONTHLY: 'MONTHLY',
  DAILY: 'DAILY'
};

export type MemberShipType = (typeof MemberShipType)[keyof typeof MemberShipType]


export const PaymentStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED',
  REFUNDED: 'REFUNDED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const EquipmentStatus: {
  OPERATIONAL: 'OPERATIONAL',
  MAINTENANCE: 'MAINTENANCE',
  OUT_OF_SERVICE: 'OUT_OF_SERVICE',
  RETIRED: 'RETIRED'
};

export type EquipmentStatus = (typeof EquipmentStatus)[keyof typeof EquipmentStatus]


export const MaintenanceType: {
  PREVENTIVE: 'PREVENTIVE',
  CORRECTIVE: 'CORRECTIVE',
  INSPECTION: 'INSPECTION',
  REPAIR: 'REPAIR'
};

export type MaintenanceType = (typeof MaintenanceType)[keyof typeof MaintenanceType]

}

export type MemberShipType = $Enums.MemberShipType

export const MemberShipType: typeof $Enums.MemberShipType

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type EquipmentStatus = $Enums.EquipmentStatus

export const EquipmentStatus: typeof $Enums.EquipmentStatus

export type MaintenanceType = $Enums.MaintenanceType

export const MaintenanceType: typeof $Enums.MaintenanceType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSession`: Exposes CRUD operations for the **UserSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSessions
    * const userSessions = await prisma.userSession.findMany()
    * ```
    */
  get userSession(): Prisma.UserSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userAccessLog`: Exposes CRUD operations for the **UserAccessLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAccessLogs
    * const userAccessLogs = await prisma.userAccessLog.findMany()
    * ```
    */
  get userAccessLog(): Prisma.UserAccessLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userIPRestriction`: Exposes CRUD operations for the **UserIPRestriction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserIPRestrictions
    * const userIPRestrictions = await prisma.userIPRestriction.findMany()
    * ```
    */
  get userIPRestriction(): Prisma.UserIPRestrictionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userAddress`: Exposes CRUD operations for the **UserAddress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAddresses
    * const userAddresses = await prisma.userAddress.findMany()
    * ```
    */
  get userAddress(): Prisma.UserAddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userEmergencyContact`: Exposes CRUD operations for the **UserEmergencyContact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserEmergencyContacts
    * const userEmergencyContacts = await prisma.userEmergencyContact.findMany()
    * ```
    */
  get userEmergencyContact(): Prisma.UserEmergencyContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSocialMedia`: Exposes CRUD operations for the **UserSocialMedia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSocialMedias
    * const userSocialMedias = await prisma.userSocialMedia.findMany()
    * ```
    */
  get userSocialMedia(): Prisma.UserSocialMediaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPreferences`: Exposes CRUD operations for the **UserPreferences** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPreferences
    * const userPreferences = await prisma.userPreferences.findMany()
    * ```
    */
  get userPreferences(): Prisma.UserPreferencesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userNotificationSettings`: Exposes CRUD operations for the **UserNotificationSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserNotificationSettings
    * const userNotificationSettings = await prisma.userNotificationSettings.findMany()
    * ```
    */
  get userNotificationSettings(): Prisma.UserNotificationSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPrivacySettings`: Exposes CRUD operations for the **UserPrivacySettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPrivacySettings
    * const userPrivacySettings = await prisma.userPrivacySettings.findMany()
    * ```
    */
  get userPrivacySettings(): Prisma.UserPrivacySettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.member`: Exposes CRUD operations for the **Member** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Members
    * const members = await prisma.member.findMany()
    * ```
    */
  get member(): Prisma.MemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.memberCheckIn`: Exposes CRUD operations for the **MemberCheckIn** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MemberCheckIns
    * const memberCheckIns = await prisma.memberCheckIn.findMany()
    * ```
    */
  get memberCheckIn(): Prisma.MemberCheckInDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.memberAttendance`: Exposes CRUD operations for the **MemberAttendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MemberAttendances
    * const memberAttendances = await prisma.memberAttendance.findMany()
    * ```
    */
  get memberAttendance(): Prisma.MemberAttendanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.memberFitnessGoal`: Exposes CRUD operations for the **MemberFitnessGoal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MemberFitnessGoals
    * const memberFitnessGoals = await prisma.memberFitnessGoal.findMany()
    * ```
    */
  get memberFitnessGoal(): Prisma.MemberFitnessGoalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.AddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emergencyContact`: Exposes CRUD operations for the **EmergencyContact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmergencyContacts
    * const emergencyContacts = await prisma.emergencyContact.findMany()
    * ```
    */
  get emergencyContact(): Prisma.EmergencyContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medicalInfo`: Exposes CRUD operations for the **MedicalInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MedicalInfos
    * const medicalInfos = await prisma.medicalInfo.findMany()
    * ```
    */
  get medicalInfo(): Prisma.MedicalInfoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.membershipPlan`: Exposes CRUD operations for the **MembershipPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MembershipPlans
    * const membershipPlans = await prisma.membershipPlan.findMany()
    * ```
    */
  get membershipPlan(): Prisma.MembershipPlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.equipment`: Exposes CRUD operations for the **Equipment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Equipment
    * const equipment = await prisma.equipment.findMany()
    * ```
    */
  get equipment(): Prisma.EquipmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.maintenanceLog`: Exposes CRUD operations for the **MaintenanceLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaintenanceLogs
    * const maintenanceLogs = await prisma.maintenanceLog.findMany()
    * ```
    */
  get maintenanceLog(): Prisma.MaintenanceLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemIntegration`: Exposes CRUD operations for the **SystemIntegration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemIntegrations
    * const systemIntegrations = await prisma.systemIntegration.findMany()
    * ```
    */
  get systemIntegration(): Prisma.SystemIntegrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.automationWorkflow`: Exposes CRUD operations for the **AutomationWorkflow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AutomationWorkflows
    * const automationWorkflows = await prisma.automationWorkflow.findMany()
    * ```
    */
  get automationWorkflow(): Prisma.AutomationWorkflowDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dataSyncJob`: Exposes CRUD operations for the **DataSyncJob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DataSyncJobs
    * const dataSyncJobs = await prisma.dataSyncJob.findMany()
    * ```
    */
  get dataSyncJob(): Prisma.DataSyncJobDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.webhookEndpoint`: Exposes CRUD operations for the **WebhookEndpoint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebhookEndpoints
    * const webhookEndpoints = await prisma.webhookEndpoint.findMany()
    * ```
    */
  get webhookEndpoint(): Prisma.WebhookEndpointDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aPIManagement`: Exposes CRUD operations for the **APIManagement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more APIManagements
    * const aPIManagements = await prisma.aPIManagement.findMany()
    * ```
    */
  get aPIManagement(): Prisma.APIManagementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.threatDetection`: Exposes CRUD operations for the **ThreatDetection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ThreatDetections
    * const threatDetections = await prisma.threatDetection.findMany()
    * ```
    */
  get threatDetection(): Prisma.ThreatDetectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.anomalyDetection`: Exposes CRUD operations for the **AnomalyDetection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnomalyDetections
    * const anomalyDetections = await prisma.anomalyDetection.findMany()
    * ```
    */
  get anomalyDetection(): Prisma.AnomalyDetectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.complianceReport`: Exposes CRUD operations for the **ComplianceReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ComplianceReports
    * const complianceReports = await prisma.complianceReport.findMany()
    * ```
    */
  get complianceReport(): Prisma.ComplianceReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.securityWorkflow`: Exposes CRUD operations for the **SecurityWorkflow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SecurityWorkflows
    * const securityWorkflows = await prisma.securityWorkflow.findMany()
    * ```
    */
  get securityWorkflow(): Prisma.SecurityWorkflowDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.securityIntegration`: Exposes CRUD operations for the **SecurityIntegration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SecurityIntegrations
    * const securityIntegrations = await prisma.securityIntegration.findMany()
    * ```
    */
  get securityIntegration(): Prisma.SecurityIntegrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.administrativeProfile`: Exposes CRUD operations for the **AdministrativeProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdministrativeProfiles
    * const administrativeProfiles = await prisma.administrativeProfile.findMany()
    * ```
    */
  get administrativeProfile(): Prisma.AdministrativeProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customRole`: Exposes CRUD operations for the **CustomRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomRoles
    * const customRoles = await prisma.customRole.findMany()
    * ```
    */
  get customRole(): Prisma.CustomRoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roleHierarchy`: Exposes CRUD operations for the **RoleHierarchy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoleHierarchies
    * const roleHierarchies = await prisma.roleHierarchy.findMany()
    * ```
    */
  get roleHierarchy(): Prisma.RoleHierarchyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permissionAudit`: Exposes CRUD operations for the **PermissionAudit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PermissionAudits
    * const permissionAudits = await prisma.permissionAudit.findMany()
    * ```
    */
  get permissionAudit(): Prisma.PermissionAuditDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.14.0
   * Query Engine version: 717184b7b35ea05dfa71a3236b7af656013e1e49
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    UserSession: 'UserSession',
    UserAccessLog: 'UserAccessLog',
    UserIPRestriction: 'UserIPRestriction',
    UserAddress: 'UserAddress',
    UserEmergencyContact: 'UserEmergencyContact',
    UserSocialMedia: 'UserSocialMedia',
    UserPreferences: 'UserPreferences',
    UserNotificationSettings: 'UserNotificationSettings',
    UserPrivacySettings: 'UserPrivacySettings',
    Member: 'Member',
    MemberCheckIn: 'MemberCheckIn',
    MemberAttendance: 'MemberAttendance',
    MemberFitnessGoal: 'MemberFitnessGoal',
    Address: 'Address',
    EmergencyContact: 'EmergencyContact',
    MedicalInfo: 'MedicalInfo',
    Payment: 'Payment',
    Invoice: 'Invoice',
    MembershipPlan: 'MembershipPlan',
    Subscription: 'Subscription',
    Equipment: 'Equipment',
    MaintenanceLog: 'MaintenanceLog',
    SystemIntegration: 'SystemIntegration',
    AutomationWorkflow: 'AutomationWorkflow',
    DataSyncJob: 'DataSyncJob',
    WebhookEndpoint: 'WebhookEndpoint',
    APIManagement: 'APIManagement',
    ThreatDetection: 'ThreatDetection',
    AnomalyDetection: 'AnomalyDetection',
    ComplianceReport: 'ComplianceReport',
    SecurityWorkflow: 'SecurityWorkflow',
    SecurityIntegration: 'SecurityIntegration',
    AdministrativeProfile: 'AdministrativeProfile',
    CustomRole: 'CustomRole',
    Permission: 'Permission',
    RoleHierarchy: 'RoleHierarchy',
    PermissionAudit: 'PermissionAudit'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "userSession" | "userAccessLog" | "userIPRestriction" | "userAddress" | "userEmergencyContact" | "userSocialMedia" | "userPreferences" | "userNotificationSettings" | "userPrivacySettings" | "member" | "memberCheckIn" | "memberAttendance" | "memberFitnessGoal" | "address" | "emergencyContact" | "medicalInfo" | "payment" | "invoice" | "membershipPlan" | "subscription" | "equipment" | "maintenanceLog" | "systemIntegration" | "automationWorkflow" | "dataSyncJob" | "webhookEndpoint" | "aPIManagement" | "threatDetection" | "anomalyDetection" | "complianceReport" | "securityWorkflow" | "securityIntegration" | "administrativeProfile" | "customRole" | "permission" | "roleHierarchy" | "permissionAudit"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserSession: {
        payload: Prisma.$UserSessionPayload<ExtArgs>
        fields: Prisma.UserSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findFirst: {
            args: Prisma.UserSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findMany: {
            args: Prisma.UserSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          create: {
            args: Prisma.UserSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          createMany: {
            args: Prisma.UserSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          delete: {
            args: Prisma.UserSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          update: {
            args: Prisma.UserSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          deleteMany: {
            args: Prisma.UserSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          upsert: {
            args: Prisma.UserSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          aggregate: {
            args: Prisma.UserSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSession>
          }
          groupBy: {
            args: Prisma.UserSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSessionCountArgs<ExtArgs>
            result: $Utils.Optional<UserSessionCountAggregateOutputType> | number
          }
        }
      }
      UserAccessLog: {
        payload: Prisma.$UserAccessLogPayload<ExtArgs>
        fields: Prisma.UserAccessLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAccessLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccessLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAccessLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccessLogPayload>
          }
          findFirst: {
            args: Prisma.UserAccessLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccessLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAccessLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccessLogPayload>
          }
          findMany: {
            args: Prisma.UserAccessLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccessLogPayload>[]
          }
          create: {
            args: Prisma.UserAccessLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccessLogPayload>
          }
          createMany: {
            args: Prisma.UserAccessLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAccessLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccessLogPayload>[]
          }
          delete: {
            args: Prisma.UserAccessLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccessLogPayload>
          }
          update: {
            args: Prisma.UserAccessLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccessLogPayload>
          }
          deleteMany: {
            args: Prisma.UserAccessLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAccessLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserAccessLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccessLogPayload>[]
          }
          upsert: {
            args: Prisma.UserAccessLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccessLogPayload>
          }
          aggregate: {
            args: Prisma.UserAccessLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAccessLog>
          }
          groupBy: {
            args: Prisma.UserAccessLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAccessLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAccessLogCountArgs<ExtArgs>
            result: $Utils.Optional<UserAccessLogCountAggregateOutputType> | number
          }
        }
      }
      UserIPRestriction: {
        payload: Prisma.$UserIPRestrictionPayload<ExtArgs>
        fields: Prisma.UserIPRestrictionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserIPRestrictionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserIPRestrictionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserIPRestrictionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserIPRestrictionPayload>
          }
          findFirst: {
            args: Prisma.UserIPRestrictionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserIPRestrictionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserIPRestrictionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserIPRestrictionPayload>
          }
          findMany: {
            args: Prisma.UserIPRestrictionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserIPRestrictionPayload>[]
          }
          create: {
            args: Prisma.UserIPRestrictionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserIPRestrictionPayload>
          }
          createMany: {
            args: Prisma.UserIPRestrictionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserIPRestrictionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserIPRestrictionPayload>[]
          }
          delete: {
            args: Prisma.UserIPRestrictionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserIPRestrictionPayload>
          }
          update: {
            args: Prisma.UserIPRestrictionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserIPRestrictionPayload>
          }
          deleteMany: {
            args: Prisma.UserIPRestrictionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserIPRestrictionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserIPRestrictionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserIPRestrictionPayload>[]
          }
          upsert: {
            args: Prisma.UserIPRestrictionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserIPRestrictionPayload>
          }
          aggregate: {
            args: Prisma.UserIPRestrictionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserIPRestriction>
          }
          groupBy: {
            args: Prisma.UserIPRestrictionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserIPRestrictionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserIPRestrictionCountArgs<ExtArgs>
            result: $Utils.Optional<UserIPRestrictionCountAggregateOutputType> | number
          }
        }
      }
      UserAddress: {
        payload: Prisma.$UserAddressPayload<ExtArgs>
        fields: Prisma.UserAddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload>
          }
          findFirst: {
            args: Prisma.UserAddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload>
          }
          findMany: {
            args: Prisma.UserAddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload>[]
          }
          create: {
            args: Prisma.UserAddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload>
          }
          createMany: {
            args: Prisma.UserAddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload>[]
          }
          delete: {
            args: Prisma.UserAddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload>
          }
          update: {
            args: Prisma.UserAddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload>
          }
          deleteMany: {
            args: Prisma.UserAddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserAddressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload>[]
          }
          upsert: {
            args: Prisma.UserAddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload>
          }
          aggregate: {
            args: Prisma.UserAddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAddress>
          }
          groupBy: {
            args: Prisma.UserAddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAddressCountArgs<ExtArgs>
            result: $Utils.Optional<UserAddressCountAggregateOutputType> | number
          }
        }
      }
      UserEmergencyContact: {
        payload: Prisma.$UserEmergencyContactPayload<ExtArgs>
        fields: Prisma.UserEmergencyContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserEmergencyContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEmergencyContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserEmergencyContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEmergencyContactPayload>
          }
          findFirst: {
            args: Prisma.UserEmergencyContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEmergencyContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserEmergencyContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEmergencyContactPayload>
          }
          findMany: {
            args: Prisma.UserEmergencyContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEmergencyContactPayload>[]
          }
          create: {
            args: Prisma.UserEmergencyContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEmergencyContactPayload>
          }
          createMany: {
            args: Prisma.UserEmergencyContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserEmergencyContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEmergencyContactPayload>[]
          }
          delete: {
            args: Prisma.UserEmergencyContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEmergencyContactPayload>
          }
          update: {
            args: Prisma.UserEmergencyContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEmergencyContactPayload>
          }
          deleteMany: {
            args: Prisma.UserEmergencyContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserEmergencyContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserEmergencyContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEmergencyContactPayload>[]
          }
          upsert: {
            args: Prisma.UserEmergencyContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEmergencyContactPayload>
          }
          aggregate: {
            args: Prisma.UserEmergencyContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserEmergencyContact>
          }
          groupBy: {
            args: Prisma.UserEmergencyContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserEmergencyContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserEmergencyContactCountArgs<ExtArgs>
            result: $Utils.Optional<UserEmergencyContactCountAggregateOutputType> | number
          }
        }
      }
      UserSocialMedia: {
        payload: Prisma.$UserSocialMediaPayload<ExtArgs>
        fields: Prisma.UserSocialMediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSocialMediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSocialMediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSocialMediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSocialMediaPayload>
          }
          findFirst: {
            args: Prisma.UserSocialMediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSocialMediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSocialMediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSocialMediaPayload>
          }
          findMany: {
            args: Prisma.UserSocialMediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSocialMediaPayload>[]
          }
          create: {
            args: Prisma.UserSocialMediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSocialMediaPayload>
          }
          createMany: {
            args: Prisma.UserSocialMediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSocialMediaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSocialMediaPayload>[]
          }
          delete: {
            args: Prisma.UserSocialMediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSocialMediaPayload>
          }
          update: {
            args: Prisma.UserSocialMediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSocialMediaPayload>
          }
          deleteMany: {
            args: Prisma.UserSocialMediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSocialMediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSocialMediaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSocialMediaPayload>[]
          }
          upsert: {
            args: Prisma.UserSocialMediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSocialMediaPayload>
          }
          aggregate: {
            args: Prisma.UserSocialMediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSocialMedia>
          }
          groupBy: {
            args: Prisma.UserSocialMediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSocialMediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSocialMediaCountArgs<ExtArgs>
            result: $Utils.Optional<UserSocialMediaCountAggregateOutputType> | number
          }
        }
      }
      UserPreferences: {
        payload: Prisma.$UserPreferencesPayload<ExtArgs>
        fields: Prisma.UserPreferencesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPreferencesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPreferencesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          findFirst: {
            args: Prisma.UserPreferencesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPreferencesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          findMany: {
            args: Prisma.UserPreferencesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>[]
          }
          create: {
            args: Prisma.UserPreferencesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          createMany: {
            args: Prisma.UserPreferencesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserPreferencesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>[]
          }
          delete: {
            args: Prisma.UserPreferencesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          update: {
            args: Prisma.UserPreferencesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          deleteMany: {
            args: Prisma.UserPreferencesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPreferencesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserPreferencesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>[]
          }
          upsert: {
            args: Prisma.UserPreferencesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          aggregate: {
            args: Prisma.UserPreferencesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPreferences>
          }
          groupBy: {
            args: Prisma.UserPreferencesGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPreferencesGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPreferencesCountArgs<ExtArgs>
            result: $Utils.Optional<UserPreferencesCountAggregateOutputType> | number
          }
        }
      }
      UserNotificationSettings: {
        payload: Prisma.$UserNotificationSettingsPayload<ExtArgs>
        fields: Prisma.UserNotificationSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserNotificationSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserNotificationSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationSettingsPayload>
          }
          findFirst: {
            args: Prisma.UserNotificationSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserNotificationSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationSettingsPayload>
          }
          findMany: {
            args: Prisma.UserNotificationSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationSettingsPayload>[]
          }
          create: {
            args: Prisma.UserNotificationSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationSettingsPayload>
          }
          createMany: {
            args: Prisma.UserNotificationSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserNotificationSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationSettingsPayload>[]
          }
          delete: {
            args: Prisma.UserNotificationSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationSettingsPayload>
          }
          update: {
            args: Prisma.UserNotificationSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationSettingsPayload>
          }
          deleteMany: {
            args: Prisma.UserNotificationSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserNotificationSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserNotificationSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationSettingsPayload>[]
          }
          upsert: {
            args: Prisma.UserNotificationSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationSettingsPayload>
          }
          aggregate: {
            args: Prisma.UserNotificationSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserNotificationSettings>
          }
          groupBy: {
            args: Prisma.UserNotificationSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserNotificationSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserNotificationSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<UserNotificationSettingsCountAggregateOutputType> | number
          }
        }
      }
      UserPrivacySettings: {
        payload: Prisma.$UserPrivacySettingsPayload<ExtArgs>
        fields: Prisma.UserPrivacySettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPrivacySettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPrivacySettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPrivacySettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPrivacySettingsPayload>
          }
          findFirst: {
            args: Prisma.UserPrivacySettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPrivacySettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPrivacySettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPrivacySettingsPayload>
          }
          findMany: {
            args: Prisma.UserPrivacySettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPrivacySettingsPayload>[]
          }
          create: {
            args: Prisma.UserPrivacySettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPrivacySettingsPayload>
          }
          createMany: {
            args: Prisma.UserPrivacySettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserPrivacySettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPrivacySettingsPayload>[]
          }
          delete: {
            args: Prisma.UserPrivacySettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPrivacySettingsPayload>
          }
          update: {
            args: Prisma.UserPrivacySettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPrivacySettingsPayload>
          }
          deleteMany: {
            args: Prisma.UserPrivacySettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPrivacySettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserPrivacySettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPrivacySettingsPayload>[]
          }
          upsert: {
            args: Prisma.UserPrivacySettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPrivacySettingsPayload>
          }
          aggregate: {
            args: Prisma.UserPrivacySettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPrivacySettings>
          }
          groupBy: {
            args: Prisma.UserPrivacySettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPrivacySettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPrivacySettingsCountArgs<ExtArgs>
            result: $Utils.Optional<UserPrivacySettingsCountAggregateOutputType> | number
          }
        }
      }
      Member: {
        payload: Prisma.$MemberPayload<ExtArgs>
        fields: Prisma.MemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          findFirst: {
            args: Prisma.MemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          findMany: {
            args: Prisma.MemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          create: {
            args: Prisma.MemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          createMany: {
            args: Prisma.MemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          delete: {
            args: Prisma.MemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          update: {
            args: Prisma.MemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          deleteMany: {
            args: Prisma.MemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          upsert: {
            args: Prisma.MemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          aggregate: {
            args: Prisma.MemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMember>
          }
          groupBy: {
            args: Prisma.MemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberCountArgs<ExtArgs>
            result: $Utils.Optional<MemberCountAggregateOutputType> | number
          }
        }
      }
      MemberCheckIn: {
        payload: Prisma.$MemberCheckInPayload<ExtArgs>
        fields: Prisma.MemberCheckInFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberCheckInFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberCheckInPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberCheckInFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberCheckInPayload>
          }
          findFirst: {
            args: Prisma.MemberCheckInFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberCheckInPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberCheckInFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberCheckInPayload>
          }
          findMany: {
            args: Prisma.MemberCheckInFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberCheckInPayload>[]
          }
          create: {
            args: Prisma.MemberCheckInCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberCheckInPayload>
          }
          createMany: {
            args: Prisma.MemberCheckInCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MemberCheckInCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberCheckInPayload>[]
          }
          delete: {
            args: Prisma.MemberCheckInDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberCheckInPayload>
          }
          update: {
            args: Prisma.MemberCheckInUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberCheckInPayload>
          }
          deleteMany: {
            args: Prisma.MemberCheckInDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MemberCheckInUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MemberCheckInUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberCheckInPayload>[]
          }
          upsert: {
            args: Prisma.MemberCheckInUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberCheckInPayload>
          }
          aggregate: {
            args: Prisma.MemberCheckInAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMemberCheckIn>
          }
          groupBy: {
            args: Prisma.MemberCheckInGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemberCheckInGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberCheckInCountArgs<ExtArgs>
            result: $Utils.Optional<MemberCheckInCountAggregateOutputType> | number
          }
        }
      }
      MemberAttendance: {
        payload: Prisma.$MemberAttendancePayload<ExtArgs>
        fields: Prisma.MemberAttendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberAttendanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberAttendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberAttendanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberAttendancePayload>
          }
          findFirst: {
            args: Prisma.MemberAttendanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberAttendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberAttendanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberAttendancePayload>
          }
          findMany: {
            args: Prisma.MemberAttendanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberAttendancePayload>[]
          }
          create: {
            args: Prisma.MemberAttendanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberAttendancePayload>
          }
          createMany: {
            args: Prisma.MemberAttendanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MemberAttendanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberAttendancePayload>[]
          }
          delete: {
            args: Prisma.MemberAttendanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberAttendancePayload>
          }
          update: {
            args: Prisma.MemberAttendanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberAttendancePayload>
          }
          deleteMany: {
            args: Prisma.MemberAttendanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MemberAttendanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MemberAttendanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberAttendancePayload>[]
          }
          upsert: {
            args: Prisma.MemberAttendanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberAttendancePayload>
          }
          aggregate: {
            args: Prisma.MemberAttendanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMemberAttendance>
          }
          groupBy: {
            args: Prisma.MemberAttendanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemberAttendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberAttendanceCountArgs<ExtArgs>
            result: $Utils.Optional<MemberAttendanceCountAggregateOutputType> | number
          }
        }
      }
      MemberFitnessGoal: {
        payload: Prisma.$MemberFitnessGoalPayload<ExtArgs>
        fields: Prisma.MemberFitnessGoalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberFitnessGoalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberFitnessGoalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberFitnessGoalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberFitnessGoalPayload>
          }
          findFirst: {
            args: Prisma.MemberFitnessGoalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberFitnessGoalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberFitnessGoalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberFitnessGoalPayload>
          }
          findMany: {
            args: Prisma.MemberFitnessGoalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberFitnessGoalPayload>[]
          }
          create: {
            args: Prisma.MemberFitnessGoalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberFitnessGoalPayload>
          }
          createMany: {
            args: Prisma.MemberFitnessGoalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MemberFitnessGoalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberFitnessGoalPayload>[]
          }
          delete: {
            args: Prisma.MemberFitnessGoalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberFitnessGoalPayload>
          }
          update: {
            args: Prisma.MemberFitnessGoalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberFitnessGoalPayload>
          }
          deleteMany: {
            args: Prisma.MemberFitnessGoalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MemberFitnessGoalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MemberFitnessGoalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberFitnessGoalPayload>[]
          }
          upsert: {
            args: Prisma.MemberFitnessGoalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberFitnessGoalPayload>
          }
          aggregate: {
            args: Prisma.MemberFitnessGoalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMemberFitnessGoal>
          }
          groupBy: {
            args: Prisma.MemberFitnessGoalGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemberFitnessGoalGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberFitnessGoalCountArgs<ExtArgs>
            result: $Utils.Optional<MemberFitnessGoalCountAggregateOutputType> | number
          }
        }
      }
      Address: {
        payload: Prisma.$AddressPayload<ExtArgs>
        fields: Prisma.AddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findFirst: {
            args: Prisma.AddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findMany: {
            args: Prisma.AddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          create: {
            args: Prisma.AddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          createMany: {
            args: Prisma.AddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          delete: {
            args: Prisma.AddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          update: {
            args: Prisma.AddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          deleteMany: {
            args: Prisma.AddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AddressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          upsert: {
            args: Prisma.AddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          aggregate: {
            args: Prisma.AddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddress>
          }
          groupBy: {
            args: Prisma.AddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddressCountArgs<ExtArgs>
            result: $Utils.Optional<AddressCountAggregateOutputType> | number
          }
        }
      }
      EmergencyContact: {
        payload: Prisma.$EmergencyContactPayload<ExtArgs>
        fields: Prisma.EmergencyContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmergencyContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmergencyContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>
          }
          findFirst: {
            args: Prisma.EmergencyContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmergencyContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>
          }
          findMany: {
            args: Prisma.EmergencyContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>[]
          }
          create: {
            args: Prisma.EmergencyContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>
          }
          createMany: {
            args: Prisma.EmergencyContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmergencyContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>[]
          }
          delete: {
            args: Prisma.EmergencyContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>
          }
          update: {
            args: Prisma.EmergencyContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>
          }
          deleteMany: {
            args: Prisma.EmergencyContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmergencyContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmergencyContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>[]
          }
          upsert: {
            args: Prisma.EmergencyContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>
          }
          aggregate: {
            args: Prisma.EmergencyContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmergencyContact>
          }
          groupBy: {
            args: Prisma.EmergencyContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmergencyContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmergencyContactCountArgs<ExtArgs>
            result: $Utils.Optional<EmergencyContactCountAggregateOutputType> | number
          }
        }
      }
      MedicalInfo: {
        payload: Prisma.$MedicalInfoPayload<ExtArgs>
        fields: Prisma.MedicalInfoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicalInfoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalInfoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicalInfoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalInfoPayload>
          }
          findFirst: {
            args: Prisma.MedicalInfoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalInfoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicalInfoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalInfoPayload>
          }
          findMany: {
            args: Prisma.MedicalInfoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalInfoPayload>[]
          }
          create: {
            args: Prisma.MedicalInfoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalInfoPayload>
          }
          createMany: {
            args: Prisma.MedicalInfoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicalInfoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalInfoPayload>[]
          }
          delete: {
            args: Prisma.MedicalInfoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalInfoPayload>
          }
          update: {
            args: Prisma.MedicalInfoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalInfoPayload>
          }
          deleteMany: {
            args: Prisma.MedicalInfoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicalInfoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MedicalInfoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalInfoPayload>[]
          }
          upsert: {
            args: Prisma.MedicalInfoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalInfoPayload>
          }
          aggregate: {
            args: Prisma.MedicalInfoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicalInfo>
          }
          groupBy: {
            args: Prisma.MedicalInfoGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicalInfoGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicalInfoCountArgs<ExtArgs>
            result: $Utils.Optional<MedicalInfoCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      MembershipPlan: {
        payload: Prisma.$MembershipPlanPayload<ExtArgs>
        fields: Prisma.MembershipPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MembershipPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MembershipPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPlanPayload>
          }
          findFirst: {
            args: Prisma.MembershipPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MembershipPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPlanPayload>
          }
          findMany: {
            args: Prisma.MembershipPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPlanPayload>[]
          }
          create: {
            args: Prisma.MembershipPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPlanPayload>
          }
          createMany: {
            args: Prisma.MembershipPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MembershipPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPlanPayload>[]
          }
          delete: {
            args: Prisma.MembershipPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPlanPayload>
          }
          update: {
            args: Prisma.MembershipPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPlanPayload>
          }
          deleteMany: {
            args: Prisma.MembershipPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MembershipPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MembershipPlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPlanPayload>[]
          }
          upsert: {
            args: Prisma.MembershipPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPlanPayload>
          }
          aggregate: {
            args: Prisma.MembershipPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMembershipPlan>
          }
          groupBy: {
            args: Prisma.MembershipPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<MembershipPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.MembershipPlanCountArgs<ExtArgs>
            result: $Utils.Optional<MembershipPlanCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      Equipment: {
        payload: Prisma.$EquipmentPayload<ExtArgs>
        fields: Prisma.EquipmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EquipmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EquipmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          findFirst: {
            args: Prisma.EquipmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EquipmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          findMany: {
            args: Prisma.EquipmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>[]
          }
          create: {
            args: Prisma.EquipmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          createMany: {
            args: Prisma.EquipmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EquipmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>[]
          }
          delete: {
            args: Prisma.EquipmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          update: {
            args: Prisma.EquipmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          deleteMany: {
            args: Prisma.EquipmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EquipmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EquipmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>[]
          }
          upsert: {
            args: Prisma.EquipmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          aggregate: {
            args: Prisma.EquipmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEquipment>
          }
          groupBy: {
            args: Prisma.EquipmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EquipmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.EquipmentCountArgs<ExtArgs>
            result: $Utils.Optional<EquipmentCountAggregateOutputType> | number
          }
        }
      }
      MaintenanceLog: {
        payload: Prisma.$MaintenanceLogPayload<ExtArgs>
        fields: Prisma.MaintenanceLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaintenanceLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaintenanceLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceLogPayload>
          }
          findFirst: {
            args: Prisma.MaintenanceLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaintenanceLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceLogPayload>
          }
          findMany: {
            args: Prisma.MaintenanceLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceLogPayload>[]
          }
          create: {
            args: Prisma.MaintenanceLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceLogPayload>
          }
          createMany: {
            args: Prisma.MaintenanceLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaintenanceLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceLogPayload>[]
          }
          delete: {
            args: Prisma.MaintenanceLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceLogPayload>
          }
          update: {
            args: Prisma.MaintenanceLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceLogPayload>
          }
          deleteMany: {
            args: Prisma.MaintenanceLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaintenanceLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MaintenanceLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceLogPayload>[]
          }
          upsert: {
            args: Prisma.MaintenanceLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceLogPayload>
          }
          aggregate: {
            args: Prisma.MaintenanceLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaintenanceLog>
          }
          groupBy: {
            args: Prisma.MaintenanceLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaintenanceLogCountArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceLogCountAggregateOutputType> | number
          }
        }
      }
      SystemIntegration: {
        payload: Prisma.$SystemIntegrationPayload<ExtArgs>
        fields: Prisma.SystemIntegrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemIntegrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemIntegrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemIntegrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemIntegrationPayload>
          }
          findFirst: {
            args: Prisma.SystemIntegrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemIntegrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemIntegrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemIntegrationPayload>
          }
          findMany: {
            args: Prisma.SystemIntegrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemIntegrationPayload>[]
          }
          create: {
            args: Prisma.SystemIntegrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemIntegrationPayload>
          }
          createMany: {
            args: Prisma.SystemIntegrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemIntegrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemIntegrationPayload>[]
          }
          delete: {
            args: Prisma.SystemIntegrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemIntegrationPayload>
          }
          update: {
            args: Prisma.SystemIntegrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemIntegrationPayload>
          }
          deleteMany: {
            args: Prisma.SystemIntegrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemIntegrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemIntegrationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemIntegrationPayload>[]
          }
          upsert: {
            args: Prisma.SystemIntegrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemIntegrationPayload>
          }
          aggregate: {
            args: Prisma.SystemIntegrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemIntegration>
          }
          groupBy: {
            args: Prisma.SystemIntegrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemIntegrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemIntegrationCountArgs<ExtArgs>
            result: $Utils.Optional<SystemIntegrationCountAggregateOutputType> | number
          }
        }
      }
      AutomationWorkflow: {
        payload: Prisma.$AutomationWorkflowPayload<ExtArgs>
        fields: Prisma.AutomationWorkflowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AutomationWorkflowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationWorkflowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutomationWorkflowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationWorkflowPayload>
          }
          findFirst: {
            args: Prisma.AutomationWorkflowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationWorkflowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutomationWorkflowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationWorkflowPayload>
          }
          findMany: {
            args: Prisma.AutomationWorkflowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationWorkflowPayload>[]
          }
          create: {
            args: Prisma.AutomationWorkflowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationWorkflowPayload>
          }
          createMany: {
            args: Prisma.AutomationWorkflowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AutomationWorkflowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationWorkflowPayload>[]
          }
          delete: {
            args: Prisma.AutomationWorkflowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationWorkflowPayload>
          }
          update: {
            args: Prisma.AutomationWorkflowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationWorkflowPayload>
          }
          deleteMany: {
            args: Prisma.AutomationWorkflowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AutomationWorkflowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AutomationWorkflowUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationWorkflowPayload>[]
          }
          upsert: {
            args: Prisma.AutomationWorkflowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationWorkflowPayload>
          }
          aggregate: {
            args: Prisma.AutomationWorkflowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutomationWorkflow>
          }
          groupBy: {
            args: Prisma.AutomationWorkflowGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutomationWorkflowGroupByOutputType>[]
          }
          count: {
            args: Prisma.AutomationWorkflowCountArgs<ExtArgs>
            result: $Utils.Optional<AutomationWorkflowCountAggregateOutputType> | number
          }
        }
      }
      DataSyncJob: {
        payload: Prisma.$DataSyncJobPayload<ExtArgs>
        fields: Prisma.DataSyncJobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DataSyncJobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSyncJobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DataSyncJobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSyncJobPayload>
          }
          findFirst: {
            args: Prisma.DataSyncJobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSyncJobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DataSyncJobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSyncJobPayload>
          }
          findMany: {
            args: Prisma.DataSyncJobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSyncJobPayload>[]
          }
          create: {
            args: Prisma.DataSyncJobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSyncJobPayload>
          }
          createMany: {
            args: Prisma.DataSyncJobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DataSyncJobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSyncJobPayload>[]
          }
          delete: {
            args: Prisma.DataSyncJobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSyncJobPayload>
          }
          update: {
            args: Prisma.DataSyncJobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSyncJobPayload>
          }
          deleteMany: {
            args: Prisma.DataSyncJobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DataSyncJobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DataSyncJobUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSyncJobPayload>[]
          }
          upsert: {
            args: Prisma.DataSyncJobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataSyncJobPayload>
          }
          aggregate: {
            args: Prisma.DataSyncJobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDataSyncJob>
          }
          groupBy: {
            args: Prisma.DataSyncJobGroupByArgs<ExtArgs>
            result: $Utils.Optional<DataSyncJobGroupByOutputType>[]
          }
          count: {
            args: Prisma.DataSyncJobCountArgs<ExtArgs>
            result: $Utils.Optional<DataSyncJobCountAggregateOutputType> | number
          }
        }
      }
      WebhookEndpoint: {
        payload: Prisma.$WebhookEndpointPayload<ExtArgs>
        fields: Prisma.WebhookEndpointFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebhookEndpointFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEndpointPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebhookEndpointFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEndpointPayload>
          }
          findFirst: {
            args: Prisma.WebhookEndpointFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEndpointPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebhookEndpointFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEndpointPayload>
          }
          findMany: {
            args: Prisma.WebhookEndpointFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEndpointPayload>[]
          }
          create: {
            args: Prisma.WebhookEndpointCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEndpointPayload>
          }
          createMany: {
            args: Prisma.WebhookEndpointCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebhookEndpointCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEndpointPayload>[]
          }
          delete: {
            args: Prisma.WebhookEndpointDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEndpointPayload>
          }
          update: {
            args: Prisma.WebhookEndpointUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEndpointPayload>
          }
          deleteMany: {
            args: Prisma.WebhookEndpointDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebhookEndpointUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WebhookEndpointUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEndpointPayload>[]
          }
          upsert: {
            args: Prisma.WebhookEndpointUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEndpointPayload>
          }
          aggregate: {
            args: Prisma.WebhookEndpointAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhookEndpoint>
          }
          groupBy: {
            args: Prisma.WebhookEndpointGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhookEndpointGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebhookEndpointCountArgs<ExtArgs>
            result: $Utils.Optional<WebhookEndpointCountAggregateOutputType> | number
          }
        }
      }
      APIManagement: {
        payload: Prisma.$APIManagementPayload<ExtArgs>
        fields: Prisma.APIManagementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.APIManagementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$APIManagementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.APIManagementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$APIManagementPayload>
          }
          findFirst: {
            args: Prisma.APIManagementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$APIManagementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.APIManagementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$APIManagementPayload>
          }
          findMany: {
            args: Prisma.APIManagementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$APIManagementPayload>[]
          }
          create: {
            args: Prisma.APIManagementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$APIManagementPayload>
          }
          createMany: {
            args: Prisma.APIManagementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.APIManagementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$APIManagementPayload>[]
          }
          delete: {
            args: Prisma.APIManagementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$APIManagementPayload>
          }
          update: {
            args: Prisma.APIManagementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$APIManagementPayload>
          }
          deleteMany: {
            args: Prisma.APIManagementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.APIManagementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.APIManagementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$APIManagementPayload>[]
          }
          upsert: {
            args: Prisma.APIManagementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$APIManagementPayload>
          }
          aggregate: {
            args: Prisma.APIManagementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAPIManagement>
          }
          groupBy: {
            args: Prisma.APIManagementGroupByArgs<ExtArgs>
            result: $Utils.Optional<APIManagementGroupByOutputType>[]
          }
          count: {
            args: Prisma.APIManagementCountArgs<ExtArgs>
            result: $Utils.Optional<APIManagementCountAggregateOutputType> | number
          }
        }
      }
      ThreatDetection: {
        payload: Prisma.$ThreatDetectionPayload<ExtArgs>
        fields: Prisma.ThreatDetectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ThreatDetectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreatDetectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ThreatDetectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreatDetectionPayload>
          }
          findFirst: {
            args: Prisma.ThreatDetectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreatDetectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ThreatDetectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreatDetectionPayload>
          }
          findMany: {
            args: Prisma.ThreatDetectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreatDetectionPayload>[]
          }
          create: {
            args: Prisma.ThreatDetectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreatDetectionPayload>
          }
          createMany: {
            args: Prisma.ThreatDetectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ThreatDetectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreatDetectionPayload>[]
          }
          delete: {
            args: Prisma.ThreatDetectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreatDetectionPayload>
          }
          update: {
            args: Prisma.ThreatDetectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreatDetectionPayload>
          }
          deleteMany: {
            args: Prisma.ThreatDetectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ThreatDetectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ThreatDetectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreatDetectionPayload>[]
          }
          upsert: {
            args: Prisma.ThreatDetectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreatDetectionPayload>
          }
          aggregate: {
            args: Prisma.ThreatDetectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateThreatDetection>
          }
          groupBy: {
            args: Prisma.ThreatDetectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ThreatDetectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ThreatDetectionCountArgs<ExtArgs>
            result: $Utils.Optional<ThreatDetectionCountAggregateOutputType> | number
          }
        }
      }
      AnomalyDetection: {
        payload: Prisma.$AnomalyDetectionPayload<ExtArgs>
        fields: Prisma.AnomalyDetectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnomalyDetectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnomalyDetectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnomalyDetectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnomalyDetectionPayload>
          }
          findFirst: {
            args: Prisma.AnomalyDetectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnomalyDetectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnomalyDetectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnomalyDetectionPayload>
          }
          findMany: {
            args: Prisma.AnomalyDetectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnomalyDetectionPayload>[]
          }
          create: {
            args: Prisma.AnomalyDetectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnomalyDetectionPayload>
          }
          createMany: {
            args: Prisma.AnomalyDetectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnomalyDetectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnomalyDetectionPayload>[]
          }
          delete: {
            args: Prisma.AnomalyDetectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnomalyDetectionPayload>
          }
          update: {
            args: Prisma.AnomalyDetectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnomalyDetectionPayload>
          }
          deleteMany: {
            args: Prisma.AnomalyDetectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnomalyDetectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnomalyDetectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnomalyDetectionPayload>[]
          }
          upsert: {
            args: Prisma.AnomalyDetectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnomalyDetectionPayload>
          }
          aggregate: {
            args: Prisma.AnomalyDetectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnomalyDetection>
          }
          groupBy: {
            args: Prisma.AnomalyDetectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnomalyDetectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnomalyDetectionCountArgs<ExtArgs>
            result: $Utils.Optional<AnomalyDetectionCountAggregateOutputType> | number
          }
        }
      }
      ComplianceReport: {
        payload: Prisma.$ComplianceReportPayload<ExtArgs>
        fields: Prisma.ComplianceReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComplianceReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComplianceReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceReportPayload>
          }
          findFirst: {
            args: Prisma.ComplianceReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComplianceReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceReportPayload>
          }
          findMany: {
            args: Prisma.ComplianceReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceReportPayload>[]
          }
          create: {
            args: Prisma.ComplianceReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceReportPayload>
          }
          createMany: {
            args: Prisma.ComplianceReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComplianceReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceReportPayload>[]
          }
          delete: {
            args: Prisma.ComplianceReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceReportPayload>
          }
          update: {
            args: Prisma.ComplianceReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceReportPayload>
          }
          deleteMany: {
            args: Prisma.ComplianceReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComplianceReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ComplianceReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceReportPayload>[]
          }
          upsert: {
            args: Prisma.ComplianceReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceReportPayload>
          }
          aggregate: {
            args: Prisma.ComplianceReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComplianceReport>
          }
          groupBy: {
            args: Prisma.ComplianceReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComplianceReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComplianceReportCountArgs<ExtArgs>
            result: $Utils.Optional<ComplianceReportCountAggregateOutputType> | number
          }
        }
      }
      SecurityWorkflow: {
        payload: Prisma.$SecurityWorkflowPayload<ExtArgs>
        fields: Prisma.SecurityWorkflowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SecurityWorkflowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityWorkflowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SecurityWorkflowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityWorkflowPayload>
          }
          findFirst: {
            args: Prisma.SecurityWorkflowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityWorkflowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SecurityWorkflowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityWorkflowPayload>
          }
          findMany: {
            args: Prisma.SecurityWorkflowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityWorkflowPayload>[]
          }
          create: {
            args: Prisma.SecurityWorkflowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityWorkflowPayload>
          }
          createMany: {
            args: Prisma.SecurityWorkflowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SecurityWorkflowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityWorkflowPayload>[]
          }
          delete: {
            args: Prisma.SecurityWorkflowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityWorkflowPayload>
          }
          update: {
            args: Prisma.SecurityWorkflowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityWorkflowPayload>
          }
          deleteMany: {
            args: Prisma.SecurityWorkflowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SecurityWorkflowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SecurityWorkflowUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityWorkflowPayload>[]
          }
          upsert: {
            args: Prisma.SecurityWorkflowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityWorkflowPayload>
          }
          aggregate: {
            args: Prisma.SecurityWorkflowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSecurityWorkflow>
          }
          groupBy: {
            args: Prisma.SecurityWorkflowGroupByArgs<ExtArgs>
            result: $Utils.Optional<SecurityWorkflowGroupByOutputType>[]
          }
          count: {
            args: Prisma.SecurityWorkflowCountArgs<ExtArgs>
            result: $Utils.Optional<SecurityWorkflowCountAggregateOutputType> | number
          }
        }
      }
      SecurityIntegration: {
        payload: Prisma.$SecurityIntegrationPayload<ExtArgs>
        fields: Prisma.SecurityIntegrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SecurityIntegrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityIntegrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SecurityIntegrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityIntegrationPayload>
          }
          findFirst: {
            args: Prisma.SecurityIntegrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityIntegrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SecurityIntegrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityIntegrationPayload>
          }
          findMany: {
            args: Prisma.SecurityIntegrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityIntegrationPayload>[]
          }
          create: {
            args: Prisma.SecurityIntegrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityIntegrationPayload>
          }
          createMany: {
            args: Prisma.SecurityIntegrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SecurityIntegrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityIntegrationPayload>[]
          }
          delete: {
            args: Prisma.SecurityIntegrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityIntegrationPayload>
          }
          update: {
            args: Prisma.SecurityIntegrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityIntegrationPayload>
          }
          deleteMany: {
            args: Prisma.SecurityIntegrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SecurityIntegrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SecurityIntegrationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityIntegrationPayload>[]
          }
          upsert: {
            args: Prisma.SecurityIntegrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityIntegrationPayload>
          }
          aggregate: {
            args: Prisma.SecurityIntegrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSecurityIntegration>
          }
          groupBy: {
            args: Prisma.SecurityIntegrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<SecurityIntegrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.SecurityIntegrationCountArgs<ExtArgs>
            result: $Utils.Optional<SecurityIntegrationCountAggregateOutputType> | number
          }
        }
      }
      AdministrativeProfile: {
        payload: Prisma.$AdministrativeProfilePayload<ExtArgs>
        fields: Prisma.AdministrativeProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdministrativeProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministrativeProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdministrativeProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministrativeProfilePayload>
          }
          findFirst: {
            args: Prisma.AdministrativeProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministrativeProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdministrativeProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministrativeProfilePayload>
          }
          findMany: {
            args: Prisma.AdministrativeProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministrativeProfilePayload>[]
          }
          create: {
            args: Prisma.AdministrativeProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministrativeProfilePayload>
          }
          createMany: {
            args: Prisma.AdministrativeProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdministrativeProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministrativeProfilePayload>[]
          }
          delete: {
            args: Prisma.AdministrativeProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministrativeProfilePayload>
          }
          update: {
            args: Prisma.AdministrativeProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministrativeProfilePayload>
          }
          deleteMany: {
            args: Prisma.AdministrativeProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdministrativeProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdministrativeProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministrativeProfilePayload>[]
          }
          upsert: {
            args: Prisma.AdministrativeProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministrativeProfilePayload>
          }
          aggregate: {
            args: Prisma.AdministrativeProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdministrativeProfile>
          }
          groupBy: {
            args: Prisma.AdministrativeProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdministrativeProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdministrativeProfileCountArgs<ExtArgs>
            result: $Utils.Optional<AdministrativeProfileCountAggregateOutputType> | number
          }
        }
      }
      CustomRole: {
        payload: Prisma.$CustomRolePayload<ExtArgs>
        fields: Prisma.CustomRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomRolePayload>
          }
          findFirst: {
            args: Prisma.CustomRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomRolePayload>
          }
          findMany: {
            args: Prisma.CustomRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomRolePayload>[]
          }
          create: {
            args: Prisma.CustomRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomRolePayload>
          }
          createMany: {
            args: Prisma.CustomRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomRolePayload>[]
          }
          delete: {
            args: Prisma.CustomRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomRolePayload>
          }
          update: {
            args: Prisma.CustomRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomRolePayload>
          }
          deleteMany: {
            args: Prisma.CustomRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomRoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomRolePayload>[]
          }
          upsert: {
            args: Prisma.CustomRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomRolePayload>
          }
          aggregate: {
            args: Prisma.CustomRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomRole>
          }
          groupBy: {
            args: Prisma.CustomRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomRoleCountArgs<ExtArgs>
            result: $Utils.Optional<CustomRoleCountAggregateOutputType> | number
          }
        }
      }
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>
        fields: Prisma.PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      RoleHierarchy: {
        payload: Prisma.$RoleHierarchyPayload<ExtArgs>
        fields: Prisma.RoleHierarchyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleHierarchyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleHierarchyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleHierarchyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleHierarchyPayload>
          }
          findFirst: {
            args: Prisma.RoleHierarchyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleHierarchyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleHierarchyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleHierarchyPayload>
          }
          findMany: {
            args: Prisma.RoleHierarchyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleHierarchyPayload>[]
          }
          create: {
            args: Prisma.RoleHierarchyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleHierarchyPayload>
          }
          createMany: {
            args: Prisma.RoleHierarchyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleHierarchyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleHierarchyPayload>[]
          }
          delete: {
            args: Prisma.RoleHierarchyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleHierarchyPayload>
          }
          update: {
            args: Prisma.RoleHierarchyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleHierarchyPayload>
          }
          deleteMany: {
            args: Prisma.RoleHierarchyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleHierarchyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleHierarchyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleHierarchyPayload>[]
          }
          upsert: {
            args: Prisma.RoleHierarchyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleHierarchyPayload>
          }
          aggregate: {
            args: Prisma.RoleHierarchyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoleHierarchy>
          }
          groupBy: {
            args: Prisma.RoleHierarchyGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleHierarchyGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleHierarchyCountArgs<ExtArgs>
            result: $Utils.Optional<RoleHierarchyCountAggregateOutputType> | number
          }
        }
      }
      PermissionAudit: {
        payload: Prisma.$PermissionAuditPayload<ExtArgs>
        fields: Prisma.PermissionAuditFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionAuditFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionAuditPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionAuditFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionAuditPayload>
          }
          findFirst: {
            args: Prisma.PermissionAuditFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionAuditPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionAuditFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionAuditPayload>
          }
          findMany: {
            args: Prisma.PermissionAuditFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionAuditPayload>[]
          }
          create: {
            args: Prisma.PermissionAuditCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionAuditPayload>
          }
          createMany: {
            args: Prisma.PermissionAuditCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PermissionAuditCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionAuditPayload>[]
          }
          delete: {
            args: Prisma.PermissionAuditDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionAuditPayload>
          }
          update: {
            args: Prisma.PermissionAuditUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionAuditPayload>
          }
          deleteMany: {
            args: Prisma.PermissionAuditDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionAuditUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PermissionAuditUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionAuditPayload>[]
          }
          upsert: {
            args: Prisma.PermissionAuditUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionAuditPayload>
          }
          aggregate: {
            args: Prisma.PermissionAuditAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermissionAudit>
          }
          groupBy: {
            args: Prisma.PermissionAuditGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionAuditGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionAuditCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionAuditCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    userSession?: UserSessionOmit
    userAccessLog?: UserAccessLogOmit
    userIPRestriction?: UserIPRestrictionOmit
    userAddress?: UserAddressOmit
    userEmergencyContact?: UserEmergencyContactOmit
    userSocialMedia?: UserSocialMediaOmit
    userPreferences?: UserPreferencesOmit
    userNotificationSettings?: UserNotificationSettingsOmit
    userPrivacySettings?: UserPrivacySettingsOmit
    member?: MemberOmit
    memberCheckIn?: MemberCheckInOmit
    memberAttendance?: MemberAttendanceOmit
    memberFitnessGoal?: MemberFitnessGoalOmit
    address?: AddressOmit
    emergencyContact?: EmergencyContactOmit
    medicalInfo?: MedicalInfoOmit
    payment?: PaymentOmit
    invoice?: InvoiceOmit
    membershipPlan?: MembershipPlanOmit
    subscription?: SubscriptionOmit
    equipment?: EquipmentOmit
    maintenanceLog?: MaintenanceLogOmit
    systemIntegration?: SystemIntegrationOmit
    automationWorkflow?: AutomationWorkflowOmit
    dataSyncJob?: DataSyncJobOmit
    webhookEndpoint?: WebhookEndpointOmit
    aPIManagement?: APIManagementOmit
    threatDetection?: ThreatDetectionOmit
    anomalyDetection?: AnomalyDetectionOmit
    complianceReport?: ComplianceReportOmit
    securityWorkflow?: SecurityWorkflowOmit
    securityIntegration?: SecurityIntegrationOmit
    administrativeProfile?: AdministrativeProfileOmit
    customRole?: CustomRoleOmit
    permission?: PermissionOmit
    roleHierarchy?: RoleHierarchyOmit
    permissionAudit?: PermissionAuditOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    permission_audits: number
    access_logs: number
    ip_restrictions: number
    sessions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permission_audits?: boolean | UserCountOutputTypeCountPermission_auditsArgs
    access_logs?: boolean | UserCountOutputTypeCountAccess_logsArgs
    ip_restrictions?: boolean | UserCountOutputTypeCountIp_restrictionsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPermission_auditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionAuditWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccess_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAccessLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountIp_restrictionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserIPRestrictionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
  }


  /**
   * Count Type MemberCountOutputType
   */

  export type MemberCountOutputType = {
    invoices: number
    attendance: number
    check_ins: number
    fitness_goals: number
    payments: number
    Subscription: number
  }

  export type MemberCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | MemberCountOutputTypeCountInvoicesArgs
    attendance?: boolean | MemberCountOutputTypeCountAttendanceArgs
    check_ins?: boolean | MemberCountOutputTypeCountCheck_insArgs
    fitness_goals?: boolean | MemberCountOutputTypeCountFitness_goalsArgs
    payments?: boolean | MemberCountOutputTypeCountPaymentsArgs
    Subscription?: boolean | MemberCountOutputTypeCountSubscriptionArgs
  }

  // Custom InputTypes
  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCountOutputType
     */
    select?: MemberCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberAttendanceWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountCheck_insArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberCheckInWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountFitness_goalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberFitnessGoalWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }


  /**
   * Count Type MembershipPlanCountOutputType
   */

  export type MembershipPlanCountOutputType = {
    subscriptions: number
  }

  export type MembershipPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | MembershipPlanCountOutputTypeCountSubscriptionsArgs
  }

  // Custom InputTypes
  /**
   * MembershipPlanCountOutputType without action
   */
  export type MembershipPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipPlanCountOutputType
     */
    select?: MembershipPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MembershipPlanCountOutputType without action
   */
  export type MembershipPlanCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }


  /**
   * Count Type EquipmentCountOutputType
   */

  export type EquipmentCountOutputType = {
    maintenanceLogs: number
  }

  export type EquipmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    maintenanceLogs?: boolean | EquipmentCountOutputTypeCountMaintenanceLogsArgs
  }

  // Custom InputTypes
  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCountOutputType
     */
    select?: EquipmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeCountMaintenanceLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceLogWhereInput
  }


  /**
   * Count Type RoleHierarchyCountOutputType
   */

  export type RoleHierarchyCountOutputType = {
    children: number
  }

  export type RoleHierarchyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | RoleHierarchyCountOutputTypeCountChildrenArgs
  }

  // Custom InputTypes
  /**
   * RoleHierarchyCountOutputType without action
   */
  export type RoleHierarchyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleHierarchyCountOutputType
     */
    select?: RoleHierarchyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleHierarchyCountOutputType without action
   */
  export type RoleHierarchyCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleHierarchyWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    tokenVersion: number | null
    loginAttempts: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    tokenVersion: number | null
    loginAttempts: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    name: string | null
    username: string | null
    email: string | null
    phone_number: string | null
    password: string | null
    role: string | null
    profile_picture: string | null
    tokenVersion: number | null
    created_at: Date | null
    updated_at: Date | null
    resetToken: string | null
    resetTokenExp: Date | null
    bio: string | null
    dateOfBirth: Date | null
    department: string | null
    email_verified: boolean | null
    gender: string | null
    isActive: boolean | null
    lastLogin: Date | null
    lockedUntil: Date | null
    loginAttempts: number | null
    position: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    username: string | null
    email: string | null
    phone_number: string | null
    password: string | null
    role: string | null
    profile_picture: string | null
    tokenVersion: number | null
    created_at: Date | null
    updated_at: Date | null
    resetToken: string | null
    resetTokenExp: Date | null
    bio: string | null
    dateOfBirth: Date | null
    department: string | null
    email_verified: boolean | null
    gender: string | null
    isActive: boolean | null
    lastLogin: Date | null
    lockedUntil: Date | null
    loginAttempts: number | null
    position: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    username: number
    email: number
    phone_number: number
    password: number
    role: number
    profile_picture: number
    tokenVersion: number
    created_at: number
    updated_at: number
    resetToken: number
    resetTokenExp: number
    bio: number
    dateOfBirth: number
    department: number
    email_verified: number
    gender: number
    isActive: number
    lastLogin: number
    lockedUntil: number
    loginAttempts: number
    position: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    tokenVersion?: true
    loginAttempts?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    tokenVersion?: true
    loginAttempts?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    username?: true
    email?: true
    phone_number?: true
    password?: true
    role?: true
    profile_picture?: true
    tokenVersion?: true
    created_at?: true
    updated_at?: true
    resetToken?: true
    resetTokenExp?: true
    bio?: true
    dateOfBirth?: true
    department?: true
    email_verified?: true
    gender?: true
    isActive?: true
    lastLogin?: true
    lockedUntil?: true
    loginAttempts?: true
    position?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    username?: true
    email?: true
    phone_number?: true
    password?: true
    role?: true
    profile_picture?: true
    tokenVersion?: true
    created_at?: true
    updated_at?: true
    resetToken?: true
    resetTokenExp?: true
    bio?: true
    dateOfBirth?: true
    department?: true
    email_verified?: true
    gender?: true
    isActive?: true
    lastLogin?: true
    lockedUntil?: true
    loginAttempts?: true
    position?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    username?: true
    email?: true
    phone_number?: true
    password?: true
    role?: true
    profile_picture?: true
    tokenVersion?: true
    created_at?: true
    updated_at?: true
    resetToken?: true
    resetTokenExp?: true
    bio?: true
    dateOfBirth?: true
    department?: true
    email_verified?: true
    gender?: true
    isActive?: true
    lastLogin?: true
    lockedUntil?: true
    loginAttempts?: true
    position?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    name: string
    username: string | null
    email: string
    phone_number: string | null
    password: string
    role: string
    profile_picture: string | null
    tokenVersion: number
    created_at: Date
    updated_at: Date
    resetToken: string | null
    resetTokenExp: Date | null
    bio: string | null
    dateOfBirth: Date | null
    department: string | null
    email_verified: boolean
    gender: string | null
    isActive: boolean
    lastLogin: Date | null
    lockedUntil: Date | null
    loginAttempts: number
    position: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    username?: boolean
    email?: boolean
    phone_number?: boolean
    password?: boolean
    role?: boolean
    profile_picture?: boolean
    tokenVersion?: boolean
    created_at?: boolean
    updated_at?: boolean
    resetToken?: boolean
    resetTokenExp?: boolean
    bio?: boolean
    dateOfBirth?: boolean
    department?: boolean
    email_verified?: boolean
    gender?: boolean
    isActive?: boolean
    lastLogin?: boolean
    lockedUntil?: boolean
    loginAttempts?: boolean
    position?: boolean
    admin_profile?: boolean | User$admin_profileArgs<ExtArgs>
    permission_audits?: boolean | User$permission_auditsArgs<ExtArgs>
    access_logs?: boolean | User$access_logsArgs<ExtArgs>
    address?: boolean | User$addressArgs<ExtArgs>
    emergency_contact?: boolean | User$emergency_contactArgs<ExtArgs>
    ip_restrictions?: boolean | User$ip_restrictionsArgs<ExtArgs>
    notification_settings?: boolean | User$notification_settingsArgs<ExtArgs>
    preferences?: boolean | User$preferencesArgs<ExtArgs>
    privacy_settings?: boolean | User$privacy_settingsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    social_media?: boolean | User$social_mediaArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    username?: boolean
    email?: boolean
    phone_number?: boolean
    password?: boolean
    role?: boolean
    profile_picture?: boolean
    tokenVersion?: boolean
    created_at?: boolean
    updated_at?: boolean
    resetToken?: boolean
    resetTokenExp?: boolean
    bio?: boolean
    dateOfBirth?: boolean
    department?: boolean
    email_verified?: boolean
    gender?: boolean
    isActive?: boolean
    lastLogin?: boolean
    lockedUntil?: boolean
    loginAttempts?: boolean
    position?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    username?: boolean
    email?: boolean
    phone_number?: boolean
    password?: boolean
    role?: boolean
    profile_picture?: boolean
    tokenVersion?: boolean
    created_at?: boolean
    updated_at?: boolean
    resetToken?: boolean
    resetTokenExp?: boolean
    bio?: boolean
    dateOfBirth?: boolean
    department?: boolean
    email_verified?: boolean
    gender?: boolean
    isActive?: boolean
    lastLogin?: boolean
    lockedUntil?: boolean
    loginAttempts?: boolean
    position?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    username?: boolean
    email?: boolean
    phone_number?: boolean
    password?: boolean
    role?: boolean
    profile_picture?: boolean
    tokenVersion?: boolean
    created_at?: boolean
    updated_at?: boolean
    resetToken?: boolean
    resetTokenExp?: boolean
    bio?: boolean
    dateOfBirth?: boolean
    department?: boolean
    email_verified?: boolean
    gender?: boolean
    isActive?: boolean
    lastLogin?: boolean
    lockedUntil?: boolean
    loginAttempts?: boolean
    position?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "username" | "email" | "phone_number" | "password" | "role" | "profile_picture" | "tokenVersion" | "created_at" | "updated_at" | "resetToken" | "resetTokenExp" | "bio" | "dateOfBirth" | "department" | "email_verified" | "gender" | "isActive" | "lastLogin" | "lockedUntil" | "loginAttempts" | "position", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin_profile?: boolean | User$admin_profileArgs<ExtArgs>
    permission_audits?: boolean | User$permission_auditsArgs<ExtArgs>
    access_logs?: boolean | User$access_logsArgs<ExtArgs>
    address?: boolean | User$addressArgs<ExtArgs>
    emergency_contact?: boolean | User$emergency_contactArgs<ExtArgs>
    ip_restrictions?: boolean | User$ip_restrictionsArgs<ExtArgs>
    notification_settings?: boolean | User$notification_settingsArgs<ExtArgs>
    preferences?: boolean | User$preferencesArgs<ExtArgs>
    privacy_settings?: boolean | User$privacy_settingsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    social_media?: boolean | User$social_mediaArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      admin_profile: Prisma.$AdministrativeProfilePayload<ExtArgs> | null
      permission_audits: Prisma.$PermissionAuditPayload<ExtArgs>[]
      access_logs: Prisma.$UserAccessLogPayload<ExtArgs>[]
      address: Prisma.$UserAddressPayload<ExtArgs> | null
      emergency_contact: Prisma.$UserEmergencyContactPayload<ExtArgs> | null
      ip_restrictions: Prisma.$UserIPRestrictionPayload<ExtArgs>[]
      notification_settings: Prisma.$UserNotificationSettingsPayload<ExtArgs> | null
      preferences: Prisma.$UserPreferencesPayload<ExtArgs> | null
      privacy_settings: Prisma.$UserPrivacySettingsPayload<ExtArgs> | null
      sessions: Prisma.$UserSessionPayload<ExtArgs>[]
      social_media: Prisma.$UserSocialMediaPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      username: string | null
      email: string
      phone_number: string | null
      password: string
      role: string
      profile_picture: string | null
      tokenVersion: number
      created_at: Date
      updated_at: Date
      resetToken: string | null
      resetTokenExp: Date | null
      bio: string | null
      dateOfBirth: Date | null
      department: string | null
      email_verified: boolean
      gender: string | null
      isActive: boolean
      lastLogin: Date | null
      lockedUntil: Date | null
      loginAttempts: number
      position: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin_profile<T extends User$admin_profileArgs<ExtArgs> = {}>(args?: Subset<T, User$admin_profileArgs<ExtArgs>>): Prisma__AdministrativeProfileClient<$Result.GetResult<Prisma.$AdministrativeProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    permission_audits<T extends User$permission_auditsArgs<ExtArgs> = {}>(args?: Subset<T, User$permission_auditsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionAuditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    access_logs<T extends User$access_logsArgs<ExtArgs> = {}>(args?: Subset<T, User$access_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAccessLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    address<T extends User$addressArgs<ExtArgs> = {}>(args?: Subset<T, User$addressArgs<ExtArgs>>): Prisma__UserAddressClient<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    emergency_contact<T extends User$emergency_contactArgs<ExtArgs> = {}>(args?: Subset<T, User$emergency_contactArgs<ExtArgs>>): Prisma__UserEmergencyContactClient<$Result.GetResult<Prisma.$UserEmergencyContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ip_restrictions<T extends User$ip_restrictionsArgs<ExtArgs> = {}>(args?: Subset<T, User$ip_restrictionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserIPRestrictionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notification_settings<T extends User$notification_settingsArgs<ExtArgs> = {}>(args?: Subset<T, User$notification_settingsArgs<ExtArgs>>): Prisma__UserNotificationSettingsClient<$Result.GetResult<Prisma.$UserNotificationSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    preferences<T extends User$preferencesArgs<ExtArgs> = {}>(args?: Subset<T, User$preferencesArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    privacy_settings<T extends User$privacy_settingsArgs<ExtArgs> = {}>(args?: Subset<T, User$privacy_settingsArgs<ExtArgs>>): Prisma__UserPrivacySettingsClient<$Result.GetResult<Prisma.$UserPrivacySettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    social_media<T extends User$social_mediaArgs<ExtArgs> = {}>(args?: Subset<T, User$social_mediaArgs<ExtArgs>>): Prisma__UserSocialMediaClient<$Result.GetResult<Prisma.$UserSocialMediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly name: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly phone_number: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly profile_picture: FieldRef<"User", 'String'>
    readonly tokenVersion: FieldRef<"User", 'Int'>
    readonly created_at: FieldRef<"User", 'DateTime'>
    readonly updated_at: FieldRef<"User", 'DateTime'>
    readonly resetToken: FieldRef<"User", 'String'>
    readonly resetTokenExp: FieldRef<"User", 'DateTime'>
    readonly bio: FieldRef<"User", 'String'>
    readonly dateOfBirth: FieldRef<"User", 'DateTime'>
    readonly department: FieldRef<"User", 'String'>
    readonly email_verified: FieldRef<"User", 'Boolean'>
    readonly gender: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
    readonly lockedUntil: FieldRef<"User", 'DateTime'>
    readonly loginAttempts: FieldRef<"User", 'Int'>
    readonly position: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.admin_profile
   */
  export type User$admin_profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdministrativeProfile
     */
    select?: AdministrativeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdministrativeProfile
     */
    omit?: AdministrativeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministrativeProfileInclude<ExtArgs> | null
    where?: AdministrativeProfileWhereInput
  }

  /**
   * User.permission_audits
   */
  export type User$permission_auditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionAudit
     */
    select?: PermissionAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermissionAudit
     */
    omit?: PermissionAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionAuditInclude<ExtArgs> | null
    where?: PermissionAuditWhereInput
    orderBy?: PermissionAuditOrderByWithRelationInput | PermissionAuditOrderByWithRelationInput[]
    cursor?: PermissionAuditWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PermissionAuditScalarFieldEnum | PermissionAuditScalarFieldEnum[]
  }

  /**
   * User.access_logs
   */
  export type User$access_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccessLog
     */
    select?: UserAccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccessLog
     */
    omit?: UserAccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccessLogInclude<ExtArgs> | null
    where?: UserAccessLogWhereInput
    orderBy?: UserAccessLogOrderByWithRelationInput | UserAccessLogOrderByWithRelationInput[]
    cursor?: UserAccessLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAccessLogScalarFieldEnum | UserAccessLogScalarFieldEnum[]
  }

  /**
   * User.address
   */
  export type User$addressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAddress
     */
    omit?: UserAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    where?: UserAddressWhereInput
  }

  /**
   * User.emergency_contact
   */
  export type User$emergency_contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmergencyContact
     */
    select?: UserEmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEmergencyContact
     */
    omit?: UserEmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmergencyContactInclude<ExtArgs> | null
    where?: UserEmergencyContactWhereInput
  }

  /**
   * User.ip_restrictions
   */
  export type User$ip_restrictionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIPRestriction
     */
    select?: UserIPRestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserIPRestriction
     */
    omit?: UserIPRestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIPRestrictionInclude<ExtArgs> | null
    where?: UserIPRestrictionWhereInput
    orderBy?: UserIPRestrictionOrderByWithRelationInput | UserIPRestrictionOrderByWithRelationInput[]
    cursor?: UserIPRestrictionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserIPRestrictionScalarFieldEnum | UserIPRestrictionScalarFieldEnum[]
  }

  /**
   * User.notification_settings
   */
  export type User$notification_settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationSettings
     */
    select?: UserNotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNotificationSettings
     */
    omit?: UserNotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationSettingsInclude<ExtArgs> | null
    where?: UserNotificationSettingsWhereInput
  }

  /**
   * User.preferences
   */
  export type User$preferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    where?: UserPreferencesWhereInput
  }

  /**
   * User.privacy_settings
   */
  export type User$privacy_settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPrivacySettings
     */
    select?: UserPrivacySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPrivacySettings
     */
    omit?: UserPrivacySettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPrivacySettingsInclude<ExtArgs> | null
    where?: UserPrivacySettingsWhereInput
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    cursor?: UserSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * User.social_media
   */
  export type User$social_mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocialMedia
     */
    select?: UserSocialMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocialMedia
     */
    omit?: UserSocialMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialMediaInclude<ExtArgs> | null
    where?: UserSocialMediaWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserSession
   */

  export type AggregateUserSession = {
    _count: UserSessionCountAggregateOutputType | null
    _avg: UserSessionAvgAggregateOutputType | null
    _sum: UserSessionSumAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  export type UserSessionAvgAggregateOutputType = {
    userId: number | null
  }

  export type UserSessionSumAggregateOutputType = {
    userId: number | null
  }

  export type UserSessionMinAggregateOutputType = {
    id: string | null
    userId: number | null
    token: string | null
    deviceType: string | null
    deviceInfo: string | null
    ipAddress: string | null
    userAgent: string | null
    isActive: boolean | null
    lastActivity: Date | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSessionMaxAggregateOutputType = {
    id: string | null
    userId: number | null
    token: string | null
    deviceType: string | null
    deviceInfo: string | null
    ipAddress: string | null
    userAgent: string | null
    isActive: boolean | null
    lastActivity: Date | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSessionCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    deviceType: number
    deviceInfo: number
    ipAddress: number
    userAgent: number
    isActive: number
    lastActivity: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserSessionAvgAggregateInputType = {
    userId?: true
  }

  export type UserSessionSumAggregateInputType = {
    userId?: true
  }

  export type UserSessionMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    deviceType?: true
    deviceInfo?: true
    ipAddress?: true
    userAgent?: true
    isActive?: true
    lastActivity?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    deviceType?: true
    deviceInfo?: true
    ipAddress?: true
    userAgent?: true
    isActive?: true
    lastActivity?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSessionCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    deviceType?: true
    deviceInfo?: true
    ipAddress?: true
    userAgent?: true
    isActive?: true
    lastActivity?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSession to aggregate.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSessions
    **/
    _count?: true | UserSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSessionMaxAggregateInputType
  }

  export type GetUserSessionAggregateType<T extends UserSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSession[P]>
      : GetScalarType<T[P], AggregateUserSession[P]>
  }




  export type UserSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithAggregationInput | UserSessionOrderByWithAggregationInput[]
    by: UserSessionScalarFieldEnum[] | UserSessionScalarFieldEnum
    having?: UserSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSessionCountAggregateInputType | true
    _avg?: UserSessionAvgAggregateInputType
    _sum?: UserSessionSumAggregateInputType
    _min?: UserSessionMinAggregateInputType
    _max?: UserSessionMaxAggregateInputType
  }

  export type UserSessionGroupByOutputType = {
    id: string
    userId: number
    token: string
    deviceType: string | null
    deviceInfo: string | null
    ipAddress: string | null
    userAgent: string | null
    isActive: boolean
    lastActivity: Date
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: UserSessionCountAggregateOutputType | null
    _avg: UserSessionAvgAggregateOutputType | null
    _sum: UserSessionSumAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  type GetUserSessionGroupByPayload<T extends UserSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
            : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
        }
      >
    >


  export type UserSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    deviceType?: boolean
    deviceInfo?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    isActive?: boolean
    lastActivity?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    deviceType?: boolean
    deviceInfo?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    isActive?: boolean
    lastActivity?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    deviceType?: boolean
    deviceInfo?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    isActive?: boolean
    lastActivity?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    deviceType?: boolean
    deviceInfo?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    isActive?: boolean
    lastActivity?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "deviceType" | "deviceInfo" | "ipAddress" | "userAgent" | "isActive" | "lastActivity" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["userSession"]>
  export type UserSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: number
      token: string
      deviceType: string | null
      deviceInfo: string | null
      ipAddress: string | null
      userAgent: string | null
      isActive: boolean
      lastActivity: Date
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userSession"]>
    composites: {}
  }

  type UserSessionGetPayload<S extends boolean | null | undefined | UserSessionDefaultArgs> = $Result.GetResult<Prisma.$UserSessionPayload, S>

  type UserSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSessionCountAggregateInputType | true
    }

  export interface UserSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSession'], meta: { name: 'UserSession' } }
    /**
     * Find zero or one UserSession that matches the filter.
     * @param {UserSessionFindUniqueArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSessionFindUniqueArgs>(args: SelectSubset<T, UserSessionFindUniqueArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSessionFindUniqueOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSessionFindFirstArgs>(args?: SelectSubset<T, UserSessionFindFirstArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSessions
     * const userSessions = await prisma.userSession.findMany()
     * 
     * // Get first 10 UserSessions
     * const userSessions = await prisma.userSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSessionWithIdOnly = await prisma.userSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSessionFindManyArgs>(args?: SelectSubset<T, UserSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSession.
     * @param {UserSessionCreateArgs} args - Arguments to create a UserSession.
     * @example
     * // Create one UserSession
     * const UserSession = await prisma.userSession.create({
     *   data: {
     *     // ... data to create a UserSession
     *   }
     * })
     * 
     */
    create<T extends UserSessionCreateArgs>(args: SelectSubset<T, UserSessionCreateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSessions.
     * @param {UserSessionCreateManyArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSessionCreateManyArgs>(args?: SelectSubset<T, UserSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSessions and returns the data saved in the database.
     * @param {UserSessionCreateManyAndReturnArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSessions and only return the `id`
     * const userSessionWithIdOnly = await prisma.userSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSession.
     * @param {UserSessionDeleteArgs} args - Arguments to delete one UserSession.
     * @example
     * // Delete one UserSession
     * const UserSession = await prisma.userSession.delete({
     *   where: {
     *     // ... filter to delete one UserSession
     *   }
     * })
     * 
     */
    delete<T extends UserSessionDeleteArgs>(args: SelectSubset<T, UserSessionDeleteArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSession.
     * @param {UserSessionUpdateArgs} args - Arguments to update one UserSession.
     * @example
     * // Update one UserSession
     * const userSession = await prisma.userSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSessionUpdateArgs>(args: SelectSubset<T, UserSessionUpdateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSessions.
     * @param {UserSessionDeleteManyArgs} args - Arguments to filter UserSessions to delete.
     * @example
     * // Delete a few UserSessions
     * const { count } = await prisma.userSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSessionDeleteManyArgs>(args?: SelectSubset<T, UserSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSessions
     * const userSession = await prisma.userSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSessionUpdateManyArgs>(args: SelectSubset<T, UserSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions and returns the data updated in the database.
     * @param {UserSessionUpdateManyAndReturnArgs} args - Arguments to update many UserSessions.
     * @example
     * // Update many UserSessions
     * const userSession = await prisma.userSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSessions and only return the `id`
     * const userSessionWithIdOnly = await prisma.userSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSession.
     * @param {UserSessionUpsertArgs} args - Arguments to update or create a UserSession.
     * @example
     * // Update or create a UserSession
     * const userSession = await prisma.userSession.upsert({
     *   create: {
     *     // ... data to create a UserSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSession we want to update
     *   }
     * })
     */
    upsert<T extends UserSessionUpsertArgs>(args: SelectSubset<T, UserSessionUpsertArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionCountArgs} args - Arguments to filter UserSessions to count.
     * @example
     * // Count the number of UserSessions
     * const count = await prisma.userSession.count({
     *   where: {
     *     // ... the filter for the UserSessions we want to count
     *   }
     * })
    **/
    count<T extends UserSessionCountArgs>(
      args?: Subset<T, UserSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSessionAggregateArgs>(args: Subset<T, UserSessionAggregateArgs>): Prisma.PrismaPromise<GetUserSessionAggregateType<T>>

    /**
     * Group by UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSessionGroupByArgs['orderBy'] }
        : { orderBy?: UserSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSession model
   */
  readonly fields: UserSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSession model
   */
  interface UserSessionFieldRefs {
    readonly id: FieldRef<"UserSession", 'String'>
    readonly userId: FieldRef<"UserSession", 'Int'>
    readonly token: FieldRef<"UserSession", 'String'>
    readonly deviceType: FieldRef<"UserSession", 'String'>
    readonly deviceInfo: FieldRef<"UserSession", 'String'>
    readonly ipAddress: FieldRef<"UserSession", 'String'>
    readonly userAgent: FieldRef<"UserSession", 'String'>
    readonly isActive: FieldRef<"UserSession", 'Boolean'>
    readonly lastActivity: FieldRef<"UserSession", 'DateTime'>
    readonly expiresAt: FieldRef<"UserSession", 'DateTime'>
    readonly createdAt: FieldRef<"UserSession", 'DateTime'>
    readonly updatedAt: FieldRef<"UserSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSession findUnique
   */
  export type UserSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findUniqueOrThrow
   */
  export type UserSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findFirst
   */
  export type UserSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findFirstOrThrow
   */
  export type UserSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findMany
   */
  export type UserSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSessions to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession create
   */
  export type UserSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSession.
     */
    data: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
  }

  /**
   * UserSession createMany
   */
  export type UserSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSession createManyAndReturn
   */
  export type UserSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSession update
   */
  export type UserSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSession.
     */
    data: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
    /**
     * Choose, which UserSession to update.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession updateMany
   */
  export type UserSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSessions.
     */
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyInput>
    /**
     * Filter which UserSessions to update
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to update.
     */
    limit?: number
  }

  /**
   * UserSession updateManyAndReturn
   */
  export type UserSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * The data used to update UserSessions.
     */
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyInput>
    /**
     * Filter which UserSessions to update
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSession upsert
   */
  export type UserSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSession to update in case it exists.
     */
    where: UserSessionWhereUniqueInput
    /**
     * In case the UserSession found by the `where` argument doesn't exist, create a new UserSession with this data.
     */
    create: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
    /**
     * In case the UserSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
  }

  /**
   * UserSession delete
   */
  export type UserSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter which UserSession to delete.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession deleteMany
   */
  export type UserSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSessions to delete
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to delete.
     */
    limit?: number
  }

  /**
   * UserSession without action
   */
  export type UserSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
  }


  /**
   * Model UserAccessLog
   */

  export type AggregateUserAccessLog = {
    _count: UserAccessLogCountAggregateOutputType | null
    _avg: UserAccessLogAvgAggregateOutputType | null
    _sum: UserAccessLogSumAggregateOutputType | null
    _min: UserAccessLogMinAggregateOutputType | null
    _max: UserAccessLogMaxAggregateOutputType | null
  }

  export type UserAccessLogAvgAggregateOutputType = {
    userId: number | null
  }

  export type UserAccessLogSumAggregateOutputType = {
    userId: number | null
  }

  export type UserAccessLogMinAggregateOutputType = {
    id: string | null
    userId: number | null
    action: string | null
    ipAddress: string | null
    userAgent: string | null
    success: boolean | null
    details: string | null
    createdAt: Date | null
  }

  export type UserAccessLogMaxAggregateOutputType = {
    id: string | null
    userId: number | null
    action: string | null
    ipAddress: string | null
    userAgent: string | null
    success: boolean | null
    details: string | null
    createdAt: Date | null
  }

  export type UserAccessLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    ipAddress: number
    userAgent: number
    success: number
    details: number
    createdAt: number
    _all: number
  }


  export type UserAccessLogAvgAggregateInputType = {
    userId?: true
  }

  export type UserAccessLogSumAggregateInputType = {
    userId?: true
  }

  export type UserAccessLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    ipAddress?: true
    userAgent?: true
    success?: true
    details?: true
    createdAt?: true
  }

  export type UserAccessLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    ipAddress?: true
    userAgent?: true
    success?: true
    details?: true
    createdAt?: true
  }

  export type UserAccessLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    ipAddress?: true
    userAgent?: true
    success?: true
    details?: true
    createdAt?: true
    _all?: true
  }

  export type UserAccessLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAccessLog to aggregate.
     */
    where?: UserAccessLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAccessLogs to fetch.
     */
    orderBy?: UserAccessLogOrderByWithRelationInput | UserAccessLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAccessLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAccessLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAccessLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAccessLogs
    **/
    _count?: true | UserAccessLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAccessLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserAccessLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAccessLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAccessLogMaxAggregateInputType
  }

  export type GetUserAccessLogAggregateType<T extends UserAccessLogAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAccessLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAccessLog[P]>
      : GetScalarType<T[P], AggregateUserAccessLog[P]>
  }




  export type UserAccessLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAccessLogWhereInput
    orderBy?: UserAccessLogOrderByWithAggregationInput | UserAccessLogOrderByWithAggregationInput[]
    by: UserAccessLogScalarFieldEnum[] | UserAccessLogScalarFieldEnum
    having?: UserAccessLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAccessLogCountAggregateInputType | true
    _avg?: UserAccessLogAvgAggregateInputType
    _sum?: UserAccessLogSumAggregateInputType
    _min?: UserAccessLogMinAggregateInputType
    _max?: UserAccessLogMaxAggregateInputType
  }

  export type UserAccessLogGroupByOutputType = {
    id: string
    userId: number
    action: string
    ipAddress: string | null
    userAgent: string | null
    success: boolean
    details: string | null
    createdAt: Date
    _count: UserAccessLogCountAggregateOutputType | null
    _avg: UserAccessLogAvgAggregateOutputType | null
    _sum: UserAccessLogSumAggregateOutputType | null
    _min: UserAccessLogMinAggregateOutputType | null
    _max: UserAccessLogMaxAggregateOutputType | null
  }

  type GetUserAccessLogGroupByPayload<T extends UserAccessLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAccessLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAccessLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAccessLogGroupByOutputType[P]>
            : GetScalarType<T[P], UserAccessLogGroupByOutputType[P]>
        }
      >
    >


  export type UserAccessLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    success?: boolean
    details?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAccessLog"]>

  export type UserAccessLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    success?: boolean
    details?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAccessLog"]>

  export type UserAccessLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    success?: boolean
    details?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAccessLog"]>

  export type UserAccessLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    success?: boolean
    details?: boolean
    createdAt?: boolean
  }

  export type UserAccessLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "ipAddress" | "userAgent" | "success" | "details" | "createdAt", ExtArgs["result"]["userAccessLog"]>
  export type UserAccessLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserAccessLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserAccessLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserAccessLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAccessLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: number
      action: string
      ipAddress: string | null
      userAgent: string | null
      success: boolean
      details: string | null
      createdAt: Date
    }, ExtArgs["result"]["userAccessLog"]>
    composites: {}
  }

  type UserAccessLogGetPayload<S extends boolean | null | undefined | UserAccessLogDefaultArgs> = $Result.GetResult<Prisma.$UserAccessLogPayload, S>

  type UserAccessLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserAccessLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserAccessLogCountAggregateInputType | true
    }

  export interface UserAccessLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAccessLog'], meta: { name: 'UserAccessLog' } }
    /**
     * Find zero or one UserAccessLog that matches the filter.
     * @param {UserAccessLogFindUniqueArgs} args - Arguments to find a UserAccessLog
     * @example
     * // Get one UserAccessLog
     * const userAccessLog = await prisma.userAccessLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAccessLogFindUniqueArgs>(args: SelectSubset<T, UserAccessLogFindUniqueArgs<ExtArgs>>): Prisma__UserAccessLogClient<$Result.GetResult<Prisma.$UserAccessLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserAccessLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserAccessLogFindUniqueOrThrowArgs} args - Arguments to find a UserAccessLog
     * @example
     * // Get one UserAccessLog
     * const userAccessLog = await prisma.userAccessLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAccessLogFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAccessLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAccessLogClient<$Result.GetResult<Prisma.$UserAccessLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAccessLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccessLogFindFirstArgs} args - Arguments to find a UserAccessLog
     * @example
     * // Get one UserAccessLog
     * const userAccessLog = await prisma.userAccessLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAccessLogFindFirstArgs>(args?: SelectSubset<T, UserAccessLogFindFirstArgs<ExtArgs>>): Prisma__UserAccessLogClient<$Result.GetResult<Prisma.$UserAccessLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAccessLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccessLogFindFirstOrThrowArgs} args - Arguments to find a UserAccessLog
     * @example
     * // Get one UserAccessLog
     * const userAccessLog = await prisma.userAccessLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAccessLogFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAccessLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAccessLogClient<$Result.GetResult<Prisma.$UserAccessLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserAccessLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccessLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAccessLogs
     * const userAccessLogs = await prisma.userAccessLog.findMany()
     * 
     * // Get first 10 UserAccessLogs
     * const userAccessLogs = await prisma.userAccessLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAccessLogWithIdOnly = await prisma.userAccessLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAccessLogFindManyArgs>(args?: SelectSubset<T, UserAccessLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAccessLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserAccessLog.
     * @param {UserAccessLogCreateArgs} args - Arguments to create a UserAccessLog.
     * @example
     * // Create one UserAccessLog
     * const UserAccessLog = await prisma.userAccessLog.create({
     *   data: {
     *     // ... data to create a UserAccessLog
     *   }
     * })
     * 
     */
    create<T extends UserAccessLogCreateArgs>(args: SelectSubset<T, UserAccessLogCreateArgs<ExtArgs>>): Prisma__UserAccessLogClient<$Result.GetResult<Prisma.$UserAccessLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserAccessLogs.
     * @param {UserAccessLogCreateManyArgs} args - Arguments to create many UserAccessLogs.
     * @example
     * // Create many UserAccessLogs
     * const userAccessLog = await prisma.userAccessLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAccessLogCreateManyArgs>(args?: SelectSubset<T, UserAccessLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAccessLogs and returns the data saved in the database.
     * @param {UserAccessLogCreateManyAndReturnArgs} args - Arguments to create many UserAccessLogs.
     * @example
     * // Create many UserAccessLogs
     * const userAccessLog = await prisma.userAccessLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAccessLogs and only return the `id`
     * const userAccessLogWithIdOnly = await prisma.userAccessLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAccessLogCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAccessLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAccessLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserAccessLog.
     * @param {UserAccessLogDeleteArgs} args - Arguments to delete one UserAccessLog.
     * @example
     * // Delete one UserAccessLog
     * const UserAccessLog = await prisma.userAccessLog.delete({
     *   where: {
     *     // ... filter to delete one UserAccessLog
     *   }
     * })
     * 
     */
    delete<T extends UserAccessLogDeleteArgs>(args: SelectSubset<T, UserAccessLogDeleteArgs<ExtArgs>>): Prisma__UserAccessLogClient<$Result.GetResult<Prisma.$UserAccessLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserAccessLog.
     * @param {UserAccessLogUpdateArgs} args - Arguments to update one UserAccessLog.
     * @example
     * // Update one UserAccessLog
     * const userAccessLog = await prisma.userAccessLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAccessLogUpdateArgs>(args: SelectSubset<T, UserAccessLogUpdateArgs<ExtArgs>>): Prisma__UserAccessLogClient<$Result.GetResult<Prisma.$UserAccessLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserAccessLogs.
     * @param {UserAccessLogDeleteManyArgs} args - Arguments to filter UserAccessLogs to delete.
     * @example
     * // Delete a few UserAccessLogs
     * const { count } = await prisma.userAccessLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAccessLogDeleteManyArgs>(args?: SelectSubset<T, UserAccessLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAccessLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccessLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAccessLogs
     * const userAccessLog = await prisma.userAccessLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAccessLogUpdateManyArgs>(args: SelectSubset<T, UserAccessLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAccessLogs and returns the data updated in the database.
     * @param {UserAccessLogUpdateManyAndReturnArgs} args - Arguments to update many UserAccessLogs.
     * @example
     * // Update many UserAccessLogs
     * const userAccessLog = await prisma.userAccessLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserAccessLogs and only return the `id`
     * const userAccessLogWithIdOnly = await prisma.userAccessLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserAccessLogUpdateManyAndReturnArgs>(args: SelectSubset<T, UserAccessLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAccessLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserAccessLog.
     * @param {UserAccessLogUpsertArgs} args - Arguments to update or create a UserAccessLog.
     * @example
     * // Update or create a UserAccessLog
     * const userAccessLog = await prisma.userAccessLog.upsert({
     *   create: {
     *     // ... data to create a UserAccessLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAccessLog we want to update
     *   }
     * })
     */
    upsert<T extends UserAccessLogUpsertArgs>(args: SelectSubset<T, UserAccessLogUpsertArgs<ExtArgs>>): Prisma__UserAccessLogClient<$Result.GetResult<Prisma.$UserAccessLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserAccessLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccessLogCountArgs} args - Arguments to filter UserAccessLogs to count.
     * @example
     * // Count the number of UserAccessLogs
     * const count = await prisma.userAccessLog.count({
     *   where: {
     *     // ... the filter for the UserAccessLogs we want to count
     *   }
     * })
    **/
    count<T extends UserAccessLogCountArgs>(
      args?: Subset<T, UserAccessLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAccessLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAccessLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccessLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAccessLogAggregateArgs>(args: Subset<T, UserAccessLogAggregateArgs>): Prisma.PrismaPromise<GetUserAccessLogAggregateType<T>>

    /**
     * Group by UserAccessLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccessLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAccessLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAccessLogGroupByArgs['orderBy'] }
        : { orderBy?: UserAccessLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAccessLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAccessLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAccessLog model
   */
  readonly fields: UserAccessLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAccessLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAccessLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAccessLog model
   */
  interface UserAccessLogFieldRefs {
    readonly id: FieldRef<"UserAccessLog", 'String'>
    readonly userId: FieldRef<"UserAccessLog", 'Int'>
    readonly action: FieldRef<"UserAccessLog", 'String'>
    readonly ipAddress: FieldRef<"UserAccessLog", 'String'>
    readonly userAgent: FieldRef<"UserAccessLog", 'String'>
    readonly success: FieldRef<"UserAccessLog", 'Boolean'>
    readonly details: FieldRef<"UserAccessLog", 'String'>
    readonly createdAt: FieldRef<"UserAccessLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserAccessLog findUnique
   */
  export type UserAccessLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccessLog
     */
    select?: UserAccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccessLog
     */
    omit?: UserAccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccessLogInclude<ExtArgs> | null
    /**
     * Filter, which UserAccessLog to fetch.
     */
    where: UserAccessLogWhereUniqueInput
  }

  /**
   * UserAccessLog findUniqueOrThrow
   */
  export type UserAccessLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccessLog
     */
    select?: UserAccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccessLog
     */
    omit?: UserAccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccessLogInclude<ExtArgs> | null
    /**
     * Filter, which UserAccessLog to fetch.
     */
    where: UserAccessLogWhereUniqueInput
  }

  /**
   * UserAccessLog findFirst
   */
  export type UserAccessLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccessLog
     */
    select?: UserAccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccessLog
     */
    omit?: UserAccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccessLogInclude<ExtArgs> | null
    /**
     * Filter, which UserAccessLog to fetch.
     */
    where?: UserAccessLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAccessLogs to fetch.
     */
    orderBy?: UserAccessLogOrderByWithRelationInput | UserAccessLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAccessLogs.
     */
    cursor?: UserAccessLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAccessLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAccessLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAccessLogs.
     */
    distinct?: UserAccessLogScalarFieldEnum | UserAccessLogScalarFieldEnum[]
  }

  /**
   * UserAccessLog findFirstOrThrow
   */
  export type UserAccessLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccessLog
     */
    select?: UserAccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccessLog
     */
    omit?: UserAccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccessLogInclude<ExtArgs> | null
    /**
     * Filter, which UserAccessLog to fetch.
     */
    where?: UserAccessLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAccessLogs to fetch.
     */
    orderBy?: UserAccessLogOrderByWithRelationInput | UserAccessLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAccessLogs.
     */
    cursor?: UserAccessLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAccessLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAccessLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAccessLogs.
     */
    distinct?: UserAccessLogScalarFieldEnum | UserAccessLogScalarFieldEnum[]
  }

  /**
   * UserAccessLog findMany
   */
  export type UserAccessLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccessLog
     */
    select?: UserAccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccessLog
     */
    omit?: UserAccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccessLogInclude<ExtArgs> | null
    /**
     * Filter, which UserAccessLogs to fetch.
     */
    where?: UserAccessLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAccessLogs to fetch.
     */
    orderBy?: UserAccessLogOrderByWithRelationInput | UserAccessLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAccessLogs.
     */
    cursor?: UserAccessLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAccessLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAccessLogs.
     */
    skip?: number
    distinct?: UserAccessLogScalarFieldEnum | UserAccessLogScalarFieldEnum[]
  }

  /**
   * UserAccessLog create
   */
  export type UserAccessLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccessLog
     */
    select?: UserAccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccessLog
     */
    omit?: UserAccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccessLogInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAccessLog.
     */
    data: XOR<UserAccessLogCreateInput, UserAccessLogUncheckedCreateInput>
  }

  /**
   * UserAccessLog createMany
   */
  export type UserAccessLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAccessLogs.
     */
    data: UserAccessLogCreateManyInput | UserAccessLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAccessLog createManyAndReturn
   */
  export type UserAccessLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccessLog
     */
    select?: UserAccessLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccessLog
     */
    omit?: UserAccessLogOmit<ExtArgs> | null
    /**
     * The data used to create many UserAccessLogs.
     */
    data: UserAccessLogCreateManyInput | UserAccessLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccessLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAccessLog update
   */
  export type UserAccessLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccessLog
     */
    select?: UserAccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccessLog
     */
    omit?: UserAccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccessLogInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAccessLog.
     */
    data: XOR<UserAccessLogUpdateInput, UserAccessLogUncheckedUpdateInput>
    /**
     * Choose, which UserAccessLog to update.
     */
    where: UserAccessLogWhereUniqueInput
  }

  /**
   * UserAccessLog updateMany
   */
  export type UserAccessLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAccessLogs.
     */
    data: XOR<UserAccessLogUpdateManyMutationInput, UserAccessLogUncheckedUpdateManyInput>
    /**
     * Filter which UserAccessLogs to update
     */
    where?: UserAccessLogWhereInput
    /**
     * Limit how many UserAccessLogs to update.
     */
    limit?: number
  }

  /**
   * UserAccessLog updateManyAndReturn
   */
  export type UserAccessLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccessLog
     */
    select?: UserAccessLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccessLog
     */
    omit?: UserAccessLogOmit<ExtArgs> | null
    /**
     * The data used to update UserAccessLogs.
     */
    data: XOR<UserAccessLogUpdateManyMutationInput, UserAccessLogUncheckedUpdateManyInput>
    /**
     * Filter which UserAccessLogs to update
     */
    where?: UserAccessLogWhereInput
    /**
     * Limit how many UserAccessLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccessLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAccessLog upsert
   */
  export type UserAccessLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccessLog
     */
    select?: UserAccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccessLog
     */
    omit?: UserAccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccessLogInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAccessLog to update in case it exists.
     */
    where: UserAccessLogWhereUniqueInput
    /**
     * In case the UserAccessLog found by the `where` argument doesn't exist, create a new UserAccessLog with this data.
     */
    create: XOR<UserAccessLogCreateInput, UserAccessLogUncheckedCreateInput>
    /**
     * In case the UserAccessLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAccessLogUpdateInput, UserAccessLogUncheckedUpdateInput>
  }

  /**
   * UserAccessLog delete
   */
  export type UserAccessLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccessLog
     */
    select?: UserAccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccessLog
     */
    omit?: UserAccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccessLogInclude<ExtArgs> | null
    /**
     * Filter which UserAccessLog to delete.
     */
    where: UserAccessLogWhereUniqueInput
  }

  /**
   * UserAccessLog deleteMany
   */
  export type UserAccessLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAccessLogs to delete
     */
    where?: UserAccessLogWhereInput
    /**
     * Limit how many UserAccessLogs to delete.
     */
    limit?: number
  }

  /**
   * UserAccessLog without action
   */
  export type UserAccessLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccessLog
     */
    select?: UserAccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccessLog
     */
    omit?: UserAccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccessLogInclude<ExtArgs> | null
  }


  /**
   * Model UserIPRestriction
   */

  export type AggregateUserIPRestriction = {
    _count: UserIPRestrictionCountAggregateOutputType | null
    _avg: UserIPRestrictionAvgAggregateOutputType | null
    _sum: UserIPRestrictionSumAggregateOutputType | null
    _min: UserIPRestrictionMinAggregateOutputType | null
    _max: UserIPRestrictionMaxAggregateOutputType | null
  }

  export type UserIPRestrictionAvgAggregateOutputType = {
    userId: number | null
  }

  export type UserIPRestrictionSumAggregateOutputType = {
    userId: number | null
  }

  export type UserIPRestrictionMinAggregateOutputType = {
    id: string | null
    userId: number | null
    ipAddress: string | null
    type: string | null
    reason: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserIPRestrictionMaxAggregateOutputType = {
    id: string | null
    userId: number | null
    ipAddress: string | null
    type: string | null
    reason: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserIPRestrictionCountAggregateOutputType = {
    id: number
    userId: number
    ipAddress: number
    type: number
    reason: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserIPRestrictionAvgAggregateInputType = {
    userId?: true
  }

  export type UserIPRestrictionSumAggregateInputType = {
    userId?: true
  }

  export type UserIPRestrictionMinAggregateInputType = {
    id?: true
    userId?: true
    ipAddress?: true
    type?: true
    reason?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserIPRestrictionMaxAggregateInputType = {
    id?: true
    userId?: true
    ipAddress?: true
    type?: true
    reason?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserIPRestrictionCountAggregateInputType = {
    id?: true
    userId?: true
    ipAddress?: true
    type?: true
    reason?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserIPRestrictionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserIPRestriction to aggregate.
     */
    where?: UserIPRestrictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserIPRestrictions to fetch.
     */
    orderBy?: UserIPRestrictionOrderByWithRelationInput | UserIPRestrictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserIPRestrictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserIPRestrictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserIPRestrictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserIPRestrictions
    **/
    _count?: true | UserIPRestrictionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserIPRestrictionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserIPRestrictionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserIPRestrictionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserIPRestrictionMaxAggregateInputType
  }

  export type GetUserIPRestrictionAggregateType<T extends UserIPRestrictionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserIPRestriction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserIPRestriction[P]>
      : GetScalarType<T[P], AggregateUserIPRestriction[P]>
  }




  export type UserIPRestrictionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserIPRestrictionWhereInput
    orderBy?: UserIPRestrictionOrderByWithAggregationInput | UserIPRestrictionOrderByWithAggregationInput[]
    by: UserIPRestrictionScalarFieldEnum[] | UserIPRestrictionScalarFieldEnum
    having?: UserIPRestrictionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserIPRestrictionCountAggregateInputType | true
    _avg?: UserIPRestrictionAvgAggregateInputType
    _sum?: UserIPRestrictionSumAggregateInputType
    _min?: UserIPRestrictionMinAggregateInputType
    _max?: UserIPRestrictionMaxAggregateInputType
  }

  export type UserIPRestrictionGroupByOutputType = {
    id: string
    userId: number
    ipAddress: string
    type: string
    reason: string | null
    expiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserIPRestrictionCountAggregateOutputType | null
    _avg: UserIPRestrictionAvgAggregateOutputType | null
    _sum: UserIPRestrictionSumAggregateOutputType | null
    _min: UserIPRestrictionMinAggregateOutputType | null
    _max: UserIPRestrictionMaxAggregateOutputType | null
  }

  type GetUserIPRestrictionGroupByPayload<T extends UserIPRestrictionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserIPRestrictionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserIPRestrictionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserIPRestrictionGroupByOutputType[P]>
            : GetScalarType<T[P], UserIPRestrictionGroupByOutputType[P]>
        }
      >
    >


  export type UserIPRestrictionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    ipAddress?: boolean
    type?: boolean
    reason?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userIPRestriction"]>

  export type UserIPRestrictionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    ipAddress?: boolean
    type?: boolean
    reason?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userIPRestriction"]>

  export type UserIPRestrictionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    ipAddress?: boolean
    type?: boolean
    reason?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userIPRestriction"]>

  export type UserIPRestrictionSelectScalar = {
    id?: boolean
    userId?: boolean
    ipAddress?: boolean
    type?: boolean
    reason?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserIPRestrictionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "ipAddress" | "type" | "reason" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["userIPRestriction"]>
  export type UserIPRestrictionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserIPRestrictionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserIPRestrictionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserIPRestrictionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserIPRestriction"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: number
      ipAddress: string
      type: string
      reason: string | null
      expiresAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userIPRestriction"]>
    composites: {}
  }

  type UserIPRestrictionGetPayload<S extends boolean | null | undefined | UserIPRestrictionDefaultArgs> = $Result.GetResult<Prisma.$UserIPRestrictionPayload, S>

  type UserIPRestrictionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserIPRestrictionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserIPRestrictionCountAggregateInputType | true
    }

  export interface UserIPRestrictionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserIPRestriction'], meta: { name: 'UserIPRestriction' } }
    /**
     * Find zero or one UserIPRestriction that matches the filter.
     * @param {UserIPRestrictionFindUniqueArgs} args - Arguments to find a UserIPRestriction
     * @example
     * // Get one UserIPRestriction
     * const userIPRestriction = await prisma.userIPRestriction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserIPRestrictionFindUniqueArgs>(args: SelectSubset<T, UserIPRestrictionFindUniqueArgs<ExtArgs>>): Prisma__UserIPRestrictionClient<$Result.GetResult<Prisma.$UserIPRestrictionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserIPRestriction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserIPRestrictionFindUniqueOrThrowArgs} args - Arguments to find a UserIPRestriction
     * @example
     * // Get one UserIPRestriction
     * const userIPRestriction = await prisma.userIPRestriction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserIPRestrictionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserIPRestrictionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserIPRestrictionClient<$Result.GetResult<Prisma.$UserIPRestrictionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserIPRestriction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIPRestrictionFindFirstArgs} args - Arguments to find a UserIPRestriction
     * @example
     * // Get one UserIPRestriction
     * const userIPRestriction = await prisma.userIPRestriction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserIPRestrictionFindFirstArgs>(args?: SelectSubset<T, UserIPRestrictionFindFirstArgs<ExtArgs>>): Prisma__UserIPRestrictionClient<$Result.GetResult<Prisma.$UserIPRestrictionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserIPRestriction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIPRestrictionFindFirstOrThrowArgs} args - Arguments to find a UserIPRestriction
     * @example
     * // Get one UserIPRestriction
     * const userIPRestriction = await prisma.userIPRestriction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserIPRestrictionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserIPRestrictionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserIPRestrictionClient<$Result.GetResult<Prisma.$UserIPRestrictionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserIPRestrictions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIPRestrictionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserIPRestrictions
     * const userIPRestrictions = await prisma.userIPRestriction.findMany()
     * 
     * // Get first 10 UserIPRestrictions
     * const userIPRestrictions = await prisma.userIPRestriction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userIPRestrictionWithIdOnly = await prisma.userIPRestriction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserIPRestrictionFindManyArgs>(args?: SelectSubset<T, UserIPRestrictionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserIPRestrictionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserIPRestriction.
     * @param {UserIPRestrictionCreateArgs} args - Arguments to create a UserIPRestriction.
     * @example
     * // Create one UserIPRestriction
     * const UserIPRestriction = await prisma.userIPRestriction.create({
     *   data: {
     *     // ... data to create a UserIPRestriction
     *   }
     * })
     * 
     */
    create<T extends UserIPRestrictionCreateArgs>(args: SelectSubset<T, UserIPRestrictionCreateArgs<ExtArgs>>): Prisma__UserIPRestrictionClient<$Result.GetResult<Prisma.$UserIPRestrictionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserIPRestrictions.
     * @param {UserIPRestrictionCreateManyArgs} args - Arguments to create many UserIPRestrictions.
     * @example
     * // Create many UserIPRestrictions
     * const userIPRestriction = await prisma.userIPRestriction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserIPRestrictionCreateManyArgs>(args?: SelectSubset<T, UserIPRestrictionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserIPRestrictions and returns the data saved in the database.
     * @param {UserIPRestrictionCreateManyAndReturnArgs} args - Arguments to create many UserIPRestrictions.
     * @example
     * // Create many UserIPRestrictions
     * const userIPRestriction = await prisma.userIPRestriction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserIPRestrictions and only return the `id`
     * const userIPRestrictionWithIdOnly = await prisma.userIPRestriction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserIPRestrictionCreateManyAndReturnArgs>(args?: SelectSubset<T, UserIPRestrictionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserIPRestrictionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserIPRestriction.
     * @param {UserIPRestrictionDeleteArgs} args - Arguments to delete one UserIPRestriction.
     * @example
     * // Delete one UserIPRestriction
     * const UserIPRestriction = await prisma.userIPRestriction.delete({
     *   where: {
     *     // ... filter to delete one UserIPRestriction
     *   }
     * })
     * 
     */
    delete<T extends UserIPRestrictionDeleteArgs>(args: SelectSubset<T, UserIPRestrictionDeleteArgs<ExtArgs>>): Prisma__UserIPRestrictionClient<$Result.GetResult<Prisma.$UserIPRestrictionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserIPRestriction.
     * @param {UserIPRestrictionUpdateArgs} args - Arguments to update one UserIPRestriction.
     * @example
     * // Update one UserIPRestriction
     * const userIPRestriction = await prisma.userIPRestriction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserIPRestrictionUpdateArgs>(args: SelectSubset<T, UserIPRestrictionUpdateArgs<ExtArgs>>): Prisma__UserIPRestrictionClient<$Result.GetResult<Prisma.$UserIPRestrictionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserIPRestrictions.
     * @param {UserIPRestrictionDeleteManyArgs} args - Arguments to filter UserIPRestrictions to delete.
     * @example
     * // Delete a few UserIPRestrictions
     * const { count } = await prisma.userIPRestriction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserIPRestrictionDeleteManyArgs>(args?: SelectSubset<T, UserIPRestrictionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserIPRestrictions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIPRestrictionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserIPRestrictions
     * const userIPRestriction = await prisma.userIPRestriction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserIPRestrictionUpdateManyArgs>(args: SelectSubset<T, UserIPRestrictionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserIPRestrictions and returns the data updated in the database.
     * @param {UserIPRestrictionUpdateManyAndReturnArgs} args - Arguments to update many UserIPRestrictions.
     * @example
     * // Update many UserIPRestrictions
     * const userIPRestriction = await prisma.userIPRestriction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserIPRestrictions and only return the `id`
     * const userIPRestrictionWithIdOnly = await prisma.userIPRestriction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserIPRestrictionUpdateManyAndReturnArgs>(args: SelectSubset<T, UserIPRestrictionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserIPRestrictionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserIPRestriction.
     * @param {UserIPRestrictionUpsertArgs} args - Arguments to update or create a UserIPRestriction.
     * @example
     * // Update or create a UserIPRestriction
     * const userIPRestriction = await prisma.userIPRestriction.upsert({
     *   create: {
     *     // ... data to create a UserIPRestriction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserIPRestriction we want to update
     *   }
     * })
     */
    upsert<T extends UserIPRestrictionUpsertArgs>(args: SelectSubset<T, UserIPRestrictionUpsertArgs<ExtArgs>>): Prisma__UserIPRestrictionClient<$Result.GetResult<Prisma.$UserIPRestrictionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserIPRestrictions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIPRestrictionCountArgs} args - Arguments to filter UserIPRestrictions to count.
     * @example
     * // Count the number of UserIPRestrictions
     * const count = await prisma.userIPRestriction.count({
     *   where: {
     *     // ... the filter for the UserIPRestrictions we want to count
     *   }
     * })
    **/
    count<T extends UserIPRestrictionCountArgs>(
      args?: Subset<T, UserIPRestrictionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserIPRestrictionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserIPRestriction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIPRestrictionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserIPRestrictionAggregateArgs>(args: Subset<T, UserIPRestrictionAggregateArgs>): Prisma.PrismaPromise<GetUserIPRestrictionAggregateType<T>>

    /**
     * Group by UserIPRestriction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIPRestrictionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserIPRestrictionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserIPRestrictionGroupByArgs['orderBy'] }
        : { orderBy?: UserIPRestrictionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserIPRestrictionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserIPRestrictionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserIPRestriction model
   */
  readonly fields: UserIPRestrictionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserIPRestriction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserIPRestrictionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserIPRestriction model
   */
  interface UserIPRestrictionFieldRefs {
    readonly id: FieldRef<"UserIPRestriction", 'String'>
    readonly userId: FieldRef<"UserIPRestriction", 'Int'>
    readonly ipAddress: FieldRef<"UserIPRestriction", 'String'>
    readonly type: FieldRef<"UserIPRestriction", 'String'>
    readonly reason: FieldRef<"UserIPRestriction", 'String'>
    readonly expiresAt: FieldRef<"UserIPRestriction", 'DateTime'>
    readonly createdAt: FieldRef<"UserIPRestriction", 'DateTime'>
    readonly updatedAt: FieldRef<"UserIPRestriction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserIPRestriction findUnique
   */
  export type UserIPRestrictionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIPRestriction
     */
    select?: UserIPRestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserIPRestriction
     */
    omit?: UserIPRestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIPRestrictionInclude<ExtArgs> | null
    /**
     * Filter, which UserIPRestriction to fetch.
     */
    where: UserIPRestrictionWhereUniqueInput
  }

  /**
   * UserIPRestriction findUniqueOrThrow
   */
  export type UserIPRestrictionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIPRestriction
     */
    select?: UserIPRestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserIPRestriction
     */
    omit?: UserIPRestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIPRestrictionInclude<ExtArgs> | null
    /**
     * Filter, which UserIPRestriction to fetch.
     */
    where: UserIPRestrictionWhereUniqueInput
  }

  /**
   * UserIPRestriction findFirst
   */
  export type UserIPRestrictionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIPRestriction
     */
    select?: UserIPRestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserIPRestriction
     */
    omit?: UserIPRestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIPRestrictionInclude<ExtArgs> | null
    /**
     * Filter, which UserIPRestriction to fetch.
     */
    where?: UserIPRestrictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserIPRestrictions to fetch.
     */
    orderBy?: UserIPRestrictionOrderByWithRelationInput | UserIPRestrictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserIPRestrictions.
     */
    cursor?: UserIPRestrictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserIPRestrictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserIPRestrictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserIPRestrictions.
     */
    distinct?: UserIPRestrictionScalarFieldEnum | UserIPRestrictionScalarFieldEnum[]
  }

  /**
   * UserIPRestriction findFirstOrThrow
   */
  export type UserIPRestrictionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIPRestriction
     */
    select?: UserIPRestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserIPRestriction
     */
    omit?: UserIPRestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIPRestrictionInclude<ExtArgs> | null
    /**
     * Filter, which UserIPRestriction to fetch.
     */
    where?: UserIPRestrictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserIPRestrictions to fetch.
     */
    orderBy?: UserIPRestrictionOrderByWithRelationInput | UserIPRestrictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserIPRestrictions.
     */
    cursor?: UserIPRestrictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserIPRestrictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserIPRestrictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserIPRestrictions.
     */
    distinct?: UserIPRestrictionScalarFieldEnum | UserIPRestrictionScalarFieldEnum[]
  }

  /**
   * UserIPRestriction findMany
   */
  export type UserIPRestrictionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIPRestriction
     */
    select?: UserIPRestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserIPRestriction
     */
    omit?: UserIPRestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIPRestrictionInclude<ExtArgs> | null
    /**
     * Filter, which UserIPRestrictions to fetch.
     */
    where?: UserIPRestrictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserIPRestrictions to fetch.
     */
    orderBy?: UserIPRestrictionOrderByWithRelationInput | UserIPRestrictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserIPRestrictions.
     */
    cursor?: UserIPRestrictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserIPRestrictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserIPRestrictions.
     */
    skip?: number
    distinct?: UserIPRestrictionScalarFieldEnum | UserIPRestrictionScalarFieldEnum[]
  }

  /**
   * UserIPRestriction create
   */
  export type UserIPRestrictionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIPRestriction
     */
    select?: UserIPRestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserIPRestriction
     */
    omit?: UserIPRestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIPRestrictionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserIPRestriction.
     */
    data: XOR<UserIPRestrictionCreateInput, UserIPRestrictionUncheckedCreateInput>
  }

  /**
   * UserIPRestriction createMany
   */
  export type UserIPRestrictionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserIPRestrictions.
     */
    data: UserIPRestrictionCreateManyInput | UserIPRestrictionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserIPRestriction createManyAndReturn
   */
  export type UserIPRestrictionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIPRestriction
     */
    select?: UserIPRestrictionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserIPRestriction
     */
    omit?: UserIPRestrictionOmit<ExtArgs> | null
    /**
     * The data used to create many UserIPRestrictions.
     */
    data: UserIPRestrictionCreateManyInput | UserIPRestrictionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIPRestrictionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserIPRestriction update
   */
  export type UserIPRestrictionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIPRestriction
     */
    select?: UserIPRestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserIPRestriction
     */
    omit?: UserIPRestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIPRestrictionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserIPRestriction.
     */
    data: XOR<UserIPRestrictionUpdateInput, UserIPRestrictionUncheckedUpdateInput>
    /**
     * Choose, which UserIPRestriction to update.
     */
    where: UserIPRestrictionWhereUniqueInput
  }

  /**
   * UserIPRestriction updateMany
   */
  export type UserIPRestrictionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserIPRestrictions.
     */
    data: XOR<UserIPRestrictionUpdateManyMutationInput, UserIPRestrictionUncheckedUpdateManyInput>
    /**
     * Filter which UserIPRestrictions to update
     */
    where?: UserIPRestrictionWhereInput
    /**
     * Limit how many UserIPRestrictions to update.
     */
    limit?: number
  }

  /**
   * UserIPRestriction updateManyAndReturn
   */
  export type UserIPRestrictionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIPRestriction
     */
    select?: UserIPRestrictionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserIPRestriction
     */
    omit?: UserIPRestrictionOmit<ExtArgs> | null
    /**
     * The data used to update UserIPRestrictions.
     */
    data: XOR<UserIPRestrictionUpdateManyMutationInput, UserIPRestrictionUncheckedUpdateManyInput>
    /**
     * Filter which UserIPRestrictions to update
     */
    where?: UserIPRestrictionWhereInput
    /**
     * Limit how many UserIPRestrictions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIPRestrictionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserIPRestriction upsert
   */
  export type UserIPRestrictionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIPRestriction
     */
    select?: UserIPRestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserIPRestriction
     */
    omit?: UserIPRestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIPRestrictionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserIPRestriction to update in case it exists.
     */
    where: UserIPRestrictionWhereUniqueInput
    /**
     * In case the UserIPRestriction found by the `where` argument doesn't exist, create a new UserIPRestriction with this data.
     */
    create: XOR<UserIPRestrictionCreateInput, UserIPRestrictionUncheckedCreateInput>
    /**
     * In case the UserIPRestriction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserIPRestrictionUpdateInput, UserIPRestrictionUncheckedUpdateInput>
  }

  /**
   * UserIPRestriction delete
   */
  export type UserIPRestrictionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIPRestriction
     */
    select?: UserIPRestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserIPRestriction
     */
    omit?: UserIPRestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIPRestrictionInclude<ExtArgs> | null
    /**
     * Filter which UserIPRestriction to delete.
     */
    where: UserIPRestrictionWhereUniqueInput
  }

  /**
   * UserIPRestriction deleteMany
   */
  export type UserIPRestrictionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserIPRestrictions to delete
     */
    where?: UserIPRestrictionWhereInput
    /**
     * Limit how many UserIPRestrictions to delete.
     */
    limit?: number
  }

  /**
   * UserIPRestriction without action
   */
  export type UserIPRestrictionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIPRestriction
     */
    select?: UserIPRestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserIPRestriction
     */
    omit?: UserIPRestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIPRestrictionInclude<ExtArgs> | null
  }


  /**
   * Model UserAddress
   */

  export type AggregateUserAddress = {
    _count: UserAddressCountAggregateOutputType | null
    _avg: UserAddressAvgAggregateOutputType | null
    _sum: UserAddressSumAggregateOutputType | null
    _min: UserAddressMinAggregateOutputType | null
    _max: UserAddressMaxAggregateOutputType | null
  }

  export type UserAddressAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserAddressSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserAddressMinAggregateOutputType = {
    id: number | null
    userId: number | null
    street: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserAddressMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    street: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserAddressCountAggregateOutputType = {
    id: number
    userId: number
    street: number
    city: number
    state: number
    postalCode: number
    country: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAddressAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserAddressSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserAddressMinAggregateInputType = {
    id?: true
    userId?: true
    street?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserAddressMaxAggregateInputType = {
    id?: true
    userId?: true
    street?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserAddressCountAggregateInputType = {
    id?: true
    userId?: true
    street?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAddress to aggregate.
     */
    where?: UserAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAddresses to fetch.
     */
    orderBy?: UserAddressOrderByWithRelationInput | UserAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAddresses
    **/
    _count?: true | UserAddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAddressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserAddressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAddressMaxAggregateInputType
  }

  export type GetUserAddressAggregateType<T extends UserAddressAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAddress[P]>
      : GetScalarType<T[P], AggregateUserAddress[P]>
  }




  export type UserAddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAddressWhereInput
    orderBy?: UserAddressOrderByWithAggregationInput | UserAddressOrderByWithAggregationInput[]
    by: UserAddressScalarFieldEnum[] | UserAddressScalarFieldEnum
    having?: UserAddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAddressCountAggregateInputType | true
    _avg?: UserAddressAvgAggregateInputType
    _sum?: UserAddressSumAggregateInputType
    _min?: UserAddressMinAggregateInputType
    _max?: UserAddressMaxAggregateInputType
  }

  export type UserAddressGroupByOutputType = {
    id: number
    userId: number
    street: string
    city: string
    state: string
    postalCode: string
    country: string
    createdAt: Date
    updatedAt: Date
    _count: UserAddressCountAggregateOutputType | null
    _avg: UserAddressAvgAggregateOutputType | null
    _sum: UserAddressSumAggregateOutputType | null
    _min: UserAddressMinAggregateOutputType | null
    _max: UserAddressMaxAggregateOutputType | null
  }

  type GetUserAddressGroupByPayload<T extends UserAddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAddressGroupByOutputType[P]>
            : GetScalarType<T[P], UserAddressGroupByOutputType[P]>
        }
      >
    >


  export type UserAddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    street?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAddress"]>

  export type UserAddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    street?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAddress"]>

  export type UserAddressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    street?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAddress"]>

  export type UserAddressSelectScalar = {
    id?: boolean
    userId?: boolean
    street?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserAddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "street" | "city" | "state" | "postalCode" | "country" | "createdAt" | "updatedAt", ExtArgs["result"]["userAddress"]>
  export type UserAddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserAddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserAddressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserAddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAddress"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      street: string
      city: string
      state: string
      postalCode: string
      country: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userAddress"]>
    composites: {}
  }

  type UserAddressGetPayload<S extends boolean | null | undefined | UserAddressDefaultArgs> = $Result.GetResult<Prisma.$UserAddressPayload, S>

  type UserAddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserAddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserAddressCountAggregateInputType | true
    }

  export interface UserAddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAddress'], meta: { name: 'UserAddress' } }
    /**
     * Find zero or one UserAddress that matches the filter.
     * @param {UserAddressFindUniqueArgs} args - Arguments to find a UserAddress
     * @example
     * // Get one UserAddress
     * const userAddress = await prisma.userAddress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAddressFindUniqueArgs>(args: SelectSubset<T, UserAddressFindUniqueArgs<ExtArgs>>): Prisma__UserAddressClient<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserAddress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserAddressFindUniqueOrThrowArgs} args - Arguments to find a UserAddress
     * @example
     * // Get one UserAddress
     * const userAddress = await prisma.userAddress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAddressFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAddressClient<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAddress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressFindFirstArgs} args - Arguments to find a UserAddress
     * @example
     * // Get one UserAddress
     * const userAddress = await prisma.userAddress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAddressFindFirstArgs>(args?: SelectSubset<T, UserAddressFindFirstArgs<ExtArgs>>): Prisma__UserAddressClient<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAddress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressFindFirstOrThrowArgs} args - Arguments to find a UserAddress
     * @example
     * // Get one UserAddress
     * const userAddress = await prisma.userAddress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAddressFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAddressClient<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserAddresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAddresses
     * const userAddresses = await prisma.userAddress.findMany()
     * 
     * // Get first 10 UserAddresses
     * const userAddresses = await prisma.userAddress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAddressWithIdOnly = await prisma.userAddress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAddressFindManyArgs>(args?: SelectSubset<T, UserAddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserAddress.
     * @param {UserAddressCreateArgs} args - Arguments to create a UserAddress.
     * @example
     * // Create one UserAddress
     * const UserAddress = await prisma.userAddress.create({
     *   data: {
     *     // ... data to create a UserAddress
     *   }
     * })
     * 
     */
    create<T extends UserAddressCreateArgs>(args: SelectSubset<T, UserAddressCreateArgs<ExtArgs>>): Prisma__UserAddressClient<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserAddresses.
     * @param {UserAddressCreateManyArgs} args - Arguments to create many UserAddresses.
     * @example
     * // Create many UserAddresses
     * const userAddress = await prisma.userAddress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAddressCreateManyArgs>(args?: SelectSubset<T, UserAddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAddresses and returns the data saved in the database.
     * @param {UserAddressCreateManyAndReturnArgs} args - Arguments to create many UserAddresses.
     * @example
     * // Create many UserAddresses
     * const userAddress = await prisma.userAddress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAddresses and only return the `id`
     * const userAddressWithIdOnly = await prisma.userAddress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAddressCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserAddress.
     * @param {UserAddressDeleteArgs} args - Arguments to delete one UserAddress.
     * @example
     * // Delete one UserAddress
     * const UserAddress = await prisma.userAddress.delete({
     *   where: {
     *     // ... filter to delete one UserAddress
     *   }
     * })
     * 
     */
    delete<T extends UserAddressDeleteArgs>(args: SelectSubset<T, UserAddressDeleteArgs<ExtArgs>>): Prisma__UserAddressClient<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserAddress.
     * @param {UserAddressUpdateArgs} args - Arguments to update one UserAddress.
     * @example
     * // Update one UserAddress
     * const userAddress = await prisma.userAddress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAddressUpdateArgs>(args: SelectSubset<T, UserAddressUpdateArgs<ExtArgs>>): Prisma__UserAddressClient<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserAddresses.
     * @param {UserAddressDeleteManyArgs} args - Arguments to filter UserAddresses to delete.
     * @example
     * // Delete a few UserAddresses
     * const { count } = await prisma.userAddress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAddressDeleteManyArgs>(args?: SelectSubset<T, UserAddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAddresses
     * const userAddress = await prisma.userAddress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAddressUpdateManyArgs>(args: SelectSubset<T, UserAddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAddresses and returns the data updated in the database.
     * @param {UserAddressUpdateManyAndReturnArgs} args - Arguments to update many UserAddresses.
     * @example
     * // Update many UserAddresses
     * const userAddress = await prisma.userAddress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserAddresses and only return the `id`
     * const userAddressWithIdOnly = await prisma.userAddress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserAddressUpdateManyAndReturnArgs>(args: SelectSubset<T, UserAddressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserAddress.
     * @param {UserAddressUpsertArgs} args - Arguments to update or create a UserAddress.
     * @example
     * // Update or create a UserAddress
     * const userAddress = await prisma.userAddress.upsert({
     *   create: {
     *     // ... data to create a UserAddress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAddress we want to update
     *   }
     * })
     */
    upsert<T extends UserAddressUpsertArgs>(args: SelectSubset<T, UserAddressUpsertArgs<ExtArgs>>): Prisma__UserAddressClient<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressCountArgs} args - Arguments to filter UserAddresses to count.
     * @example
     * // Count the number of UserAddresses
     * const count = await prisma.userAddress.count({
     *   where: {
     *     // ... the filter for the UserAddresses we want to count
     *   }
     * })
    **/
    count<T extends UserAddressCountArgs>(
      args?: Subset<T, UserAddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAddressAggregateArgs>(args: Subset<T, UserAddressAggregateArgs>): Prisma.PrismaPromise<GetUserAddressAggregateType<T>>

    /**
     * Group by UserAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAddressGroupByArgs['orderBy'] }
        : { orderBy?: UserAddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAddress model
   */
  readonly fields: UserAddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAddress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAddress model
   */
  interface UserAddressFieldRefs {
    readonly id: FieldRef<"UserAddress", 'Int'>
    readonly userId: FieldRef<"UserAddress", 'Int'>
    readonly street: FieldRef<"UserAddress", 'String'>
    readonly city: FieldRef<"UserAddress", 'String'>
    readonly state: FieldRef<"UserAddress", 'String'>
    readonly postalCode: FieldRef<"UserAddress", 'String'>
    readonly country: FieldRef<"UserAddress", 'String'>
    readonly createdAt: FieldRef<"UserAddress", 'DateTime'>
    readonly updatedAt: FieldRef<"UserAddress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserAddress findUnique
   */
  export type UserAddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAddress
     */
    omit?: UserAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * Filter, which UserAddress to fetch.
     */
    where: UserAddressWhereUniqueInput
  }

  /**
   * UserAddress findUniqueOrThrow
   */
  export type UserAddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAddress
     */
    omit?: UserAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * Filter, which UserAddress to fetch.
     */
    where: UserAddressWhereUniqueInput
  }

  /**
   * UserAddress findFirst
   */
  export type UserAddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAddress
     */
    omit?: UserAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * Filter, which UserAddress to fetch.
     */
    where?: UserAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAddresses to fetch.
     */
    orderBy?: UserAddressOrderByWithRelationInput | UserAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAddresses.
     */
    cursor?: UserAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAddresses.
     */
    distinct?: UserAddressScalarFieldEnum | UserAddressScalarFieldEnum[]
  }

  /**
   * UserAddress findFirstOrThrow
   */
  export type UserAddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAddress
     */
    omit?: UserAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * Filter, which UserAddress to fetch.
     */
    where?: UserAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAddresses to fetch.
     */
    orderBy?: UserAddressOrderByWithRelationInput | UserAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAddresses.
     */
    cursor?: UserAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAddresses.
     */
    distinct?: UserAddressScalarFieldEnum | UserAddressScalarFieldEnum[]
  }

  /**
   * UserAddress findMany
   */
  export type UserAddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAddress
     */
    omit?: UserAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * Filter, which UserAddresses to fetch.
     */
    where?: UserAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAddresses to fetch.
     */
    orderBy?: UserAddressOrderByWithRelationInput | UserAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAddresses.
     */
    cursor?: UserAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAddresses.
     */
    skip?: number
    distinct?: UserAddressScalarFieldEnum | UserAddressScalarFieldEnum[]
  }

  /**
   * UserAddress create
   */
  export type UserAddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAddress
     */
    omit?: UserAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAddress.
     */
    data: XOR<UserAddressCreateInput, UserAddressUncheckedCreateInput>
  }

  /**
   * UserAddress createMany
   */
  export type UserAddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAddresses.
     */
    data: UserAddressCreateManyInput | UserAddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAddress createManyAndReturn
   */
  export type UserAddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAddress
     */
    omit?: UserAddressOmit<ExtArgs> | null
    /**
     * The data used to create many UserAddresses.
     */
    data: UserAddressCreateManyInput | UserAddressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAddress update
   */
  export type UserAddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAddress
     */
    omit?: UserAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAddress.
     */
    data: XOR<UserAddressUpdateInput, UserAddressUncheckedUpdateInput>
    /**
     * Choose, which UserAddress to update.
     */
    where: UserAddressWhereUniqueInput
  }

  /**
   * UserAddress updateMany
   */
  export type UserAddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAddresses.
     */
    data: XOR<UserAddressUpdateManyMutationInput, UserAddressUncheckedUpdateManyInput>
    /**
     * Filter which UserAddresses to update
     */
    where?: UserAddressWhereInput
    /**
     * Limit how many UserAddresses to update.
     */
    limit?: number
  }

  /**
   * UserAddress updateManyAndReturn
   */
  export type UserAddressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAddress
     */
    omit?: UserAddressOmit<ExtArgs> | null
    /**
     * The data used to update UserAddresses.
     */
    data: XOR<UserAddressUpdateManyMutationInput, UserAddressUncheckedUpdateManyInput>
    /**
     * Filter which UserAddresses to update
     */
    where?: UserAddressWhereInput
    /**
     * Limit how many UserAddresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAddress upsert
   */
  export type UserAddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAddress
     */
    omit?: UserAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAddress to update in case it exists.
     */
    where: UserAddressWhereUniqueInput
    /**
     * In case the UserAddress found by the `where` argument doesn't exist, create a new UserAddress with this data.
     */
    create: XOR<UserAddressCreateInput, UserAddressUncheckedCreateInput>
    /**
     * In case the UserAddress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAddressUpdateInput, UserAddressUncheckedUpdateInput>
  }

  /**
   * UserAddress delete
   */
  export type UserAddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAddress
     */
    omit?: UserAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * Filter which UserAddress to delete.
     */
    where: UserAddressWhereUniqueInput
  }

  /**
   * UserAddress deleteMany
   */
  export type UserAddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAddresses to delete
     */
    where?: UserAddressWhereInput
    /**
     * Limit how many UserAddresses to delete.
     */
    limit?: number
  }

  /**
   * UserAddress without action
   */
  export type UserAddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAddress
     */
    omit?: UserAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
  }


  /**
   * Model UserEmergencyContact
   */

  export type AggregateUserEmergencyContact = {
    _count: UserEmergencyContactCountAggregateOutputType | null
    _avg: UserEmergencyContactAvgAggregateOutputType | null
    _sum: UserEmergencyContactSumAggregateOutputType | null
    _min: UserEmergencyContactMinAggregateOutputType | null
    _max: UserEmergencyContactMaxAggregateOutputType | null
  }

  export type UserEmergencyContactAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserEmergencyContactSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserEmergencyContactMinAggregateOutputType = {
    id: number | null
    userId: number | null
    name: string | null
    relationship: string | null
    phone: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserEmergencyContactMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    name: string | null
    relationship: string | null
    phone: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserEmergencyContactCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    relationship: number
    phone: number
    email: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserEmergencyContactAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserEmergencyContactSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserEmergencyContactMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    relationship?: true
    phone?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserEmergencyContactMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    relationship?: true
    phone?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserEmergencyContactCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    relationship?: true
    phone?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserEmergencyContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserEmergencyContact to aggregate.
     */
    where?: UserEmergencyContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserEmergencyContacts to fetch.
     */
    orderBy?: UserEmergencyContactOrderByWithRelationInput | UserEmergencyContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserEmergencyContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserEmergencyContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserEmergencyContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserEmergencyContacts
    **/
    _count?: true | UserEmergencyContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserEmergencyContactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserEmergencyContactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserEmergencyContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserEmergencyContactMaxAggregateInputType
  }

  export type GetUserEmergencyContactAggregateType<T extends UserEmergencyContactAggregateArgs> = {
        [P in keyof T & keyof AggregateUserEmergencyContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserEmergencyContact[P]>
      : GetScalarType<T[P], AggregateUserEmergencyContact[P]>
  }




  export type UserEmergencyContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserEmergencyContactWhereInput
    orderBy?: UserEmergencyContactOrderByWithAggregationInput | UserEmergencyContactOrderByWithAggregationInput[]
    by: UserEmergencyContactScalarFieldEnum[] | UserEmergencyContactScalarFieldEnum
    having?: UserEmergencyContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserEmergencyContactCountAggregateInputType | true
    _avg?: UserEmergencyContactAvgAggregateInputType
    _sum?: UserEmergencyContactSumAggregateInputType
    _min?: UserEmergencyContactMinAggregateInputType
    _max?: UserEmergencyContactMaxAggregateInputType
  }

  export type UserEmergencyContactGroupByOutputType = {
    id: number
    userId: number
    name: string
    relationship: string
    phone: string
    email: string
    createdAt: Date
    updatedAt: Date
    _count: UserEmergencyContactCountAggregateOutputType | null
    _avg: UserEmergencyContactAvgAggregateOutputType | null
    _sum: UserEmergencyContactSumAggregateOutputType | null
    _min: UserEmergencyContactMinAggregateOutputType | null
    _max: UserEmergencyContactMaxAggregateOutputType | null
  }

  type GetUserEmergencyContactGroupByPayload<T extends UserEmergencyContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserEmergencyContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserEmergencyContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserEmergencyContactGroupByOutputType[P]>
            : GetScalarType<T[P], UserEmergencyContactGroupByOutputType[P]>
        }
      >
    >


  export type UserEmergencyContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    relationship?: boolean
    phone?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userEmergencyContact"]>

  export type UserEmergencyContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    relationship?: boolean
    phone?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userEmergencyContact"]>

  export type UserEmergencyContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    relationship?: boolean
    phone?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userEmergencyContact"]>

  export type UserEmergencyContactSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    relationship?: boolean
    phone?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserEmergencyContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "relationship" | "phone" | "email" | "createdAt" | "updatedAt", ExtArgs["result"]["userEmergencyContact"]>
  export type UserEmergencyContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserEmergencyContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserEmergencyContactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserEmergencyContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserEmergencyContact"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      name: string
      relationship: string
      phone: string
      email: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userEmergencyContact"]>
    composites: {}
  }

  type UserEmergencyContactGetPayload<S extends boolean | null | undefined | UserEmergencyContactDefaultArgs> = $Result.GetResult<Prisma.$UserEmergencyContactPayload, S>

  type UserEmergencyContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserEmergencyContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserEmergencyContactCountAggregateInputType | true
    }

  export interface UserEmergencyContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserEmergencyContact'], meta: { name: 'UserEmergencyContact' } }
    /**
     * Find zero or one UserEmergencyContact that matches the filter.
     * @param {UserEmergencyContactFindUniqueArgs} args - Arguments to find a UserEmergencyContact
     * @example
     * // Get one UserEmergencyContact
     * const userEmergencyContact = await prisma.userEmergencyContact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserEmergencyContactFindUniqueArgs>(args: SelectSubset<T, UserEmergencyContactFindUniqueArgs<ExtArgs>>): Prisma__UserEmergencyContactClient<$Result.GetResult<Prisma.$UserEmergencyContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserEmergencyContact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserEmergencyContactFindUniqueOrThrowArgs} args - Arguments to find a UserEmergencyContact
     * @example
     * // Get one UserEmergencyContact
     * const userEmergencyContact = await prisma.userEmergencyContact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserEmergencyContactFindUniqueOrThrowArgs>(args: SelectSubset<T, UserEmergencyContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserEmergencyContactClient<$Result.GetResult<Prisma.$UserEmergencyContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserEmergencyContact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEmergencyContactFindFirstArgs} args - Arguments to find a UserEmergencyContact
     * @example
     * // Get one UserEmergencyContact
     * const userEmergencyContact = await prisma.userEmergencyContact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserEmergencyContactFindFirstArgs>(args?: SelectSubset<T, UserEmergencyContactFindFirstArgs<ExtArgs>>): Prisma__UserEmergencyContactClient<$Result.GetResult<Prisma.$UserEmergencyContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserEmergencyContact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEmergencyContactFindFirstOrThrowArgs} args - Arguments to find a UserEmergencyContact
     * @example
     * // Get one UserEmergencyContact
     * const userEmergencyContact = await prisma.userEmergencyContact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserEmergencyContactFindFirstOrThrowArgs>(args?: SelectSubset<T, UserEmergencyContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserEmergencyContactClient<$Result.GetResult<Prisma.$UserEmergencyContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserEmergencyContacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEmergencyContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserEmergencyContacts
     * const userEmergencyContacts = await prisma.userEmergencyContact.findMany()
     * 
     * // Get first 10 UserEmergencyContacts
     * const userEmergencyContacts = await prisma.userEmergencyContact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userEmergencyContactWithIdOnly = await prisma.userEmergencyContact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserEmergencyContactFindManyArgs>(args?: SelectSubset<T, UserEmergencyContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserEmergencyContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserEmergencyContact.
     * @param {UserEmergencyContactCreateArgs} args - Arguments to create a UserEmergencyContact.
     * @example
     * // Create one UserEmergencyContact
     * const UserEmergencyContact = await prisma.userEmergencyContact.create({
     *   data: {
     *     // ... data to create a UserEmergencyContact
     *   }
     * })
     * 
     */
    create<T extends UserEmergencyContactCreateArgs>(args: SelectSubset<T, UserEmergencyContactCreateArgs<ExtArgs>>): Prisma__UserEmergencyContactClient<$Result.GetResult<Prisma.$UserEmergencyContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserEmergencyContacts.
     * @param {UserEmergencyContactCreateManyArgs} args - Arguments to create many UserEmergencyContacts.
     * @example
     * // Create many UserEmergencyContacts
     * const userEmergencyContact = await prisma.userEmergencyContact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserEmergencyContactCreateManyArgs>(args?: SelectSubset<T, UserEmergencyContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserEmergencyContacts and returns the data saved in the database.
     * @param {UserEmergencyContactCreateManyAndReturnArgs} args - Arguments to create many UserEmergencyContacts.
     * @example
     * // Create many UserEmergencyContacts
     * const userEmergencyContact = await prisma.userEmergencyContact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserEmergencyContacts and only return the `id`
     * const userEmergencyContactWithIdOnly = await prisma.userEmergencyContact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserEmergencyContactCreateManyAndReturnArgs>(args?: SelectSubset<T, UserEmergencyContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserEmergencyContactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserEmergencyContact.
     * @param {UserEmergencyContactDeleteArgs} args - Arguments to delete one UserEmergencyContact.
     * @example
     * // Delete one UserEmergencyContact
     * const UserEmergencyContact = await prisma.userEmergencyContact.delete({
     *   where: {
     *     // ... filter to delete one UserEmergencyContact
     *   }
     * })
     * 
     */
    delete<T extends UserEmergencyContactDeleteArgs>(args: SelectSubset<T, UserEmergencyContactDeleteArgs<ExtArgs>>): Prisma__UserEmergencyContactClient<$Result.GetResult<Prisma.$UserEmergencyContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserEmergencyContact.
     * @param {UserEmergencyContactUpdateArgs} args - Arguments to update one UserEmergencyContact.
     * @example
     * // Update one UserEmergencyContact
     * const userEmergencyContact = await prisma.userEmergencyContact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserEmergencyContactUpdateArgs>(args: SelectSubset<T, UserEmergencyContactUpdateArgs<ExtArgs>>): Prisma__UserEmergencyContactClient<$Result.GetResult<Prisma.$UserEmergencyContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserEmergencyContacts.
     * @param {UserEmergencyContactDeleteManyArgs} args - Arguments to filter UserEmergencyContacts to delete.
     * @example
     * // Delete a few UserEmergencyContacts
     * const { count } = await prisma.userEmergencyContact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserEmergencyContactDeleteManyArgs>(args?: SelectSubset<T, UserEmergencyContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserEmergencyContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEmergencyContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserEmergencyContacts
     * const userEmergencyContact = await prisma.userEmergencyContact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserEmergencyContactUpdateManyArgs>(args: SelectSubset<T, UserEmergencyContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserEmergencyContacts and returns the data updated in the database.
     * @param {UserEmergencyContactUpdateManyAndReturnArgs} args - Arguments to update many UserEmergencyContacts.
     * @example
     * // Update many UserEmergencyContacts
     * const userEmergencyContact = await prisma.userEmergencyContact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserEmergencyContacts and only return the `id`
     * const userEmergencyContactWithIdOnly = await prisma.userEmergencyContact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserEmergencyContactUpdateManyAndReturnArgs>(args: SelectSubset<T, UserEmergencyContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserEmergencyContactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserEmergencyContact.
     * @param {UserEmergencyContactUpsertArgs} args - Arguments to update or create a UserEmergencyContact.
     * @example
     * // Update or create a UserEmergencyContact
     * const userEmergencyContact = await prisma.userEmergencyContact.upsert({
     *   create: {
     *     // ... data to create a UserEmergencyContact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserEmergencyContact we want to update
     *   }
     * })
     */
    upsert<T extends UserEmergencyContactUpsertArgs>(args: SelectSubset<T, UserEmergencyContactUpsertArgs<ExtArgs>>): Prisma__UserEmergencyContactClient<$Result.GetResult<Prisma.$UserEmergencyContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserEmergencyContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEmergencyContactCountArgs} args - Arguments to filter UserEmergencyContacts to count.
     * @example
     * // Count the number of UserEmergencyContacts
     * const count = await prisma.userEmergencyContact.count({
     *   where: {
     *     // ... the filter for the UserEmergencyContacts we want to count
     *   }
     * })
    **/
    count<T extends UserEmergencyContactCountArgs>(
      args?: Subset<T, UserEmergencyContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserEmergencyContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserEmergencyContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEmergencyContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserEmergencyContactAggregateArgs>(args: Subset<T, UserEmergencyContactAggregateArgs>): Prisma.PrismaPromise<GetUserEmergencyContactAggregateType<T>>

    /**
     * Group by UserEmergencyContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEmergencyContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserEmergencyContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserEmergencyContactGroupByArgs['orderBy'] }
        : { orderBy?: UserEmergencyContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserEmergencyContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserEmergencyContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserEmergencyContact model
   */
  readonly fields: UserEmergencyContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserEmergencyContact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserEmergencyContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserEmergencyContact model
   */
  interface UserEmergencyContactFieldRefs {
    readonly id: FieldRef<"UserEmergencyContact", 'Int'>
    readonly userId: FieldRef<"UserEmergencyContact", 'Int'>
    readonly name: FieldRef<"UserEmergencyContact", 'String'>
    readonly relationship: FieldRef<"UserEmergencyContact", 'String'>
    readonly phone: FieldRef<"UserEmergencyContact", 'String'>
    readonly email: FieldRef<"UserEmergencyContact", 'String'>
    readonly createdAt: FieldRef<"UserEmergencyContact", 'DateTime'>
    readonly updatedAt: FieldRef<"UserEmergencyContact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserEmergencyContact findUnique
   */
  export type UserEmergencyContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmergencyContact
     */
    select?: UserEmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEmergencyContact
     */
    omit?: UserEmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which UserEmergencyContact to fetch.
     */
    where: UserEmergencyContactWhereUniqueInput
  }

  /**
   * UserEmergencyContact findUniqueOrThrow
   */
  export type UserEmergencyContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmergencyContact
     */
    select?: UserEmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEmergencyContact
     */
    omit?: UserEmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which UserEmergencyContact to fetch.
     */
    where: UserEmergencyContactWhereUniqueInput
  }

  /**
   * UserEmergencyContact findFirst
   */
  export type UserEmergencyContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmergencyContact
     */
    select?: UserEmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEmergencyContact
     */
    omit?: UserEmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which UserEmergencyContact to fetch.
     */
    where?: UserEmergencyContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserEmergencyContacts to fetch.
     */
    orderBy?: UserEmergencyContactOrderByWithRelationInput | UserEmergencyContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserEmergencyContacts.
     */
    cursor?: UserEmergencyContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserEmergencyContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserEmergencyContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserEmergencyContacts.
     */
    distinct?: UserEmergencyContactScalarFieldEnum | UserEmergencyContactScalarFieldEnum[]
  }

  /**
   * UserEmergencyContact findFirstOrThrow
   */
  export type UserEmergencyContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmergencyContact
     */
    select?: UserEmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEmergencyContact
     */
    omit?: UserEmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which UserEmergencyContact to fetch.
     */
    where?: UserEmergencyContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserEmergencyContacts to fetch.
     */
    orderBy?: UserEmergencyContactOrderByWithRelationInput | UserEmergencyContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserEmergencyContacts.
     */
    cursor?: UserEmergencyContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserEmergencyContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserEmergencyContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserEmergencyContacts.
     */
    distinct?: UserEmergencyContactScalarFieldEnum | UserEmergencyContactScalarFieldEnum[]
  }

  /**
   * UserEmergencyContact findMany
   */
  export type UserEmergencyContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmergencyContact
     */
    select?: UserEmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEmergencyContact
     */
    omit?: UserEmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which UserEmergencyContacts to fetch.
     */
    where?: UserEmergencyContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserEmergencyContacts to fetch.
     */
    orderBy?: UserEmergencyContactOrderByWithRelationInput | UserEmergencyContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserEmergencyContacts.
     */
    cursor?: UserEmergencyContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserEmergencyContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserEmergencyContacts.
     */
    skip?: number
    distinct?: UserEmergencyContactScalarFieldEnum | UserEmergencyContactScalarFieldEnum[]
  }

  /**
   * UserEmergencyContact create
   */
  export type UserEmergencyContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmergencyContact
     */
    select?: UserEmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEmergencyContact
     */
    omit?: UserEmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmergencyContactInclude<ExtArgs> | null
    /**
     * The data needed to create a UserEmergencyContact.
     */
    data: XOR<UserEmergencyContactCreateInput, UserEmergencyContactUncheckedCreateInput>
  }

  /**
   * UserEmergencyContact createMany
   */
  export type UserEmergencyContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserEmergencyContacts.
     */
    data: UserEmergencyContactCreateManyInput | UserEmergencyContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserEmergencyContact createManyAndReturn
   */
  export type UserEmergencyContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmergencyContact
     */
    select?: UserEmergencyContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserEmergencyContact
     */
    omit?: UserEmergencyContactOmit<ExtArgs> | null
    /**
     * The data used to create many UserEmergencyContacts.
     */
    data: UserEmergencyContactCreateManyInput | UserEmergencyContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmergencyContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserEmergencyContact update
   */
  export type UserEmergencyContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmergencyContact
     */
    select?: UserEmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEmergencyContact
     */
    omit?: UserEmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmergencyContactInclude<ExtArgs> | null
    /**
     * The data needed to update a UserEmergencyContact.
     */
    data: XOR<UserEmergencyContactUpdateInput, UserEmergencyContactUncheckedUpdateInput>
    /**
     * Choose, which UserEmergencyContact to update.
     */
    where: UserEmergencyContactWhereUniqueInput
  }

  /**
   * UserEmergencyContact updateMany
   */
  export type UserEmergencyContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserEmergencyContacts.
     */
    data: XOR<UserEmergencyContactUpdateManyMutationInput, UserEmergencyContactUncheckedUpdateManyInput>
    /**
     * Filter which UserEmergencyContacts to update
     */
    where?: UserEmergencyContactWhereInput
    /**
     * Limit how many UserEmergencyContacts to update.
     */
    limit?: number
  }

  /**
   * UserEmergencyContact updateManyAndReturn
   */
  export type UserEmergencyContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmergencyContact
     */
    select?: UserEmergencyContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserEmergencyContact
     */
    omit?: UserEmergencyContactOmit<ExtArgs> | null
    /**
     * The data used to update UserEmergencyContacts.
     */
    data: XOR<UserEmergencyContactUpdateManyMutationInput, UserEmergencyContactUncheckedUpdateManyInput>
    /**
     * Filter which UserEmergencyContacts to update
     */
    where?: UserEmergencyContactWhereInput
    /**
     * Limit how many UserEmergencyContacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmergencyContactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserEmergencyContact upsert
   */
  export type UserEmergencyContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmergencyContact
     */
    select?: UserEmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEmergencyContact
     */
    omit?: UserEmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmergencyContactInclude<ExtArgs> | null
    /**
     * The filter to search for the UserEmergencyContact to update in case it exists.
     */
    where: UserEmergencyContactWhereUniqueInput
    /**
     * In case the UserEmergencyContact found by the `where` argument doesn't exist, create a new UserEmergencyContact with this data.
     */
    create: XOR<UserEmergencyContactCreateInput, UserEmergencyContactUncheckedCreateInput>
    /**
     * In case the UserEmergencyContact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserEmergencyContactUpdateInput, UserEmergencyContactUncheckedUpdateInput>
  }

  /**
   * UserEmergencyContact delete
   */
  export type UserEmergencyContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmergencyContact
     */
    select?: UserEmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEmergencyContact
     */
    omit?: UserEmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmergencyContactInclude<ExtArgs> | null
    /**
     * Filter which UserEmergencyContact to delete.
     */
    where: UserEmergencyContactWhereUniqueInput
  }

  /**
   * UserEmergencyContact deleteMany
   */
  export type UserEmergencyContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserEmergencyContacts to delete
     */
    where?: UserEmergencyContactWhereInput
    /**
     * Limit how many UserEmergencyContacts to delete.
     */
    limit?: number
  }

  /**
   * UserEmergencyContact without action
   */
  export type UserEmergencyContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmergencyContact
     */
    select?: UserEmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEmergencyContact
     */
    omit?: UserEmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmergencyContactInclude<ExtArgs> | null
  }


  /**
   * Model UserSocialMedia
   */

  export type AggregateUserSocialMedia = {
    _count: UserSocialMediaCountAggregateOutputType | null
    _avg: UserSocialMediaAvgAggregateOutputType | null
    _sum: UserSocialMediaSumAggregateOutputType | null
    _min: UserSocialMediaMinAggregateOutputType | null
    _max: UserSocialMediaMaxAggregateOutputType | null
  }

  export type UserSocialMediaAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserSocialMediaSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserSocialMediaMinAggregateOutputType = {
    id: number | null
    userId: number | null
    linkedin: string | null
    twitter: string | null
    facebook: string | null
    instagram: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSocialMediaMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    linkedin: string | null
    twitter: string | null
    facebook: string | null
    instagram: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSocialMediaCountAggregateOutputType = {
    id: number
    userId: number
    linkedin: number
    twitter: number
    facebook: number
    instagram: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserSocialMediaAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserSocialMediaSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserSocialMediaMinAggregateInputType = {
    id?: true
    userId?: true
    linkedin?: true
    twitter?: true
    facebook?: true
    instagram?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSocialMediaMaxAggregateInputType = {
    id?: true
    userId?: true
    linkedin?: true
    twitter?: true
    facebook?: true
    instagram?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSocialMediaCountAggregateInputType = {
    id?: true
    userId?: true
    linkedin?: true
    twitter?: true
    facebook?: true
    instagram?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserSocialMediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSocialMedia to aggregate.
     */
    where?: UserSocialMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSocialMedias to fetch.
     */
    orderBy?: UserSocialMediaOrderByWithRelationInput | UserSocialMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSocialMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSocialMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSocialMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSocialMedias
    **/
    _count?: true | UserSocialMediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserSocialMediaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSocialMediaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSocialMediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSocialMediaMaxAggregateInputType
  }

  export type GetUserSocialMediaAggregateType<T extends UserSocialMediaAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSocialMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSocialMedia[P]>
      : GetScalarType<T[P], AggregateUserSocialMedia[P]>
  }




  export type UserSocialMediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSocialMediaWhereInput
    orderBy?: UserSocialMediaOrderByWithAggregationInput | UserSocialMediaOrderByWithAggregationInput[]
    by: UserSocialMediaScalarFieldEnum[] | UserSocialMediaScalarFieldEnum
    having?: UserSocialMediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSocialMediaCountAggregateInputType | true
    _avg?: UserSocialMediaAvgAggregateInputType
    _sum?: UserSocialMediaSumAggregateInputType
    _min?: UserSocialMediaMinAggregateInputType
    _max?: UserSocialMediaMaxAggregateInputType
  }

  export type UserSocialMediaGroupByOutputType = {
    id: number
    userId: number
    linkedin: string | null
    twitter: string | null
    facebook: string | null
    instagram: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserSocialMediaCountAggregateOutputType | null
    _avg: UserSocialMediaAvgAggregateOutputType | null
    _sum: UserSocialMediaSumAggregateOutputType | null
    _min: UserSocialMediaMinAggregateOutputType | null
    _max: UserSocialMediaMaxAggregateOutputType | null
  }

  type GetUserSocialMediaGroupByPayload<T extends UserSocialMediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSocialMediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSocialMediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSocialMediaGroupByOutputType[P]>
            : GetScalarType<T[P], UserSocialMediaGroupByOutputType[P]>
        }
      >
    >


  export type UserSocialMediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    linkedin?: boolean
    twitter?: boolean
    facebook?: boolean
    instagram?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSocialMedia"]>

  export type UserSocialMediaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    linkedin?: boolean
    twitter?: boolean
    facebook?: boolean
    instagram?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSocialMedia"]>

  export type UserSocialMediaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    linkedin?: boolean
    twitter?: boolean
    facebook?: boolean
    instagram?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSocialMedia"]>

  export type UserSocialMediaSelectScalar = {
    id?: boolean
    userId?: boolean
    linkedin?: boolean
    twitter?: boolean
    facebook?: boolean
    instagram?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserSocialMediaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "linkedin" | "twitter" | "facebook" | "instagram" | "createdAt" | "updatedAt", ExtArgs["result"]["userSocialMedia"]>
  export type UserSocialMediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSocialMediaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSocialMediaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSocialMediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSocialMedia"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      linkedin: string | null
      twitter: string | null
      facebook: string | null
      instagram: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userSocialMedia"]>
    composites: {}
  }

  type UserSocialMediaGetPayload<S extends boolean | null | undefined | UserSocialMediaDefaultArgs> = $Result.GetResult<Prisma.$UserSocialMediaPayload, S>

  type UserSocialMediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSocialMediaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSocialMediaCountAggregateInputType | true
    }

  export interface UserSocialMediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSocialMedia'], meta: { name: 'UserSocialMedia' } }
    /**
     * Find zero or one UserSocialMedia that matches the filter.
     * @param {UserSocialMediaFindUniqueArgs} args - Arguments to find a UserSocialMedia
     * @example
     * // Get one UserSocialMedia
     * const userSocialMedia = await prisma.userSocialMedia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSocialMediaFindUniqueArgs>(args: SelectSubset<T, UserSocialMediaFindUniqueArgs<ExtArgs>>): Prisma__UserSocialMediaClient<$Result.GetResult<Prisma.$UserSocialMediaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSocialMedia that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSocialMediaFindUniqueOrThrowArgs} args - Arguments to find a UserSocialMedia
     * @example
     * // Get one UserSocialMedia
     * const userSocialMedia = await prisma.userSocialMedia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSocialMediaFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSocialMediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSocialMediaClient<$Result.GetResult<Prisma.$UserSocialMediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSocialMedia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSocialMediaFindFirstArgs} args - Arguments to find a UserSocialMedia
     * @example
     * // Get one UserSocialMedia
     * const userSocialMedia = await prisma.userSocialMedia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSocialMediaFindFirstArgs>(args?: SelectSubset<T, UserSocialMediaFindFirstArgs<ExtArgs>>): Prisma__UserSocialMediaClient<$Result.GetResult<Prisma.$UserSocialMediaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSocialMedia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSocialMediaFindFirstOrThrowArgs} args - Arguments to find a UserSocialMedia
     * @example
     * // Get one UserSocialMedia
     * const userSocialMedia = await prisma.userSocialMedia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSocialMediaFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSocialMediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSocialMediaClient<$Result.GetResult<Prisma.$UserSocialMediaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSocialMedias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSocialMediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSocialMedias
     * const userSocialMedias = await prisma.userSocialMedia.findMany()
     * 
     * // Get first 10 UserSocialMedias
     * const userSocialMedias = await prisma.userSocialMedia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSocialMediaWithIdOnly = await prisma.userSocialMedia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSocialMediaFindManyArgs>(args?: SelectSubset<T, UserSocialMediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSocialMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSocialMedia.
     * @param {UserSocialMediaCreateArgs} args - Arguments to create a UserSocialMedia.
     * @example
     * // Create one UserSocialMedia
     * const UserSocialMedia = await prisma.userSocialMedia.create({
     *   data: {
     *     // ... data to create a UserSocialMedia
     *   }
     * })
     * 
     */
    create<T extends UserSocialMediaCreateArgs>(args: SelectSubset<T, UserSocialMediaCreateArgs<ExtArgs>>): Prisma__UserSocialMediaClient<$Result.GetResult<Prisma.$UserSocialMediaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSocialMedias.
     * @param {UserSocialMediaCreateManyArgs} args - Arguments to create many UserSocialMedias.
     * @example
     * // Create many UserSocialMedias
     * const userSocialMedia = await prisma.userSocialMedia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSocialMediaCreateManyArgs>(args?: SelectSubset<T, UserSocialMediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSocialMedias and returns the data saved in the database.
     * @param {UserSocialMediaCreateManyAndReturnArgs} args - Arguments to create many UserSocialMedias.
     * @example
     * // Create many UserSocialMedias
     * const userSocialMedia = await prisma.userSocialMedia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSocialMedias and only return the `id`
     * const userSocialMediaWithIdOnly = await prisma.userSocialMedia.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSocialMediaCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSocialMediaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSocialMediaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSocialMedia.
     * @param {UserSocialMediaDeleteArgs} args - Arguments to delete one UserSocialMedia.
     * @example
     * // Delete one UserSocialMedia
     * const UserSocialMedia = await prisma.userSocialMedia.delete({
     *   where: {
     *     // ... filter to delete one UserSocialMedia
     *   }
     * })
     * 
     */
    delete<T extends UserSocialMediaDeleteArgs>(args: SelectSubset<T, UserSocialMediaDeleteArgs<ExtArgs>>): Prisma__UserSocialMediaClient<$Result.GetResult<Prisma.$UserSocialMediaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSocialMedia.
     * @param {UserSocialMediaUpdateArgs} args - Arguments to update one UserSocialMedia.
     * @example
     * // Update one UserSocialMedia
     * const userSocialMedia = await prisma.userSocialMedia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSocialMediaUpdateArgs>(args: SelectSubset<T, UserSocialMediaUpdateArgs<ExtArgs>>): Prisma__UserSocialMediaClient<$Result.GetResult<Prisma.$UserSocialMediaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSocialMedias.
     * @param {UserSocialMediaDeleteManyArgs} args - Arguments to filter UserSocialMedias to delete.
     * @example
     * // Delete a few UserSocialMedias
     * const { count } = await prisma.userSocialMedia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSocialMediaDeleteManyArgs>(args?: SelectSubset<T, UserSocialMediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSocialMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSocialMediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSocialMedias
     * const userSocialMedia = await prisma.userSocialMedia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSocialMediaUpdateManyArgs>(args: SelectSubset<T, UserSocialMediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSocialMedias and returns the data updated in the database.
     * @param {UserSocialMediaUpdateManyAndReturnArgs} args - Arguments to update many UserSocialMedias.
     * @example
     * // Update many UserSocialMedias
     * const userSocialMedia = await prisma.userSocialMedia.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSocialMedias and only return the `id`
     * const userSocialMediaWithIdOnly = await prisma.userSocialMedia.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSocialMediaUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSocialMediaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSocialMediaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSocialMedia.
     * @param {UserSocialMediaUpsertArgs} args - Arguments to update or create a UserSocialMedia.
     * @example
     * // Update or create a UserSocialMedia
     * const userSocialMedia = await prisma.userSocialMedia.upsert({
     *   create: {
     *     // ... data to create a UserSocialMedia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSocialMedia we want to update
     *   }
     * })
     */
    upsert<T extends UserSocialMediaUpsertArgs>(args: SelectSubset<T, UserSocialMediaUpsertArgs<ExtArgs>>): Prisma__UserSocialMediaClient<$Result.GetResult<Prisma.$UserSocialMediaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSocialMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSocialMediaCountArgs} args - Arguments to filter UserSocialMedias to count.
     * @example
     * // Count the number of UserSocialMedias
     * const count = await prisma.userSocialMedia.count({
     *   where: {
     *     // ... the filter for the UserSocialMedias we want to count
     *   }
     * })
    **/
    count<T extends UserSocialMediaCountArgs>(
      args?: Subset<T, UserSocialMediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSocialMediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSocialMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSocialMediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSocialMediaAggregateArgs>(args: Subset<T, UserSocialMediaAggregateArgs>): Prisma.PrismaPromise<GetUserSocialMediaAggregateType<T>>

    /**
     * Group by UserSocialMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSocialMediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSocialMediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSocialMediaGroupByArgs['orderBy'] }
        : { orderBy?: UserSocialMediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSocialMediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSocialMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSocialMedia model
   */
  readonly fields: UserSocialMediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSocialMedia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSocialMediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSocialMedia model
   */
  interface UserSocialMediaFieldRefs {
    readonly id: FieldRef<"UserSocialMedia", 'Int'>
    readonly userId: FieldRef<"UserSocialMedia", 'Int'>
    readonly linkedin: FieldRef<"UserSocialMedia", 'String'>
    readonly twitter: FieldRef<"UserSocialMedia", 'String'>
    readonly facebook: FieldRef<"UserSocialMedia", 'String'>
    readonly instagram: FieldRef<"UserSocialMedia", 'String'>
    readonly createdAt: FieldRef<"UserSocialMedia", 'DateTime'>
    readonly updatedAt: FieldRef<"UserSocialMedia", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSocialMedia findUnique
   */
  export type UserSocialMediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocialMedia
     */
    select?: UserSocialMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocialMedia
     */
    omit?: UserSocialMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialMediaInclude<ExtArgs> | null
    /**
     * Filter, which UserSocialMedia to fetch.
     */
    where: UserSocialMediaWhereUniqueInput
  }

  /**
   * UserSocialMedia findUniqueOrThrow
   */
  export type UserSocialMediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocialMedia
     */
    select?: UserSocialMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocialMedia
     */
    omit?: UserSocialMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialMediaInclude<ExtArgs> | null
    /**
     * Filter, which UserSocialMedia to fetch.
     */
    where: UserSocialMediaWhereUniqueInput
  }

  /**
   * UserSocialMedia findFirst
   */
  export type UserSocialMediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocialMedia
     */
    select?: UserSocialMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocialMedia
     */
    omit?: UserSocialMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialMediaInclude<ExtArgs> | null
    /**
     * Filter, which UserSocialMedia to fetch.
     */
    where?: UserSocialMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSocialMedias to fetch.
     */
    orderBy?: UserSocialMediaOrderByWithRelationInput | UserSocialMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSocialMedias.
     */
    cursor?: UserSocialMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSocialMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSocialMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSocialMedias.
     */
    distinct?: UserSocialMediaScalarFieldEnum | UserSocialMediaScalarFieldEnum[]
  }

  /**
   * UserSocialMedia findFirstOrThrow
   */
  export type UserSocialMediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocialMedia
     */
    select?: UserSocialMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocialMedia
     */
    omit?: UserSocialMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialMediaInclude<ExtArgs> | null
    /**
     * Filter, which UserSocialMedia to fetch.
     */
    where?: UserSocialMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSocialMedias to fetch.
     */
    orderBy?: UserSocialMediaOrderByWithRelationInput | UserSocialMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSocialMedias.
     */
    cursor?: UserSocialMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSocialMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSocialMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSocialMedias.
     */
    distinct?: UserSocialMediaScalarFieldEnum | UserSocialMediaScalarFieldEnum[]
  }

  /**
   * UserSocialMedia findMany
   */
  export type UserSocialMediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocialMedia
     */
    select?: UserSocialMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocialMedia
     */
    omit?: UserSocialMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialMediaInclude<ExtArgs> | null
    /**
     * Filter, which UserSocialMedias to fetch.
     */
    where?: UserSocialMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSocialMedias to fetch.
     */
    orderBy?: UserSocialMediaOrderByWithRelationInput | UserSocialMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSocialMedias.
     */
    cursor?: UserSocialMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSocialMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSocialMedias.
     */
    skip?: number
    distinct?: UserSocialMediaScalarFieldEnum | UserSocialMediaScalarFieldEnum[]
  }

  /**
   * UserSocialMedia create
   */
  export type UserSocialMediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocialMedia
     */
    select?: UserSocialMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocialMedia
     */
    omit?: UserSocialMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialMediaInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSocialMedia.
     */
    data: XOR<UserSocialMediaCreateInput, UserSocialMediaUncheckedCreateInput>
  }

  /**
   * UserSocialMedia createMany
   */
  export type UserSocialMediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSocialMedias.
     */
    data: UserSocialMediaCreateManyInput | UserSocialMediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSocialMedia createManyAndReturn
   */
  export type UserSocialMediaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocialMedia
     */
    select?: UserSocialMediaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocialMedia
     */
    omit?: UserSocialMediaOmit<ExtArgs> | null
    /**
     * The data used to create many UserSocialMedias.
     */
    data: UserSocialMediaCreateManyInput | UserSocialMediaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialMediaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSocialMedia update
   */
  export type UserSocialMediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocialMedia
     */
    select?: UserSocialMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocialMedia
     */
    omit?: UserSocialMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialMediaInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSocialMedia.
     */
    data: XOR<UserSocialMediaUpdateInput, UserSocialMediaUncheckedUpdateInput>
    /**
     * Choose, which UserSocialMedia to update.
     */
    where: UserSocialMediaWhereUniqueInput
  }

  /**
   * UserSocialMedia updateMany
   */
  export type UserSocialMediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSocialMedias.
     */
    data: XOR<UserSocialMediaUpdateManyMutationInput, UserSocialMediaUncheckedUpdateManyInput>
    /**
     * Filter which UserSocialMedias to update
     */
    where?: UserSocialMediaWhereInput
    /**
     * Limit how many UserSocialMedias to update.
     */
    limit?: number
  }

  /**
   * UserSocialMedia updateManyAndReturn
   */
  export type UserSocialMediaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocialMedia
     */
    select?: UserSocialMediaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocialMedia
     */
    omit?: UserSocialMediaOmit<ExtArgs> | null
    /**
     * The data used to update UserSocialMedias.
     */
    data: XOR<UserSocialMediaUpdateManyMutationInput, UserSocialMediaUncheckedUpdateManyInput>
    /**
     * Filter which UserSocialMedias to update
     */
    where?: UserSocialMediaWhereInput
    /**
     * Limit how many UserSocialMedias to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialMediaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSocialMedia upsert
   */
  export type UserSocialMediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocialMedia
     */
    select?: UserSocialMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocialMedia
     */
    omit?: UserSocialMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialMediaInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSocialMedia to update in case it exists.
     */
    where: UserSocialMediaWhereUniqueInput
    /**
     * In case the UserSocialMedia found by the `where` argument doesn't exist, create a new UserSocialMedia with this data.
     */
    create: XOR<UserSocialMediaCreateInput, UserSocialMediaUncheckedCreateInput>
    /**
     * In case the UserSocialMedia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSocialMediaUpdateInput, UserSocialMediaUncheckedUpdateInput>
  }

  /**
   * UserSocialMedia delete
   */
  export type UserSocialMediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocialMedia
     */
    select?: UserSocialMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocialMedia
     */
    omit?: UserSocialMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialMediaInclude<ExtArgs> | null
    /**
     * Filter which UserSocialMedia to delete.
     */
    where: UserSocialMediaWhereUniqueInput
  }

  /**
   * UserSocialMedia deleteMany
   */
  export type UserSocialMediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSocialMedias to delete
     */
    where?: UserSocialMediaWhereInput
    /**
     * Limit how many UserSocialMedias to delete.
     */
    limit?: number
  }

  /**
   * UserSocialMedia without action
   */
  export type UserSocialMediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocialMedia
     */
    select?: UserSocialMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocialMedia
     */
    omit?: UserSocialMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialMediaInclude<ExtArgs> | null
  }


  /**
   * Model UserPreferences
   */

  export type AggregateUserPreferences = {
    _count: UserPreferencesCountAggregateOutputType | null
    _avg: UserPreferencesAvgAggregateOutputType | null
    _sum: UserPreferencesSumAggregateOutputType | null
    _min: UserPreferencesMinAggregateOutputType | null
    _max: UserPreferencesMaxAggregateOutputType | null
  }

  export type UserPreferencesAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserPreferencesSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserPreferencesMinAggregateOutputType = {
    id: number | null
    userId: number | null
    theme: string | null
    language: string | null
    timezone: string | null
    dateFormat: string | null
    timeFormat: string | null
    currency: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPreferencesMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    theme: string | null
    language: string | null
    timezone: string | null
    dateFormat: string | null
    timeFormat: string | null
    currency: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPreferencesCountAggregateOutputType = {
    id: number
    userId: number
    theme: number
    language: number
    timezone: number
    dateFormat: number
    timeFormat: number
    currency: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserPreferencesAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserPreferencesSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserPreferencesMinAggregateInputType = {
    id?: true
    userId?: true
    theme?: true
    language?: true
    timezone?: true
    dateFormat?: true
    timeFormat?: true
    currency?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPreferencesMaxAggregateInputType = {
    id?: true
    userId?: true
    theme?: true
    language?: true
    timezone?: true
    dateFormat?: true
    timeFormat?: true
    currency?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPreferencesCountAggregateInputType = {
    id?: true
    userId?: true
    theme?: true
    language?: true
    timezone?: true
    dateFormat?: true
    timeFormat?: true
    currency?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserPreferencesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPreferences to aggregate.
     */
    where?: UserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPreferences
    **/
    _count?: true | UserPreferencesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserPreferencesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserPreferencesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPreferencesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPreferencesMaxAggregateInputType
  }

  export type GetUserPreferencesAggregateType<T extends UserPreferencesAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPreferences]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPreferences[P]>
      : GetScalarType<T[P], AggregateUserPreferences[P]>
  }




  export type UserPreferencesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPreferencesWhereInput
    orderBy?: UserPreferencesOrderByWithAggregationInput | UserPreferencesOrderByWithAggregationInput[]
    by: UserPreferencesScalarFieldEnum[] | UserPreferencesScalarFieldEnum
    having?: UserPreferencesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPreferencesCountAggregateInputType | true
    _avg?: UserPreferencesAvgAggregateInputType
    _sum?: UserPreferencesSumAggregateInputType
    _min?: UserPreferencesMinAggregateInputType
    _max?: UserPreferencesMaxAggregateInputType
  }

  export type UserPreferencesGroupByOutputType = {
    id: number
    userId: number
    theme: string
    language: string
    timezone: string
    dateFormat: string
    timeFormat: string
    currency: string
    createdAt: Date
    updatedAt: Date
    _count: UserPreferencesCountAggregateOutputType | null
    _avg: UserPreferencesAvgAggregateOutputType | null
    _sum: UserPreferencesSumAggregateOutputType | null
    _min: UserPreferencesMinAggregateOutputType | null
    _max: UserPreferencesMaxAggregateOutputType | null
  }

  type GetUserPreferencesGroupByPayload<T extends UserPreferencesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPreferencesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPreferencesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPreferencesGroupByOutputType[P]>
            : GetScalarType<T[P], UserPreferencesGroupByOutputType[P]>
        }
      >
    >


  export type UserPreferencesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    theme?: boolean
    language?: boolean
    timezone?: boolean
    dateFormat?: boolean
    timeFormat?: boolean
    currency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPreferences"]>

  export type UserPreferencesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    theme?: boolean
    language?: boolean
    timezone?: boolean
    dateFormat?: boolean
    timeFormat?: boolean
    currency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPreferences"]>

  export type UserPreferencesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    theme?: boolean
    language?: boolean
    timezone?: boolean
    dateFormat?: boolean
    timeFormat?: boolean
    currency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPreferences"]>

  export type UserPreferencesSelectScalar = {
    id?: boolean
    userId?: boolean
    theme?: boolean
    language?: boolean
    timezone?: boolean
    dateFormat?: boolean
    timeFormat?: boolean
    currency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserPreferencesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "theme" | "language" | "timezone" | "dateFormat" | "timeFormat" | "currency" | "createdAt" | "updatedAt", ExtArgs["result"]["userPreferences"]>
  export type UserPreferencesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPreferencesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPreferencesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserPreferencesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPreferences"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      theme: string
      language: string
      timezone: string
      dateFormat: string
      timeFormat: string
      currency: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userPreferences"]>
    composites: {}
  }

  type UserPreferencesGetPayload<S extends boolean | null | undefined | UserPreferencesDefaultArgs> = $Result.GetResult<Prisma.$UserPreferencesPayload, S>

  type UserPreferencesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPreferencesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPreferencesCountAggregateInputType | true
    }

  export interface UserPreferencesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPreferences'], meta: { name: 'UserPreferences' } }
    /**
     * Find zero or one UserPreferences that matches the filter.
     * @param {UserPreferencesFindUniqueArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPreferencesFindUniqueArgs>(args: SelectSubset<T, UserPreferencesFindUniqueArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserPreferences that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPreferencesFindUniqueOrThrowArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPreferencesFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPreferencesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesFindFirstArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPreferencesFindFirstArgs>(args?: SelectSubset<T, UserPreferencesFindFirstArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPreferences that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesFindFirstOrThrowArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPreferencesFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPreferencesFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPreferences
     * const userPreferences = await prisma.userPreferences.findMany()
     * 
     * // Get first 10 UserPreferences
     * const userPreferences = await prisma.userPreferences.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPreferencesWithIdOnly = await prisma.userPreferences.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPreferencesFindManyArgs>(args?: SelectSubset<T, UserPreferencesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserPreferences.
     * @param {UserPreferencesCreateArgs} args - Arguments to create a UserPreferences.
     * @example
     * // Create one UserPreferences
     * const UserPreferences = await prisma.userPreferences.create({
     *   data: {
     *     // ... data to create a UserPreferences
     *   }
     * })
     * 
     */
    create<T extends UserPreferencesCreateArgs>(args: SelectSubset<T, UserPreferencesCreateArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserPreferences.
     * @param {UserPreferencesCreateManyArgs} args - Arguments to create many UserPreferences.
     * @example
     * // Create many UserPreferences
     * const userPreferences = await prisma.userPreferences.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPreferencesCreateManyArgs>(args?: SelectSubset<T, UserPreferencesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserPreferences and returns the data saved in the database.
     * @param {UserPreferencesCreateManyAndReturnArgs} args - Arguments to create many UserPreferences.
     * @example
     * // Create many UserPreferences
     * const userPreferences = await prisma.userPreferences.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserPreferences and only return the `id`
     * const userPreferencesWithIdOnly = await prisma.userPreferences.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserPreferencesCreateManyAndReturnArgs>(args?: SelectSubset<T, UserPreferencesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserPreferences.
     * @param {UserPreferencesDeleteArgs} args - Arguments to delete one UserPreferences.
     * @example
     * // Delete one UserPreferences
     * const UserPreferences = await prisma.userPreferences.delete({
     *   where: {
     *     // ... filter to delete one UserPreferences
     *   }
     * })
     * 
     */
    delete<T extends UserPreferencesDeleteArgs>(args: SelectSubset<T, UserPreferencesDeleteArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserPreferences.
     * @param {UserPreferencesUpdateArgs} args - Arguments to update one UserPreferences.
     * @example
     * // Update one UserPreferences
     * const userPreferences = await prisma.userPreferences.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPreferencesUpdateArgs>(args: SelectSubset<T, UserPreferencesUpdateArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserPreferences.
     * @param {UserPreferencesDeleteManyArgs} args - Arguments to filter UserPreferences to delete.
     * @example
     * // Delete a few UserPreferences
     * const { count } = await prisma.userPreferences.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPreferencesDeleteManyArgs>(args?: SelectSubset<T, UserPreferencesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPreferences
     * const userPreferences = await prisma.userPreferences.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPreferencesUpdateManyArgs>(args: SelectSubset<T, UserPreferencesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPreferences and returns the data updated in the database.
     * @param {UserPreferencesUpdateManyAndReturnArgs} args - Arguments to update many UserPreferences.
     * @example
     * // Update many UserPreferences
     * const userPreferences = await prisma.userPreferences.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserPreferences and only return the `id`
     * const userPreferencesWithIdOnly = await prisma.userPreferences.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserPreferencesUpdateManyAndReturnArgs>(args: SelectSubset<T, UserPreferencesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserPreferences.
     * @param {UserPreferencesUpsertArgs} args - Arguments to update or create a UserPreferences.
     * @example
     * // Update or create a UserPreferences
     * const userPreferences = await prisma.userPreferences.upsert({
     *   create: {
     *     // ... data to create a UserPreferences
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPreferences we want to update
     *   }
     * })
     */
    upsert<T extends UserPreferencesUpsertArgs>(args: SelectSubset<T, UserPreferencesUpsertArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesCountArgs} args - Arguments to filter UserPreferences to count.
     * @example
     * // Count the number of UserPreferences
     * const count = await prisma.userPreferences.count({
     *   where: {
     *     // ... the filter for the UserPreferences we want to count
     *   }
     * })
    **/
    count<T extends UserPreferencesCountArgs>(
      args?: Subset<T, UserPreferencesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPreferencesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPreferencesAggregateArgs>(args: Subset<T, UserPreferencesAggregateArgs>): Prisma.PrismaPromise<GetUserPreferencesAggregateType<T>>

    /**
     * Group by UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPreferencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPreferencesGroupByArgs['orderBy'] }
        : { orderBy?: UserPreferencesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPreferencesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPreferencesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPreferences model
   */
  readonly fields: UserPreferencesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPreferences.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPreferencesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPreferences model
   */
  interface UserPreferencesFieldRefs {
    readonly id: FieldRef<"UserPreferences", 'Int'>
    readonly userId: FieldRef<"UserPreferences", 'Int'>
    readonly theme: FieldRef<"UserPreferences", 'String'>
    readonly language: FieldRef<"UserPreferences", 'String'>
    readonly timezone: FieldRef<"UserPreferences", 'String'>
    readonly dateFormat: FieldRef<"UserPreferences", 'String'>
    readonly timeFormat: FieldRef<"UserPreferences", 'String'>
    readonly currency: FieldRef<"UserPreferences", 'String'>
    readonly createdAt: FieldRef<"UserPreferences", 'DateTime'>
    readonly updatedAt: FieldRef<"UserPreferences", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserPreferences findUnique
   */
  export type UserPreferencesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where: UserPreferencesWhereUniqueInput
  }

  /**
   * UserPreferences findUniqueOrThrow
   */
  export type UserPreferencesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where: UserPreferencesWhereUniqueInput
  }

  /**
   * UserPreferences findFirst
   */
  export type UserPreferencesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where?: UserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPreferences.
     */
    cursor?: UserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPreferences.
     */
    distinct?: UserPreferencesScalarFieldEnum | UserPreferencesScalarFieldEnum[]
  }

  /**
   * UserPreferences findFirstOrThrow
   */
  export type UserPreferencesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where?: UserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPreferences.
     */
    cursor?: UserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPreferences.
     */
    distinct?: UserPreferencesScalarFieldEnum | UserPreferencesScalarFieldEnum[]
  }

  /**
   * UserPreferences findMany
   */
  export type UserPreferencesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where?: UserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPreferences.
     */
    cursor?: UserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    distinct?: UserPreferencesScalarFieldEnum | UserPreferencesScalarFieldEnum[]
  }

  /**
   * UserPreferences create
   */
  export type UserPreferencesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPreferences.
     */
    data: XOR<UserPreferencesCreateInput, UserPreferencesUncheckedCreateInput>
  }

  /**
   * UserPreferences createMany
   */
  export type UserPreferencesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPreferences.
     */
    data: UserPreferencesCreateManyInput | UserPreferencesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPreferences createManyAndReturn
   */
  export type UserPreferencesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * The data used to create many UserPreferences.
     */
    data: UserPreferencesCreateManyInput | UserPreferencesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPreferences update
   */
  export type UserPreferencesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPreferences.
     */
    data: XOR<UserPreferencesUpdateInput, UserPreferencesUncheckedUpdateInput>
    /**
     * Choose, which UserPreferences to update.
     */
    where: UserPreferencesWhereUniqueInput
  }

  /**
   * UserPreferences updateMany
   */
  export type UserPreferencesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPreferences.
     */
    data: XOR<UserPreferencesUpdateManyMutationInput, UserPreferencesUncheckedUpdateManyInput>
    /**
     * Filter which UserPreferences to update
     */
    where?: UserPreferencesWhereInput
    /**
     * Limit how many UserPreferences to update.
     */
    limit?: number
  }

  /**
   * UserPreferences updateManyAndReturn
   */
  export type UserPreferencesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * The data used to update UserPreferences.
     */
    data: XOR<UserPreferencesUpdateManyMutationInput, UserPreferencesUncheckedUpdateManyInput>
    /**
     * Filter which UserPreferences to update
     */
    where?: UserPreferencesWhereInput
    /**
     * Limit how many UserPreferences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPreferences upsert
   */
  export type UserPreferencesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPreferences to update in case it exists.
     */
    where: UserPreferencesWhereUniqueInput
    /**
     * In case the UserPreferences found by the `where` argument doesn't exist, create a new UserPreferences with this data.
     */
    create: XOR<UserPreferencesCreateInput, UserPreferencesUncheckedCreateInput>
    /**
     * In case the UserPreferences was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPreferencesUpdateInput, UserPreferencesUncheckedUpdateInput>
  }

  /**
   * UserPreferences delete
   */
  export type UserPreferencesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter which UserPreferences to delete.
     */
    where: UserPreferencesWhereUniqueInput
  }

  /**
   * UserPreferences deleteMany
   */
  export type UserPreferencesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPreferences to delete
     */
    where?: UserPreferencesWhereInput
    /**
     * Limit how many UserPreferences to delete.
     */
    limit?: number
  }

  /**
   * UserPreferences without action
   */
  export type UserPreferencesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
  }


  /**
   * Model UserNotificationSettings
   */

  export type AggregateUserNotificationSettings = {
    _count: UserNotificationSettingsCountAggregateOutputType | null
    _avg: UserNotificationSettingsAvgAggregateOutputType | null
    _sum: UserNotificationSettingsSumAggregateOutputType | null
    _min: UserNotificationSettingsMinAggregateOutputType | null
    _max: UserNotificationSettingsMaxAggregateOutputType | null
  }

  export type UserNotificationSettingsAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserNotificationSettingsSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserNotificationSettingsMinAggregateOutputType = {
    id: number | null
    userId: number | null
    email_loginAlerts: boolean | null
    email_securityUpdates: boolean | null
    email_systemAnnouncements: boolean | null
    email_marketingEmails: boolean | null
    push_loginAlerts: boolean | null
    push_securityUpdates: boolean | null
    push_systemAnnouncements: boolean | null
    push_marketingNotifications: boolean | null
    sms_loginAlerts: boolean | null
    sms_securityUpdates: boolean | null
    sms_emergencyAlerts: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserNotificationSettingsMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    email_loginAlerts: boolean | null
    email_securityUpdates: boolean | null
    email_systemAnnouncements: boolean | null
    email_marketingEmails: boolean | null
    push_loginAlerts: boolean | null
    push_securityUpdates: boolean | null
    push_systemAnnouncements: boolean | null
    push_marketingNotifications: boolean | null
    sms_loginAlerts: boolean | null
    sms_securityUpdates: boolean | null
    sms_emergencyAlerts: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserNotificationSettingsCountAggregateOutputType = {
    id: number
    userId: number
    email_loginAlerts: number
    email_securityUpdates: number
    email_systemAnnouncements: number
    email_marketingEmails: number
    push_loginAlerts: number
    push_securityUpdates: number
    push_systemAnnouncements: number
    push_marketingNotifications: number
    sms_loginAlerts: number
    sms_securityUpdates: number
    sms_emergencyAlerts: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserNotificationSettingsAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserNotificationSettingsSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserNotificationSettingsMinAggregateInputType = {
    id?: true
    userId?: true
    email_loginAlerts?: true
    email_securityUpdates?: true
    email_systemAnnouncements?: true
    email_marketingEmails?: true
    push_loginAlerts?: true
    push_securityUpdates?: true
    push_systemAnnouncements?: true
    push_marketingNotifications?: true
    sms_loginAlerts?: true
    sms_securityUpdates?: true
    sms_emergencyAlerts?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserNotificationSettingsMaxAggregateInputType = {
    id?: true
    userId?: true
    email_loginAlerts?: true
    email_securityUpdates?: true
    email_systemAnnouncements?: true
    email_marketingEmails?: true
    push_loginAlerts?: true
    push_securityUpdates?: true
    push_systemAnnouncements?: true
    push_marketingNotifications?: true
    sms_loginAlerts?: true
    sms_securityUpdates?: true
    sms_emergencyAlerts?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserNotificationSettingsCountAggregateInputType = {
    id?: true
    userId?: true
    email_loginAlerts?: true
    email_securityUpdates?: true
    email_systemAnnouncements?: true
    email_marketingEmails?: true
    push_loginAlerts?: true
    push_securityUpdates?: true
    push_systemAnnouncements?: true
    push_marketingNotifications?: true
    sms_loginAlerts?: true
    sms_securityUpdates?: true
    sms_emergencyAlerts?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserNotificationSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserNotificationSettings to aggregate.
     */
    where?: UserNotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNotificationSettings to fetch.
     */
    orderBy?: UserNotificationSettingsOrderByWithRelationInput | UserNotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserNotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNotificationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserNotificationSettings
    **/
    _count?: true | UserNotificationSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserNotificationSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserNotificationSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserNotificationSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserNotificationSettingsMaxAggregateInputType
  }

  export type GetUserNotificationSettingsAggregateType<T extends UserNotificationSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserNotificationSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserNotificationSettings[P]>
      : GetScalarType<T[P], AggregateUserNotificationSettings[P]>
  }




  export type UserNotificationSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserNotificationSettingsWhereInput
    orderBy?: UserNotificationSettingsOrderByWithAggregationInput | UserNotificationSettingsOrderByWithAggregationInput[]
    by: UserNotificationSettingsScalarFieldEnum[] | UserNotificationSettingsScalarFieldEnum
    having?: UserNotificationSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserNotificationSettingsCountAggregateInputType | true
    _avg?: UserNotificationSettingsAvgAggregateInputType
    _sum?: UserNotificationSettingsSumAggregateInputType
    _min?: UserNotificationSettingsMinAggregateInputType
    _max?: UserNotificationSettingsMaxAggregateInputType
  }

  export type UserNotificationSettingsGroupByOutputType = {
    id: number
    userId: number
    email_loginAlerts: boolean
    email_securityUpdates: boolean
    email_systemAnnouncements: boolean
    email_marketingEmails: boolean
    push_loginAlerts: boolean
    push_securityUpdates: boolean
    push_systemAnnouncements: boolean
    push_marketingNotifications: boolean
    sms_loginAlerts: boolean
    sms_securityUpdates: boolean
    sms_emergencyAlerts: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserNotificationSettingsCountAggregateOutputType | null
    _avg: UserNotificationSettingsAvgAggregateOutputType | null
    _sum: UserNotificationSettingsSumAggregateOutputType | null
    _min: UserNotificationSettingsMinAggregateOutputType | null
    _max: UserNotificationSettingsMaxAggregateOutputType | null
  }

  type GetUserNotificationSettingsGroupByPayload<T extends UserNotificationSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserNotificationSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserNotificationSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserNotificationSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], UserNotificationSettingsGroupByOutputType[P]>
        }
      >
    >


  export type UserNotificationSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email_loginAlerts?: boolean
    email_securityUpdates?: boolean
    email_systemAnnouncements?: boolean
    email_marketingEmails?: boolean
    push_loginAlerts?: boolean
    push_securityUpdates?: boolean
    push_systemAnnouncements?: boolean
    push_marketingNotifications?: boolean
    sms_loginAlerts?: boolean
    sms_securityUpdates?: boolean
    sms_emergencyAlerts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userNotificationSettings"]>

  export type UserNotificationSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email_loginAlerts?: boolean
    email_securityUpdates?: boolean
    email_systemAnnouncements?: boolean
    email_marketingEmails?: boolean
    push_loginAlerts?: boolean
    push_securityUpdates?: boolean
    push_systemAnnouncements?: boolean
    push_marketingNotifications?: boolean
    sms_loginAlerts?: boolean
    sms_securityUpdates?: boolean
    sms_emergencyAlerts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userNotificationSettings"]>

  export type UserNotificationSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email_loginAlerts?: boolean
    email_securityUpdates?: boolean
    email_systemAnnouncements?: boolean
    email_marketingEmails?: boolean
    push_loginAlerts?: boolean
    push_securityUpdates?: boolean
    push_systemAnnouncements?: boolean
    push_marketingNotifications?: boolean
    sms_loginAlerts?: boolean
    sms_securityUpdates?: boolean
    sms_emergencyAlerts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userNotificationSettings"]>

  export type UserNotificationSettingsSelectScalar = {
    id?: boolean
    userId?: boolean
    email_loginAlerts?: boolean
    email_securityUpdates?: boolean
    email_systemAnnouncements?: boolean
    email_marketingEmails?: boolean
    push_loginAlerts?: boolean
    push_securityUpdates?: boolean
    push_systemAnnouncements?: boolean
    push_marketingNotifications?: boolean
    sms_loginAlerts?: boolean
    sms_securityUpdates?: boolean
    sms_emergencyAlerts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserNotificationSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "email_loginAlerts" | "email_securityUpdates" | "email_systemAnnouncements" | "email_marketingEmails" | "push_loginAlerts" | "push_securityUpdates" | "push_systemAnnouncements" | "push_marketingNotifications" | "sms_loginAlerts" | "sms_securityUpdates" | "sms_emergencyAlerts" | "createdAt" | "updatedAt", ExtArgs["result"]["userNotificationSettings"]>
  export type UserNotificationSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserNotificationSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserNotificationSettingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserNotificationSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserNotificationSettings"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      email_loginAlerts: boolean
      email_securityUpdates: boolean
      email_systemAnnouncements: boolean
      email_marketingEmails: boolean
      push_loginAlerts: boolean
      push_securityUpdates: boolean
      push_systemAnnouncements: boolean
      push_marketingNotifications: boolean
      sms_loginAlerts: boolean
      sms_securityUpdates: boolean
      sms_emergencyAlerts: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userNotificationSettings"]>
    composites: {}
  }

  type UserNotificationSettingsGetPayload<S extends boolean | null | undefined | UserNotificationSettingsDefaultArgs> = $Result.GetResult<Prisma.$UserNotificationSettingsPayload, S>

  type UserNotificationSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserNotificationSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserNotificationSettingsCountAggregateInputType | true
    }

  export interface UserNotificationSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserNotificationSettings'], meta: { name: 'UserNotificationSettings' } }
    /**
     * Find zero or one UserNotificationSettings that matches the filter.
     * @param {UserNotificationSettingsFindUniqueArgs} args - Arguments to find a UserNotificationSettings
     * @example
     * // Get one UserNotificationSettings
     * const userNotificationSettings = await prisma.userNotificationSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserNotificationSettingsFindUniqueArgs>(args: SelectSubset<T, UserNotificationSettingsFindUniqueArgs<ExtArgs>>): Prisma__UserNotificationSettingsClient<$Result.GetResult<Prisma.$UserNotificationSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserNotificationSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserNotificationSettingsFindUniqueOrThrowArgs} args - Arguments to find a UserNotificationSettings
     * @example
     * // Get one UserNotificationSettings
     * const userNotificationSettings = await prisma.userNotificationSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserNotificationSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserNotificationSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserNotificationSettingsClient<$Result.GetResult<Prisma.$UserNotificationSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserNotificationSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationSettingsFindFirstArgs} args - Arguments to find a UserNotificationSettings
     * @example
     * // Get one UserNotificationSettings
     * const userNotificationSettings = await prisma.userNotificationSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserNotificationSettingsFindFirstArgs>(args?: SelectSubset<T, UserNotificationSettingsFindFirstArgs<ExtArgs>>): Prisma__UserNotificationSettingsClient<$Result.GetResult<Prisma.$UserNotificationSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserNotificationSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationSettingsFindFirstOrThrowArgs} args - Arguments to find a UserNotificationSettings
     * @example
     * // Get one UserNotificationSettings
     * const userNotificationSettings = await prisma.userNotificationSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserNotificationSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserNotificationSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserNotificationSettingsClient<$Result.GetResult<Prisma.$UserNotificationSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserNotificationSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserNotificationSettings
     * const userNotificationSettings = await prisma.userNotificationSettings.findMany()
     * 
     * // Get first 10 UserNotificationSettings
     * const userNotificationSettings = await prisma.userNotificationSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userNotificationSettingsWithIdOnly = await prisma.userNotificationSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserNotificationSettingsFindManyArgs>(args?: SelectSubset<T, UserNotificationSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserNotificationSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserNotificationSettings.
     * @param {UserNotificationSettingsCreateArgs} args - Arguments to create a UserNotificationSettings.
     * @example
     * // Create one UserNotificationSettings
     * const UserNotificationSettings = await prisma.userNotificationSettings.create({
     *   data: {
     *     // ... data to create a UserNotificationSettings
     *   }
     * })
     * 
     */
    create<T extends UserNotificationSettingsCreateArgs>(args: SelectSubset<T, UserNotificationSettingsCreateArgs<ExtArgs>>): Prisma__UserNotificationSettingsClient<$Result.GetResult<Prisma.$UserNotificationSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserNotificationSettings.
     * @param {UserNotificationSettingsCreateManyArgs} args - Arguments to create many UserNotificationSettings.
     * @example
     * // Create many UserNotificationSettings
     * const userNotificationSettings = await prisma.userNotificationSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserNotificationSettingsCreateManyArgs>(args?: SelectSubset<T, UserNotificationSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserNotificationSettings and returns the data saved in the database.
     * @param {UserNotificationSettingsCreateManyAndReturnArgs} args - Arguments to create many UserNotificationSettings.
     * @example
     * // Create many UserNotificationSettings
     * const userNotificationSettings = await prisma.userNotificationSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserNotificationSettings and only return the `id`
     * const userNotificationSettingsWithIdOnly = await prisma.userNotificationSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserNotificationSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, UserNotificationSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserNotificationSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserNotificationSettings.
     * @param {UserNotificationSettingsDeleteArgs} args - Arguments to delete one UserNotificationSettings.
     * @example
     * // Delete one UserNotificationSettings
     * const UserNotificationSettings = await prisma.userNotificationSettings.delete({
     *   where: {
     *     // ... filter to delete one UserNotificationSettings
     *   }
     * })
     * 
     */
    delete<T extends UserNotificationSettingsDeleteArgs>(args: SelectSubset<T, UserNotificationSettingsDeleteArgs<ExtArgs>>): Prisma__UserNotificationSettingsClient<$Result.GetResult<Prisma.$UserNotificationSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserNotificationSettings.
     * @param {UserNotificationSettingsUpdateArgs} args - Arguments to update one UserNotificationSettings.
     * @example
     * // Update one UserNotificationSettings
     * const userNotificationSettings = await prisma.userNotificationSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserNotificationSettingsUpdateArgs>(args: SelectSubset<T, UserNotificationSettingsUpdateArgs<ExtArgs>>): Prisma__UserNotificationSettingsClient<$Result.GetResult<Prisma.$UserNotificationSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserNotificationSettings.
     * @param {UserNotificationSettingsDeleteManyArgs} args - Arguments to filter UserNotificationSettings to delete.
     * @example
     * // Delete a few UserNotificationSettings
     * const { count } = await prisma.userNotificationSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserNotificationSettingsDeleteManyArgs>(args?: SelectSubset<T, UserNotificationSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserNotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserNotificationSettings
     * const userNotificationSettings = await prisma.userNotificationSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserNotificationSettingsUpdateManyArgs>(args: SelectSubset<T, UserNotificationSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserNotificationSettings and returns the data updated in the database.
     * @param {UserNotificationSettingsUpdateManyAndReturnArgs} args - Arguments to update many UserNotificationSettings.
     * @example
     * // Update many UserNotificationSettings
     * const userNotificationSettings = await prisma.userNotificationSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserNotificationSettings and only return the `id`
     * const userNotificationSettingsWithIdOnly = await prisma.userNotificationSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserNotificationSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, UserNotificationSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserNotificationSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserNotificationSettings.
     * @param {UserNotificationSettingsUpsertArgs} args - Arguments to update or create a UserNotificationSettings.
     * @example
     * // Update or create a UserNotificationSettings
     * const userNotificationSettings = await prisma.userNotificationSettings.upsert({
     *   create: {
     *     // ... data to create a UserNotificationSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserNotificationSettings we want to update
     *   }
     * })
     */
    upsert<T extends UserNotificationSettingsUpsertArgs>(args: SelectSubset<T, UserNotificationSettingsUpsertArgs<ExtArgs>>): Prisma__UserNotificationSettingsClient<$Result.GetResult<Prisma.$UserNotificationSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserNotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationSettingsCountArgs} args - Arguments to filter UserNotificationSettings to count.
     * @example
     * // Count the number of UserNotificationSettings
     * const count = await prisma.userNotificationSettings.count({
     *   where: {
     *     // ... the filter for the UserNotificationSettings we want to count
     *   }
     * })
    **/
    count<T extends UserNotificationSettingsCountArgs>(
      args?: Subset<T, UserNotificationSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserNotificationSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserNotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserNotificationSettingsAggregateArgs>(args: Subset<T, UserNotificationSettingsAggregateArgs>): Prisma.PrismaPromise<GetUserNotificationSettingsAggregateType<T>>

    /**
     * Group by UserNotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserNotificationSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserNotificationSettingsGroupByArgs['orderBy'] }
        : { orderBy?: UserNotificationSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserNotificationSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserNotificationSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserNotificationSettings model
   */
  readonly fields: UserNotificationSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserNotificationSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserNotificationSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserNotificationSettings model
   */
  interface UserNotificationSettingsFieldRefs {
    readonly id: FieldRef<"UserNotificationSettings", 'Int'>
    readonly userId: FieldRef<"UserNotificationSettings", 'Int'>
    readonly email_loginAlerts: FieldRef<"UserNotificationSettings", 'Boolean'>
    readonly email_securityUpdates: FieldRef<"UserNotificationSettings", 'Boolean'>
    readonly email_systemAnnouncements: FieldRef<"UserNotificationSettings", 'Boolean'>
    readonly email_marketingEmails: FieldRef<"UserNotificationSettings", 'Boolean'>
    readonly push_loginAlerts: FieldRef<"UserNotificationSettings", 'Boolean'>
    readonly push_securityUpdates: FieldRef<"UserNotificationSettings", 'Boolean'>
    readonly push_systemAnnouncements: FieldRef<"UserNotificationSettings", 'Boolean'>
    readonly push_marketingNotifications: FieldRef<"UserNotificationSettings", 'Boolean'>
    readonly sms_loginAlerts: FieldRef<"UserNotificationSettings", 'Boolean'>
    readonly sms_securityUpdates: FieldRef<"UserNotificationSettings", 'Boolean'>
    readonly sms_emergencyAlerts: FieldRef<"UserNotificationSettings", 'Boolean'>
    readonly createdAt: FieldRef<"UserNotificationSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"UserNotificationSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserNotificationSettings findUnique
   */
  export type UserNotificationSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationSettings
     */
    select?: UserNotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNotificationSettings
     */
    omit?: UserNotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserNotificationSettings to fetch.
     */
    where: UserNotificationSettingsWhereUniqueInput
  }

  /**
   * UserNotificationSettings findUniqueOrThrow
   */
  export type UserNotificationSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationSettings
     */
    select?: UserNotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNotificationSettings
     */
    omit?: UserNotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserNotificationSettings to fetch.
     */
    where: UserNotificationSettingsWhereUniqueInput
  }

  /**
   * UserNotificationSettings findFirst
   */
  export type UserNotificationSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationSettings
     */
    select?: UserNotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNotificationSettings
     */
    omit?: UserNotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserNotificationSettings to fetch.
     */
    where?: UserNotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNotificationSettings to fetch.
     */
    orderBy?: UserNotificationSettingsOrderByWithRelationInput | UserNotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserNotificationSettings.
     */
    cursor?: UserNotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNotificationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserNotificationSettings.
     */
    distinct?: UserNotificationSettingsScalarFieldEnum | UserNotificationSettingsScalarFieldEnum[]
  }

  /**
   * UserNotificationSettings findFirstOrThrow
   */
  export type UserNotificationSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationSettings
     */
    select?: UserNotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNotificationSettings
     */
    omit?: UserNotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserNotificationSettings to fetch.
     */
    where?: UserNotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNotificationSettings to fetch.
     */
    orderBy?: UserNotificationSettingsOrderByWithRelationInput | UserNotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserNotificationSettings.
     */
    cursor?: UserNotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNotificationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserNotificationSettings.
     */
    distinct?: UserNotificationSettingsScalarFieldEnum | UserNotificationSettingsScalarFieldEnum[]
  }

  /**
   * UserNotificationSettings findMany
   */
  export type UserNotificationSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationSettings
     */
    select?: UserNotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNotificationSettings
     */
    omit?: UserNotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserNotificationSettings to fetch.
     */
    where?: UserNotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNotificationSettings to fetch.
     */
    orderBy?: UserNotificationSettingsOrderByWithRelationInput | UserNotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserNotificationSettings.
     */
    cursor?: UserNotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNotificationSettings.
     */
    skip?: number
    distinct?: UserNotificationSettingsScalarFieldEnum | UserNotificationSettingsScalarFieldEnum[]
  }

  /**
   * UserNotificationSettings create
   */
  export type UserNotificationSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationSettings
     */
    select?: UserNotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNotificationSettings
     */
    omit?: UserNotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserNotificationSettings.
     */
    data: XOR<UserNotificationSettingsCreateInput, UserNotificationSettingsUncheckedCreateInput>
  }

  /**
   * UserNotificationSettings createMany
   */
  export type UserNotificationSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserNotificationSettings.
     */
    data: UserNotificationSettingsCreateManyInput | UserNotificationSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserNotificationSettings createManyAndReturn
   */
  export type UserNotificationSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationSettings
     */
    select?: UserNotificationSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserNotificationSettings
     */
    omit?: UserNotificationSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many UserNotificationSettings.
     */
    data: UserNotificationSettingsCreateManyInput | UserNotificationSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserNotificationSettings update
   */
  export type UserNotificationSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationSettings
     */
    select?: UserNotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNotificationSettings
     */
    omit?: UserNotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserNotificationSettings.
     */
    data: XOR<UserNotificationSettingsUpdateInput, UserNotificationSettingsUncheckedUpdateInput>
    /**
     * Choose, which UserNotificationSettings to update.
     */
    where: UserNotificationSettingsWhereUniqueInput
  }

  /**
   * UserNotificationSettings updateMany
   */
  export type UserNotificationSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserNotificationSettings.
     */
    data: XOR<UserNotificationSettingsUpdateManyMutationInput, UserNotificationSettingsUncheckedUpdateManyInput>
    /**
     * Filter which UserNotificationSettings to update
     */
    where?: UserNotificationSettingsWhereInput
    /**
     * Limit how many UserNotificationSettings to update.
     */
    limit?: number
  }

  /**
   * UserNotificationSettings updateManyAndReturn
   */
  export type UserNotificationSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationSettings
     */
    select?: UserNotificationSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserNotificationSettings
     */
    omit?: UserNotificationSettingsOmit<ExtArgs> | null
    /**
     * The data used to update UserNotificationSettings.
     */
    data: XOR<UserNotificationSettingsUpdateManyMutationInput, UserNotificationSettingsUncheckedUpdateManyInput>
    /**
     * Filter which UserNotificationSettings to update
     */
    where?: UserNotificationSettingsWhereInput
    /**
     * Limit how many UserNotificationSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationSettingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserNotificationSettings upsert
   */
  export type UserNotificationSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationSettings
     */
    select?: UserNotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNotificationSettings
     */
    omit?: UserNotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserNotificationSettings to update in case it exists.
     */
    where: UserNotificationSettingsWhereUniqueInput
    /**
     * In case the UserNotificationSettings found by the `where` argument doesn't exist, create a new UserNotificationSettings with this data.
     */
    create: XOR<UserNotificationSettingsCreateInput, UserNotificationSettingsUncheckedCreateInput>
    /**
     * In case the UserNotificationSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserNotificationSettingsUpdateInput, UserNotificationSettingsUncheckedUpdateInput>
  }

  /**
   * UserNotificationSettings delete
   */
  export type UserNotificationSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationSettings
     */
    select?: UserNotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNotificationSettings
     */
    omit?: UserNotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter which UserNotificationSettings to delete.
     */
    where: UserNotificationSettingsWhereUniqueInput
  }

  /**
   * UserNotificationSettings deleteMany
   */
  export type UserNotificationSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserNotificationSettings to delete
     */
    where?: UserNotificationSettingsWhereInput
    /**
     * Limit how many UserNotificationSettings to delete.
     */
    limit?: number
  }

  /**
   * UserNotificationSettings without action
   */
  export type UserNotificationSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationSettings
     */
    select?: UserNotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNotificationSettings
     */
    omit?: UserNotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationSettingsInclude<ExtArgs> | null
  }


  /**
   * Model UserPrivacySettings
   */

  export type AggregateUserPrivacySettings = {
    _count: UserPrivacySettingsCountAggregateOutputType | null
    _avg: UserPrivacySettingsAvgAggregateOutputType | null
    _sum: UserPrivacySettingsSumAggregateOutputType | null
    _min: UserPrivacySettingsMinAggregateOutputType | null
    _max: UserPrivacySettingsMaxAggregateOutputType | null
  }

  export type UserPrivacySettingsAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserPrivacySettingsSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserPrivacySettingsMinAggregateOutputType = {
    id: number | null
    userId: number | null
    profileVisibility: string | null
    showEmail: boolean | null
    showPhone: boolean | null
    showLocation: boolean | null
    allowContact: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPrivacySettingsMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    profileVisibility: string | null
    showEmail: boolean | null
    showPhone: boolean | null
    showLocation: boolean | null
    allowContact: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPrivacySettingsCountAggregateOutputType = {
    id: number
    userId: number
    profileVisibility: number
    showEmail: number
    showPhone: number
    showLocation: number
    allowContact: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserPrivacySettingsAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserPrivacySettingsSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserPrivacySettingsMinAggregateInputType = {
    id?: true
    userId?: true
    profileVisibility?: true
    showEmail?: true
    showPhone?: true
    showLocation?: true
    allowContact?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPrivacySettingsMaxAggregateInputType = {
    id?: true
    userId?: true
    profileVisibility?: true
    showEmail?: true
    showPhone?: true
    showLocation?: true
    allowContact?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPrivacySettingsCountAggregateInputType = {
    id?: true
    userId?: true
    profileVisibility?: true
    showEmail?: true
    showPhone?: true
    showLocation?: true
    allowContact?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserPrivacySettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPrivacySettings to aggregate.
     */
    where?: UserPrivacySettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPrivacySettings to fetch.
     */
    orderBy?: UserPrivacySettingsOrderByWithRelationInput | UserPrivacySettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPrivacySettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPrivacySettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPrivacySettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPrivacySettings
    **/
    _count?: true | UserPrivacySettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserPrivacySettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserPrivacySettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPrivacySettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPrivacySettingsMaxAggregateInputType
  }

  export type GetUserPrivacySettingsAggregateType<T extends UserPrivacySettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPrivacySettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPrivacySettings[P]>
      : GetScalarType<T[P], AggregateUserPrivacySettings[P]>
  }




  export type UserPrivacySettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPrivacySettingsWhereInput
    orderBy?: UserPrivacySettingsOrderByWithAggregationInput | UserPrivacySettingsOrderByWithAggregationInput[]
    by: UserPrivacySettingsScalarFieldEnum[] | UserPrivacySettingsScalarFieldEnum
    having?: UserPrivacySettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPrivacySettingsCountAggregateInputType | true
    _avg?: UserPrivacySettingsAvgAggregateInputType
    _sum?: UserPrivacySettingsSumAggregateInputType
    _min?: UserPrivacySettingsMinAggregateInputType
    _max?: UserPrivacySettingsMaxAggregateInputType
  }

  export type UserPrivacySettingsGroupByOutputType = {
    id: number
    userId: number
    profileVisibility: string
    showEmail: boolean
    showPhone: boolean
    showLocation: boolean
    allowContact: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserPrivacySettingsCountAggregateOutputType | null
    _avg: UserPrivacySettingsAvgAggregateOutputType | null
    _sum: UserPrivacySettingsSumAggregateOutputType | null
    _min: UserPrivacySettingsMinAggregateOutputType | null
    _max: UserPrivacySettingsMaxAggregateOutputType | null
  }

  type GetUserPrivacySettingsGroupByPayload<T extends UserPrivacySettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPrivacySettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPrivacySettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPrivacySettingsGroupByOutputType[P]>
            : GetScalarType<T[P], UserPrivacySettingsGroupByOutputType[P]>
        }
      >
    >


  export type UserPrivacySettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    profileVisibility?: boolean
    showEmail?: boolean
    showPhone?: boolean
    showLocation?: boolean
    allowContact?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPrivacySettings"]>

  export type UserPrivacySettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    profileVisibility?: boolean
    showEmail?: boolean
    showPhone?: boolean
    showLocation?: boolean
    allowContact?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPrivacySettings"]>

  export type UserPrivacySettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    profileVisibility?: boolean
    showEmail?: boolean
    showPhone?: boolean
    showLocation?: boolean
    allowContact?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPrivacySettings"]>

  export type UserPrivacySettingsSelectScalar = {
    id?: boolean
    userId?: boolean
    profileVisibility?: boolean
    showEmail?: boolean
    showPhone?: boolean
    showLocation?: boolean
    allowContact?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserPrivacySettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "profileVisibility" | "showEmail" | "showPhone" | "showLocation" | "allowContact" | "createdAt" | "updatedAt", ExtArgs["result"]["userPrivacySettings"]>
  export type UserPrivacySettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPrivacySettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPrivacySettingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserPrivacySettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPrivacySettings"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      profileVisibility: string
      showEmail: boolean
      showPhone: boolean
      showLocation: boolean
      allowContact: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userPrivacySettings"]>
    composites: {}
  }

  type UserPrivacySettingsGetPayload<S extends boolean | null | undefined | UserPrivacySettingsDefaultArgs> = $Result.GetResult<Prisma.$UserPrivacySettingsPayload, S>

  type UserPrivacySettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPrivacySettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPrivacySettingsCountAggregateInputType | true
    }

  export interface UserPrivacySettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPrivacySettings'], meta: { name: 'UserPrivacySettings' } }
    /**
     * Find zero or one UserPrivacySettings that matches the filter.
     * @param {UserPrivacySettingsFindUniqueArgs} args - Arguments to find a UserPrivacySettings
     * @example
     * // Get one UserPrivacySettings
     * const userPrivacySettings = await prisma.userPrivacySettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPrivacySettingsFindUniqueArgs>(args: SelectSubset<T, UserPrivacySettingsFindUniqueArgs<ExtArgs>>): Prisma__UserPrivacySettingsClient<$Result.GetResult<Prisma.$UserPrivacySettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserPrivacySettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPrivacySettingsFindUniqueOrThrowArgs} args - Arguments to find a UserPrivacySettings
     * @example
     * // Get one UserPrivacySettings
     * const userPrivacySettings = await prisma.userPrivacySettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPrivacySettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPrivacySettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPrivacySettingsClient<$Result.GetResult<Prisma.$UserPrivacySettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPrivacySettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPrivacySettingsFindFirstArgs} args - Arguments to find a UserPrivacySettings
     * @example
     * // Get one UserPrivacySettings
     * const userPrivacySettings = await prisma.userPrivacySettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPrivacySettingsFindFirstArgs>(args?: SelectSubset<T, UserPrivacySettingsFindFirstArgs<ExtArgs>>): Prisma__UserPrivacySettingsClient<$Result.GetResult<Prisma.$UserPrivacySettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPrivacySettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPrivacySettingsFindFirstOrThrowArgs} args - Arguments to find a UserPrivacySettings
     * @example
     * // Get one UserPrivacySettings
     * const userPrivacySettings = await prisma.userPrivacySettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPrivacySettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPrivacySettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPrivacySettingsClient<$Result.GetResult<Prisma.$UserPrivacySettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPrivacySettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPrivacySettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPrivacySettings
     * const userPrivacySettings = await prisma.userPrivacySettings.findMany()
     * 
     * // Get first 10 UserPrivacySettings
     * const userPrivacySettings = await prisma.userPrivacySettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPrivacySettingsWithIdOnly = await prisma.userPrivacySettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPrivacySettingsFindManyArgs>(args?: SelectSubset<T, UserPrivacySettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPrivacySettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserPrivacySettings.
     * @param {UserPrivacySettingsCreateArgs} args - Arguments to create a UserPrivacySettings.
     * @example
     * // Create one UserPrivacySettings
     * const UserPrivacySettings = await prisma.userPrivacySettings.create({
     *   data: {
     *     // ... data to create a UserPrivacySettings
     *   }
     * })
     * 
     */
    create<T extends UserPrivacySettingsCreateArgs>(args: SelectSubset<T, UserPrivacySettingsCreateArgs<ExtArgs>>): Prisma__UserPrivacySettingsClient<$Result.GetResult<Prisma.$UserPrivacySettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserPrivacySettings.
     * @param {UserPrivacySettingsCreateManyArgs} args - Arguments to create many UserPrivacySettings.
     * @example
     * // Create many UserPrivacySettings
     * const userPrivacySettings = await prisma.userPrivacySettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPrivacySettingsCreateManyArgs>(args?: SelectSubset<T, UserPrivacySettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserPrivacySettings and returns the data saved in the database.
     * @param {UserPrivacySettingsCreateManyAndReturnArgs} args - Arguments to create many UserPrivacySettings.
     * @example
     * // Create many UserPrivacySettings
     * const userPrivacySettings = await prisma.userPrivacySettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserPrivacySettings and only return the `id`
     * const userPrivacySettingsWithIdOnly = await prisma.userPrivacySettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserPrivacySettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, UserPrivacySettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPrivacySettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserPrivacySettings.
     * @param {UserPrivacySettingsDeleteArgs} args - Arguments to delete one UserPrivacySettings.
     * @example
     * // Delete one UserPrivacySettings
     * const UserPrivacySettings = await prisma.userPrivacySettings.delete({
     *   where: {
     *     // ... filter to delete one UserPrivacySettings
     *   }
     * })
     * 
     */
    delete<T extends UserPrivacySettingsDeleteArgs>(args: SelectSubset<T, UserPrivacySettingsDeleteArgs<ExtArgs>>): Prisma__UserPrivacySettingsClient<$Result.GetResult<Prisma.$UserPrivacySettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserPrivacySettings.
     * @param {UserPrivacySettingsUpdateArgs} args - Arguments to update one UserPrivacySettings.
     * @example
     * // Update one UserPrivacySettings
     * const userPrivacySettings = await prisma.userPrivacySettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPrivacySettingsUpdateArgs>(args: SelectSubset<T, UserPrivacySettingsUpdateArgs<ExtArgs>>): Prisma__UserPrivacySettingsClient<$Result.GetResult<Prisma.$UserPrivacySettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserPrivacySettings.
     * @param {UserPrivacySettingsDeleteManyArgs} args - Arguments to filter UserPrivacySettings to delete.
     * @example
     * // Delete a few UserPrivacySettings
     * const { count } = await prisma.userPrivacySettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPrivacySettingsDeleteManyArgs>(args?: SelectSubset<T, UserPrivacySettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPrivacySettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPrivacySettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPrivacySettings
     * const userPrivacySettings = await prisma.userPrivacySettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPrivacySettingsUpdateManyArgs>(args: SelectSubset<T, UserPrivacySettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPrivacySettings and returns the data updated in the database.
     * @param {UserPrivacySettingsUpdateManyAndReturnArgs} args - Arguments to update many UserPrivacySettings.
     * @example
     * // Update many UserPrivacySettings
     * const userPrivacySettings = await prisma.userPrivacySettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserPrivacySettings and only return the `id`
     * const userPrivacySettingsWithIdOnly = await prisma.userPrivacySettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserPrivacySettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, UserPrivacySettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPrivacySettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserPrivacySettings.
     * @param {UserPrivacySettingsUpsertArgs} args - Arguments to update or create a UserPrivacySettings.
     * @example
     * // Update or create a UserPrivacySettings
     * const userPrivacySettings = await prisma.userPrivacySettings.upsert({
     *   create: {
     *     // ... data to create a UserPrivacySettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPrivacySettings we want to update
     *   }
     * })
     */
    upsert<T extends UserPrivacySettingsUpsertArgs>(args: SelectSubset<T, UserPrivacySettingsUpsertArgs<ExtArgs>>): Prisma__UserPrivacySettingsClient<$Result.GetResult<Prisma.$UserPrivacySettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserPrivacySettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPrivacySettingsCountArgs} args - Arguments to filter UserPrivacySettings to count.
     * @example
     * // Count the number of UserPrivacySettings
     * const count = await prisma.userPrivacySettings.count({
     *   where: {
     *     // ... the filter for the UserPrivacySettings we want to count
     *   }
     * })
    **/
    count<T extends UserPrivacySettingsCountArgs>(
      args?: Subset<T, UserPrivacySettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPrivacySettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPrivacySettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPrivacySettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPrivacySettingsAggregateArgs>(args: Subset<T, UserPrivacySettingsAggregateArgs>): Prisma.PrismaPromise<GetUserPrivacySettingsAggregateType<T>>

    /**
     * Group by UserPrivacySettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPrivacySettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPrivacySettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPrivacySettingsGroupByArgs['orderBy'] }
        : { orderBy?: UserPrivacySettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPrivacySettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPrivacySettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPrivacySettings model
   */
  readonly fields: UserPrivacySettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPrivacySettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPrivacySettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPrivacySettings model
   */
  interface UserPrivacySettingsFieldRefs {
    readonly id: FieldRef<"UserPrivacySettings", 'Int'>
    readonly userId: FieldRef<"UserPrivacySettings", 'Int'>
    readonly profileVisibility: FieldRef<"UserPrivacySettings", 'String'>
    readonly showEmail: FieldRef<"UserPrivacySettings", 'Boolean'>
    readonly showPhone: FieldRef<"UserPrivacySettings", 'Boolean'>
    readonly showLocation: FieldRef<"UserPrivacySettings", 'Boolean'>
    readonly allowContact: FieldRef<"UserPrivacySettings", 'Boolean'>
    readonly createdAt: FieldRef<"UserPrivacySettings", 'DateTime'>
    readonly updatedAt: FieldRef<"UserPrivacySettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserPrivacySettings findUnique
   */
  export type UserPrivacySettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPrivacySettings
     */
    select?: UserPrivacySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPrivacySettings
     */
    omit?: UserPrivacySettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPrivacySettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserPrivacySettings to fetch.
     */
    where: UserPrivacySettingsWhereUniqueInput
  }

  /**
   * UserPrivacySettings findUniqueOrThrow
   */
  export type UserPrivacySettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPrivacySettings
     */
    select?: UserPrivacySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPrivacySettings
     */
    omit?: UserPrivacySettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPrivacySettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserPrivacySettings to fetch.
     */
    where: UserPrivacySettingsWhereUniqueInput
  }

  /**
   * UserPrivacySettings findFirst
   */
  export type UserPrivacySettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPrivacySettings
     */
    select?: UserPrivacySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPrivacySettings
     */
    omit?: UserPrivacySettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPrivacySettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserPrivacySettings to fetch.
     */
    where?: UserPrivacySettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPrivacySettings to fetch.
     */
    orderBy?: UserPrivacySettingsOrderByWithRelationInput | UserPrivacySettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPrivacySettings.
     */
    cursor?: UserPrivacySettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPrivacySettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPrivacySettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPrivacySettings.
     */
    distinct?: UserPrivacySettingsScalarFieldEnum | UserPrivacySettingsScalarFieldEnum[]
  }

  /**
   * UserPrivacySettings findFirstOrThrow
   */
  export type UserPrivacySettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPrivacySettings
     */
    select?: UserPrivacySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPrivacySettings
     */
    omit?: UserPrivacySettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPrivacySettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserPrivacySettings to fetch.
     */
    where?: UserPrivacySettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPrivacySettings to fetch.
     */
    orderBy?: UserPrivacySettingsOrderByWithRelationInput | UserPrivacySettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPrivacySettings.
     */
    cursor?: UserPrivacySettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPrivacySettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPrivacySettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPrivacySettings.
     */
    distinct?: UserPrivacySettingsScalarFieldEnum | UserPrivacySettingsScalarFieldEnum[]
  }

  /**
   * UserPrivacySettings findMany
   */
  export type UserPrivacySettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPrivacySettings
     */
    select?: UserPrivacySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPrivacySettings
     */
    omit?: UserPrivacySettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPrivacySettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserPrivacySettings to fetch.
     */
    where?: UserPrivacySettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPrivacySettings to fetch.
     */
    orderBy?: UserPrivacySettingsOrderByWithRelationInput | UserPrivacySettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPrivacySettings.
     */
    cursor?: UserPrivacySettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPrivacySettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPrivacySettings.
     */
    skip?: number
    distinct?: UserPrivacySettingsScalarFieldEnum | UserPrivacySettingsScalarFieldEnum[]
  }

  /**
   * UserPrivacySettings create
   */
  export type UserPrivacySettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPrivacySettings
     */
    select?: UserPrivacySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPrivacySettings
     */
    omit?: UserPrivacySettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPrivacySettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPrivacySettings.
     */
    data: XOR<UserPrivacySettingsCreateInput, UserPrivacySettingsUncheckedCreateInput>
  }

  /**
   * UserPrivacySettings createMany
   */
  export type UserPrivacySettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPrivacySettings.
     */
    data: UserPrivacySettingsCreateManyInput | UserPrivacySettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPrivacySettings createManyAndReturn
   */
  export type UserPrivacySettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPrivacySettings
     */
    select?: UserPrivacySettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPrivacySettings
     */
    omit?: UserPrivacySettingsOmit<ExtArgs> | null
    /**
     * The data used to create many UserPrivacySettings.
     */
    data: UserPrivacySettingsCreateManyInput | UserPrivacySettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPrivacySettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPrivacySettings update
   */
  export type UserPrivacySettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPrivacySettings
     */
    select?: UserPrivacySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPrivacySettings
     */
    omit?: UserPrivacySettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPrivacySettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPrivacySettings.
     */
    data: XOR<UserPrivacySettingsUpdateInput, UserPrivacySettingsUncheckedUpdateInput>
    /**
     * Choose, which UserPrivacySettings to update.
     */
    where: UserPrivacySettingsWhereUniqueInput
  }

  /**
   * UserPrivacySettings updateMany
   */
  export type UserPrivacySettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPrivacySettings.
     */
    data: XOR<UserPrivacySettingsUpdateManyMutationInput, UserPrivacySettingsUncheckedUpdateManyInput>
    /**
     * Filter which UserPrivacySettings to update
     */
    where?: UserPrivacySettingsWhereInput
    /**
     * Limit how many UserPrivacySettings to update.
     */
    limit?: number
  }

  /**
   * UserPrivacySettings updateManyAndReturn
   */
  export type UserPrivacySettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPrivacySettings
     */
    select?: UserPrivacySettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPrivacySettings
     */
    omit?: UserPrivacySettingsOmit<ExtArgs> | null
    /**
     * The data used to update UserPrivacySettings.
     */
    data: XOR<UserPrivacySettingsUpdateManyMutationInput, UserPrivacySettingsUncheckedUpdateManyInput>
    /**
     * Filter which UserPrivacySettings to update
     */
    where?: UserPrivacySettingsWhereInput
    /**
     * Limit how many UserPrivacySettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPrivacySettingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPrivacySettings upsert
   */
  export type UserPrivacySettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPrivacySettings
     */
    select?: UserPrivacySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPrivacySettings
     */
    omit?: UserPrivacySettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPrivacySettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPrivacySettings to update in case it exists.
     */
    where: UserPrivacySettingsWhereUniqueInput
    /**
     * In case the UserPrivacySettings found by the `where` argument doesn't exist, create a new UserPrivacySettings with this data.
     */
    create: XOR<UserPrivacySettingsCreateInput, UserPrivacySettingsUncheckedCreateInput>
    /**
     * In case the UserPrivacySettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPrivacySettingsUpdateInput, UserPrivacySettingsUncheckedUpdateInput>
  }

  /**
   * UserPrivacySettings delete
   */
  export type UserPrivacySettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPrivacySettings
     */
    select?: UserPrivacySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPrivacySettings
     */
    omit?: UserPrivacySettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPrivacySettingsInclude<ExtArgs> | null
    /**
     * Filter which UserPrivacySettings to delete.
     */
    where: UserPrivacySettingsWhereUniqueInput
  }

  /**
   * UserPrivacySettings deleteMany
   */
  export type UserPrivacySettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPrivacySettings to delete
     */
    where?: UserPrivacySettingsWhereInput
    /**
     * Limit how many UserPrivacySettings to delete.
     */
    limit?: number
  }

  /**
   * UserPrivacySettings without action
   */
  export type UserPrivacySettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPrivacySettings
     */
    select?: UserPrivacySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPrivacySettings
     */
    omit?: UserPrivacySettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPrivacySettingsInclude<ExtArgs> | null
  }


  /**
   * Model Member
   */

  export type AggregateMember = {
    _count: MemberCountAggregateOutputType | null
    _avg: MemberAvgAggregateOutputType | null
    _sum: MemberSumAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  export type MemberAvgAggregateOutputType = {
    age: number | null
  }

  export type MemberSumAggregateOutputType = {
    age: number | null
  }

  export type MemberMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone_number: string | null
    password: string | null
    age: number | null
    profile_picture: string | null
    membershiptype: $Enums.MemberShipType | null
    createdAt: Date | null
    updatedAt: Date | null
    email_verification_expires: Date | null
    email_verification_token: string | null
    email_verified: boolean | null
    terms_accepted: boolean | null
    terms_accepted_at: Date | null
  }

  export type MemberMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone_number: string | null
    password: string | null
    age: number | null
    profile_picture: string | null
    membershiptype: $Enums.MemberShipType | null
    createdAt: Date | null
    updatedAt: Date | null
    email_verification_expires: Date | null
    email_verification_token: string | null
    email_verified: boolean | null
    terms_accepted: boolean | null
    terms_accepted_at: Date | null
  }

  export type MemberCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone_number: number
    password: number
    age: number
    profile_picture: number
    membershiptype: number
    createdAt: number
    updatedAt: number
    email_verification_expires: number
    email_verification_token: number
    email_verified: number
    terms_accepted: number
    terms_accepted_at: number
    _all: number
  }


  export type MemberAvgAggregateInputType = {
    age?: true
  }

  export type MemberSumAggregateInputType = {
    age?: true
  }

  export type MemberMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone_number?: true
    password?: true
    age?: true
    profile_picture?: true
    membershiptype?: true
    createdAt?: true
    updatedAt?: true
    email_verification_expires?: true
    email_verification_token?: true
    email_verified?: true
    terms_accepted?: true
    terms_accepted_at?: true
  }

  export type MemberMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone_number?: true
    password?: true
    age?: true
    profile_picture?: true
    membershiptype?: true
    createdAt?: true
    updatedAt?: true
    email_verification_expires?: true
    email_verification_token?: true
    email_verified?: true
    terms_accepted?: true
    terms_accepted_at?: true
  }

  export type MemberCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone_number?: true
    password?: true
    age?: true
    profile_picture?: true
    membershiptype?: true
    createdAt?: true
    updatedAt?: true
    email_verification_expires?: true
    email_verification_token?: true
    email_verified?: true
    terms_accepted?: true
    terms_accepted_at?: true
    _all?: true
  }

  export type MemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Member to aggregate.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Members
    **/
    _count?: true | MemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberMaxAggregateInputType
  }

  export type GetMemberAggregateType<T extends MemberAggregateArgs> = {
        [P in keyof T & keyof AggregateMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMember[P]>
      : GetScalarType<T[P], AggregateMember[P]>
  }




  export type MemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithAggregationInput | MemberOrderByWithAggregationInput[]
    by: MemberScalarFieldEnum[] | MemberScalarFieldEnum
    having?: MemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberCountAggregateInputType | true
    _avg?: MemberAvgAggregateInputType
    _sum?: MemberSumAggregateInputType
    _min?: MemberMinAggregateInputType
    _max?: MemberMaxAggregateInputType
  }

  export type MemberGroupByOutputType = {
    id: string
    name: string
    email: string
    phone_number: string | null
    password: string
    age: number
    profile_picture: string | null
    membershiptype: $Enums.MemberShipType
    createdAt: Date
    updatedAt: Date
    email_verification_expires: Date | null
    email_verification_token: string | null
    email_verified: boolean
    terms_accepted: boolean
    terms_accepted_at: Date | null
    _count: MemberCountAggregateOutputType | null
    _avg: MemberAvgAggregateOutputType | null
    _sum: MemberSumAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  type GetMemberGroupByPayload<T extends MemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberGroupByOutputType[P]>
            : GetScalarType<T[P], MemberGroupByOutputType[P]>
        }
      >
    >


  export type MemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone_number?: boolean
    password?: boolean
    age?: boolean
    profile_picture?: boolean
    membershiptype?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email_verification_expires?: boolean
    email_verification_token?: boolean
    email_verified?: boolean
    terms_accepted?: boolean
    terms_accepted_at?: boolean
    address?: boolean | Member$addressArgs<ExtArgs>
    emergency_contact?: boolean | Member$emergency_contactArgs<ExtArgs>
    invoices?: boolean | Member$invoicesArgs<ExtArgs>
    medical_info?: boolean | Member$medical_infoArgs<ExtArgs>
    attendance?: boolean | Member$attendanceArgs<ExtArgs>
    check_ins?: boolean | Member$check_insArgs<ExtArgs>
    fitness_goals?: boolean | Member$fitness_goalsArgs<ExtArgs>
    payments?: boolean | Member$paymentsArgs<ExtArgs>
    Subscription?: boolean | Member$SubscriptionArgs<ExtArgs>
    _count?: boolean | MemberCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["member"]>

  export type MemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone_number?: boolean
    password?: boolean
    age?: boolean
    profile_picture?: boolean
    membershiptype?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email_verification_expires?: boolean
    email_verification_token?: boolean
    email_verified?: boolean
    terms_accepted?: boolean
    terms_accepted_at?: boolean
  }, ExtArgs["result"]["member"]>

  export type MemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone_number?: boolean
    password?: boolean
    age?: boolean
    profile_picture?: boolean
    membershiptype?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email_verification_expires?: boolean
    email_verification_token?: boolean
    email_verified?: boolean
    terms_accepted?: boolean
    terms_accepted_at?: boolean
  }, ExtArgs["result"]["member"]>

  export type MemberSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone_number?: boolean
    password?: boolean
    age?: boolean
    profile_picture?: boolean
    membershiptype?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email_verification_expires?: boolean
    email_verification_token?: boolean
    email_verified?: boolean
    terms_accepted?: boolean
    terms_accepted_at?: boolean
  }

  export type MemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone_number" | "password" | "age" | "profile_picture" | "membershiptype" | "createdAt" | "updatedAt" | "email_verification_expires" | "email_verification_token" | "email_verified" | "terms_accepted" | "terms_accepted_at", ExtArgs["result"]["member"]>
  export type MemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | Member$addressArgs<ExtArgs>
    emergency_contact?: boolean | Member$emergency_contactArgs<ExtArgs>
    invoices?: boolean | Member$invoicesArgs<ExtArgs>
    medical_info?: boolean | Member$medical_infoArgs<ExtArgs>
    attendance?: boolean | Member$attendanceArgs<ExtArgs>
    check_ins?: boolean | Member$check_insArgs<ExtArgs>
    fitness_goals?: boolean | Member$fitness_goalsArgs<ExtArgs>
    payments?: boolean | Member$paymentsArgs<ExtArgs>
    Subscription?: boolean | Member$SubscriptionArgs<ExtArgs>
    _count?: boolean | MemberCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Member"
    objects: {
      address: Prisma.$AddressPayload<ExtArgs> | null
      emergency_contact: Prisma.$EmergencyContactPayload<ExtArgs> | null
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      medical_info: Prisma.$MedicalInfoPayload<ExtArgs> | null
      attendance: Prisma.$MemberAttendancePayload<ExtArgs>[]
      check_ins: Prisma.$MemberCheckInPayload<ExtArgs>[]
      fitness_goals: Prisma.$MemberFitnessGoalPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      Subscription: Prisma.$SubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      phone_number: string | null
      password: string
      age: number
      profile_picture: string | null
      membershiptype: $Enums.MemberShipType
      createdAt: Date
      updatedAt: Date
      email_verification_expires: Date | null
      email_verification_token: string | null
      email_verified: boolean
      terms_accepted: boolean
      terms_accepted_at: Date | null
    }, ExtArgs["result"]["member"]>
    composites: {}
  }

  type MemberGetPayload<S extends boolean | null | undefined | MemberDefaultArgs> = $Result.GetResult<Prisma.$MemberPayload, S>

  type MemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MemberCountAggregateInputType | true
    }

  export interface MemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Member'], meta: { name: 'Member' } }
    /**
     * Find zero or one Member that matches the filter.
     * @param {MemberFindUniqueArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MemberFindUniqueArgs>(args: SelectSubset<T, MemberFindUniqueArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Member that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MemberFindUniqueOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MemberFindUniqueOrThrowArgs>(args: SelectSubset<T, MemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Member that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindFirstArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MemberFindFirstArgs>(args?: SelectSubset<T, MemberFindFirstArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Member that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindFirstOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MemberFindFirstOrThrowArgs>(args?: SelectSubset<T, MemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Members
     * const members = await prisma.member.findMany()
     * 
     * // Get first 10 Members
     * const members = await prisma.member.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberWithIdOnly = await prisma.member.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MemberFindManyArgs>(args?: SelectSubset<T, MemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Member.
     * @param {MemberCreateArgs} args - Arguments to create a Member.
     * @example
     * // Create one Member
     * const Member = await prisma.member.create({
     *   data: {
     *     // ... data to create a Member
     *   }
     * })
     * 
     */
    create<T extends MemberCreateArgs>(args: SelectSubset<T, MemberCreateArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Members.
     * @param {MemberCreateManyArgs} args - Arguments to create many Members.
     * @example
     * // Create many Members
     * const member = await prisma.member.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MemberCreateManyArgs>(args?: SelectSubset<T, MemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Members and returns the data saved in the database.
     * @param {MemberCreateManyAndReturnArgs} args - Arguments to create many Members.
     * @example
     * // Create many Members
     * const member = await prisma.member.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Members and only return the `id`
     * const memberWithIdOnly = await prisma.member.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MemberCreateManyAndReturnArgs>(args?: SelectSubset<T, MemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Member.
     * @param {MemberDeleteArgs} args - Arguments to delete one Member.
     * @example
     * // Delete one Member
     * const Member = await prisma.member.delete({
     *   where: {
     *     // ... filter to delete one Member
     *   }
     * })
     * 
     */
    delete<T extends MemberDeleteArgs>(args: SelectSubset<T, MemberDeleteArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Member.
     * @param {MemberUpdateArgs} args - Arguments to update one Member.
     * @example
     * // Update one Member
     * const member = await prisma.member.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MemberUpdateArgs>(args: SelectSubset<T, MemberUpdateArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Members.
     * @param {MemberDeleteManyArgs} args - Arguments to filter Members to delete.
     * @example
     * // Delete a few Members
     * const { count } = await prisma.member.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MemberDeleteManyArgs>(args?: SelectSubset<T, MemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Members
     * const member = await prisma.member.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MemberUpdateManyArgs>(args: SelectSubset<T, MemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Members and returns the data updated in the database.
     * @param {MemberUpdateManyAndReturnArgs} args - Arguments to update many Members.
     * @example
     * // Update many Members
     * const member = await prisma.member.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Members and only return the `id`
     * const memberWithIdOnly = await prisma.member.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MemberUpdateManyAndReturnArgs>(args: SelectSubset<T, MemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Member.
     * @param {MemberUpsertArgs} args - Arguments to update or create a Member.
     * @example
     * // Update or create a Member
     * const member = await prisma.member.upsert({
     *   create: {
     *     // ... data to create a Member
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Member we want to update
     *   }
     * })
     */
    upsert<T extends MemberUpsertArgs>(args: SelectSubset<T, MemberUpsertArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCountArgs} args - Arguments to filter Members to count.
     * @example
     * // Count the number of Members
     * const count = await prisma.member.count({
     *   where: {
     *     // ... the filter for the Members we want to count
     *   }
     * })
    **/
    count<T extends MemberCountArgs>(
      args?: Subset<T, MemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberAggregateArgs>(args: Subset<T, MemberAggregateArgs>): Prisma.PrismaPromise<GetMemberAggregateType<T>>

    /**
     * Group by Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberGroupByArgs['orderBy'] }
        : { orderBy?: MemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Member model
   */
  readonly fields: MemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Member.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    address<T extends Member$addressArgs<ExtArgs> = {}>(args?: Subset<T, Member$addressArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    emergency_contact<T extends Member$emergency_contactArgs<ExtArgs> = {}>(args?: Subset<T, Member$emergency_contactArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    invoices<T extends Member$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Member$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    medical_info<T extends Member$medical_infoArgs<ExtArgs> = {}>(args?: Subset<T, Member$medical_infoArgs<ExtArgs>>): Prisma__MedicalInfoClient<$Result.GetResult<Prisma.$MedicalInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    attendance<T extends Member$attendanceArgs<ExtArgs> = {}>(args?: Subset<T, Member$attendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberAttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    check_ins<T extends Member$check_insArgs<ExtArgs> = {}>(args?: Subset<T, Member$check_insArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberCheckInPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fitness_goals<T extends Member$fitness_goalsArgs<ExtArgs> = {}>(args?: Subset<T, Member$fitness_goalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberFitnessGoalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Member$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Member$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Subscription<T extends Member$SubscriptionArgs<ExtArgs> = {}>(args?: Subset<T, Member$SubscriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Member model
   */
  interface MemberFieldRefs {
    readonly id: FieldRef<"Member", 'String'>
    readonly name: FieldRef<"Member", 'String'>
    readonly email: FieldRef<"Member", 'String'>
    readonly phone_number: FieldRef<"Member", 'String'>
    readonly password: FieldRef<"Member", 'String'>
    readonly age: FieldRef<"Member", 'Int'>
    readonly profile_picture: FieldRef<"Member", 'String'>
    readonly membershiptype: FieldRef<"Member", 'MemberShipType'>
    readonly createdAt: FieldRef<"Member", 'DateTime'>
    readonly updatedAt: FieldRef<"Member", 'DateTime'>
    readonly email_verification_expires: FieldRef<"Member", 'DateTime'>
    readonly email_verification_token: FieldRef<"Member", 'String'>
    readonly email_verified: FieldRef<"Member", 'Boolean'>
    readonly terms_accepted: FieldRef<"Member", 'Boolean'>
    readonly terms_accepted_at: FieldRef<"Member", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Member findUnique
   */
  export type MemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member findUniqueOrThrow
   */
  export type MemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member findFirst
   */
  export type MemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member findFirstOrThrow
   */
  export type MemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member findMany
   */
  export type MemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Members to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member create
   */
  export type MemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The data needed to create a Member.
     */
    data: XOR<MemberCreateInput, MemberUncheckedCreateInput>
  }

  /**
   * Member createMany
   */
  export type MemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Members.
     */
    data: MemberCreateManyInput | MemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Member createManyAndReturn
   */
  export type MemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * The data used to create many Members.
     */
    data: MemberCreateManyInput | MemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Member update
   */
  export type MemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The data needed to update a Member.
     */
    data: XOR<MemberUpdateInput, MemberUncheckedUpdateInput>
    /**
     * Choose, which Member to update.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member updateMany
   */
  export type MemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Members.
     */
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyInput>
    /**
     * Filter which Members to update
     */
    where?: MemberWhereInput
    /**
     * Limit how many Members to update.
     */
    limit?: number
  }

  /**
   * Member updateManyAndReturn
   */
  export type MemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * The data used to update Members.
     */
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyInput>
    /**
     * Filter which Members to update
     */
    where?: MemberWhereInput
    /**
     * Limit how many Members to update.
     */
    limit?: number
  }

  /**
   * Member upsert
   */
  export type MemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The filter to search for the Member to update in case it exists.
     */
    where: MemberWhereUniqueInput
    /**
     * In case the Member found by the `where` argument doesn't exist, create a new Member with this data.
     */
    create: XOR<MemberCreateInput, MemberUncheckedCreateInput>
    /**
     * In case the Member was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberUpdateInput, MemberUncheckedUpdateInput>
  }

  /**
   * Member delete
   */
  export type MemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter which Member to delete.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member deleteMany
   */
  export type MemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Members to delete
     */
    where?: MemberWhereInput
    /**
     * Limit how many Members to delete.
     */
    limit?: number
  }

  /**
   * Member.address
   */
  export type Member$addressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
  }

  /**
   * Member.emergency_contact
   */
  export type Member$emergency_contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    where?: EmergencyContactWhereInput
  }

  /**
   * Member.invoices
   */
  export type Member$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Member.medical_info
   */
  export type Member$medical_infoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalInfo
     */
    select?: MedicalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalInfo
     */
    omit?: MedicalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalInfoInclude<ExtArgs> | null
    where?: MedicalInfoWhereInput
  }

  /**
   * Member.attendance
   */
  export type Member$attendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberAttendance
     */
    select?: MemberAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberAttendance
     */
    omit?: MemberAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberAttendanceInclude<ExtArgs> | null
    where?: MemberAttendanceWhereInput
    orderBy?: MemberAttendanceOrderByWithRelationInput | MemberAttendanceOrderByWithRelationInput[]
    cursor?: MemberAttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberAttendanceScalarFieldEnum | MemberAttendanceScalarFieldEnum[]
  }

  /**
   * Member.check_ins
   */
  export type Member$check_insArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCheckIn
     */
    select?: MemberCheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberCheckIn
     */
    omit?: MemberCheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberCheckInInclude<ExtArgs> | null
    where?: MemberCheckInWhereInput
    orderBy?: MemberCheckInOrderByWithRelationInput | MemberCheckInOrderByWithRelationInput[]
    cursor?: MemberCheckInWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberCheckInScalarFieldEnum | MemberCheckInScalarFieldEnum[]
  }

  /**
   * Member.fitness_goals
   */
  export type Member$fitness_goalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberFitnessGoal
     */
    select?: MemberFitnessGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberFitnessGoal
     */
    omit?: MemberFitnessGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberFitnessGoalInclude<ExtArgs> | null
    where?: MemberFitnessGoalWhereInput
    orderBy?: MemberFitnessGoalOrderByWithRelationInput | MemberFitnessGoalOrderByWithRelationInput[]
    cursor?: MemberFitnessGoalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberFitnessGoalScalarFieldEnum | MemberFitnessGoalScalarFieldEnum[]
  }

  /**
   * Member.payments
   */
  export type Member$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Member.Subscription
   */
  export type Member$SubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Member without action
   */
  export type MemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
  }


  /**
   * Model MemberCheckIn
   */

  export type AggregateMemberCheckIn = {
    _count: MemberCheckInCountAggregateOutputType | null
    _min: MemberCheckInMinAggregateOutputType | null
    _max: MemberCheckInMaxAggregateOutputType | null
  }

  export type MemberCheckInMinAggregateOutputType = {
    id: string | null
    memberId: string | null
    checkInTime: Date | null
    checkOutTime: Date | null
    location: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberCheckInMaxAggregateOutputType = {
    id: string | null
    memberId: string | null
    checkInTime: Date | null
    checkOutTime: Date | null
    location: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberCheckInCountAggregateOutputType = {
    id: number
    memberId: number
    checkInTime: number
    checkOutTime: number
    location: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MemberCheckInMinAggregateInputType = {
    id?: true
    memberId?: true
    checkInTime?: true
    checkOutTime?: true
    location?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberCheckInMaxAggregateInputType = {
    id?: true
    memberId?: true
    checkInTime?: true
    checkOutTime?: true
    location?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberCheckInCountAggregateInputType = {
    id?: true
    memberId?: true
    checkInTime?: true
    checkOutTime?: true
    location?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MemberCheckInAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberCheckIn to aggregate.
     */
    where?: MemberCheckInWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberCheckIns to fetch.
     */
    orderBy?: MemberCheckInOrderByWithRelationInput | MemberCheckInOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberCheckInWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberCheckIns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberCheckIns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MemberCheckIns
    **/
    _count?: true | MemberCheckInCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberCheckInMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberCheckInMaxAggregateInputType
  }

  export type GetMemberCheckInAggregateType<T extends MemberCheckInAggregateArgs> = {
        [P in keyof T & keyof AggregateMemberCheckIn]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMemberCheckIn[P]>
      : GetScalarType<T[P], AggregateMemberCheckIn[P]>
  }




  export type MemberCheckInGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberCheckInWhereInput
    orderBy?: MemberCheckInOrderByWithAggregationInput | MemberCheckInOrderByWithAggregationInput[]
    by: MemberCheckInScalarFieldEnum[] | MemberCheckInScalarFieldEnum
    having?: MemberCheckInScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberCheckInCountAggregateInputType | true
    _min?: MemberCheckInMinAggregateInputType
    _max?: MemberCheckInMaxAggregateInputType
  }

  export type MemberCheckInGroupByOutputType = {
    id: string
    memberId: string
    checkInTime: Date
    checkOutTime: Date | null
    location: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: MemberCheckInCountAggregateOutputType | null
    _min: MemberCheckInMinAggregateOutputType | null
    _max: MemberCheckInMaxAggregateOutputType | null
  }

  type GetMemberCheckInGroupByPayload<T extends MemberCheckInGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberCheckInGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberCheckInGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberCheckInGroupByOutputType[P]>
            : GetScalarType<T[P], MemberCheckInGroupByOutputType[P]>
        }
      >
    >


  export type MemberCheckInSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    location?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["memberCheckIn"]>

  export type MemberCheckInSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    location?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["memberCheckIn"]>

  export type MemberCheckInSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    location?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["memberCheckIn"]>

  export type MemberCheckInSelectScalar = {
    id?: boolean
    memberId?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    location?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MemberCheckInOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "memberId" | "checkInTime" | "checkOutTime" | "location" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["memberCheckIn"]>
  export type MemberCheckInInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type MemberCheckInIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type MemberCheckInIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }

  export type $MemberCheckInPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MemberCheckIn"
    objects: {
      member: Prisma.$MemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      memberId: string
      checkInTime: Date
      checkOutTime: Date | null
      location: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["memberCheckIn"]>
    composites: {}
  }

  type MemberCheckInGetPayload<S extends boolean | null | undefined | MemberCheckInDefaultArgs> = $Result.GetResult<Prisma.$MemberCheckInPayload, S>

  type MemberCheckInCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MemberCheckInFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MemberCheckInCountAggregateInputType | true
    }

  export interface MemberCheckInDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MemberCheckIn'], meta: { name: 'MemberCheckIn' } }
    /**
     * Find zero or one MemberCheckIn that matches the filter.
     * @param {MemberCheckInFindUniqueArgs} args - Arguments to find a MemberCheckIn
     * @example
     * // Get one MemberCheckIn
     * const memberCheckIn = await prisma.memberCheckIn.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MemberCheckInFindUniqueArgs>(args: SelectSubset<T, MemberCheckInFindUniqueArgs<ExtArgs>>): Prisma__MemberCheckInClient<$Result.GetResult<Prisma.$MemberCheckInPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MemberCheckIn that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MemberCheckInFindUniqueOrThrowArgs} args - Arguments to find a MemberCheckIn
     * @example
     * // Get one MemberCheckIn
     * const memberCheckIn = await prisma.memberCheckIn.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MemberCheckInFindUniqueOrThrowArgs>(args: SelectSubset<T, MemberCheckInFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MemberCheckInClient<$Result.GetResult<Prisma.$MemberCheckInPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MemberCheckIn that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCheckInFindFirstArgs} args - Arguments to find a MemberCheckIn
     * @example
     * // Get one MemberCheckIn
     * const memberCheckIn = await prisma.memberCheckIn.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MemberCheckInFindFirstArgs>(args?: SelectSubset<T, MemberCheckInFindFirstArgs<ExtArgs>>): Prisma__MemberCheckInClient<$Result.GetResult<Prisma.$MemberCheckInPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MemberCheckIn that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCheckInFindFirstOrThrowArgs} args - Arguments to find a MemberCheckIn
     * @example
     * // Get one MemberCheckIn
     * const memberCheckIn = await prisma.memberCheckIn.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MemberCheckInFindFirstOrThrowArgs>(args?: SelectSubset<T, MemberCheckInFindFirstOrThrowArgs<ExtArgs>>): Prisma__MemberCheckInClient<$Result.GetResult<Prisma.$MemberCheckInPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MemberCheckIns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCheckInFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MemberCheckIns
     * const memberCheckIns = await prisma.memberCheckIn.findMany()
     * 
     * // Get first 10 MemberCheckIns
     * const memberCheckIns = await prisma.memberCheckIn.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberCheckInWithIdOnly = await prisma.memberCheckIn.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MemberCheckInFindManyArgs>(args?: SelectSubset<T, MemberCheckInFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberCheckInPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MemberCheckIn.
     * @param {MemberCheckInCreateArgs} args - Arguments to create a MemberCheckIn.
     * @example
     * // Create one MemberCheckIn
     * const MemberCheckIn = await prisma.memberCheckIn.create({
     *   data: {
     *     // ... data to create a MemberCheckIn
     *   }
     * })
     * 
     */
    create<T extends MemberCheckInCreateArgs>(args: SelectSubset<T, MemberCheckInCreateArgs<ExtArgs>>): Prisma__MemberCheckInClient<$Result.GetResult<Prisma.$MemberCheckInPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MemberCheckIns.
     * @param {MemberCheckInCreateManyArgs} args - Arguments to create many MemberCheckIns.
     * @example
     * // Create many MemberCheckIns
     * const memberCheckIn = await prisma.memberCheckIn.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MemberCheckInCreateManyArgs>(args?: SelectSubset<T, MemberCheckInCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MemberCheckIns and returns the data saved in the database.
     * @param {MemberCheckInCreateManyAndReturnArgs} args - Arguments to create many MemberCheckIns.
     * @example
     * // Create many MemberCheckIns
     * const memberCheckIn = await prisma.memberCheckIn.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MemberCheckIns and only return the `id`
     * const memberCheckInWithIdOnly = await prisma.memberCheckIn.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MemberCheckInCreateManyAndReturnArgs>(args?: SelectSubset<T, MemberCheckInCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberCheckInPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MemberCheckIn.
     * @param {MemberCheckInDeleteArgs} args - Arguments to delete one MemberCheckIn.
     * @example
     * // Delete one MemberCheckIn
     * const MemberCheckIn = await prisma.memberCheckIn.delete({
     *   where: {
     *     // ... filter to delete one MemberCheckIn
     *   }
     * })
     * 
     */
    delete<T extends MemberCheckInDeleteArgs>(args: SelectSubset<T, MemberCheckInDeleteArgs<ExtArgs>>): Prisma__MemberCheckInClient<$Result.GetResult<Prisma.$MemberCheckInPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MemberCheckIn.
     * @param {MemberCheckInUpdateArgs} args - Arguments to update one MemberCheckIn.
     * @example
     * // Update one MemberCheckIn
     * const memberCheckIn = await prisma.memberCheckIn.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MemberCheckInUpdateArgs>(args: SelectSubset<T, MemberCheckInUpdateArgs<ExtArgs>>): Prisma__MemberCheckInClient<$Result.GetResult<Prisma.$MemberCheckInPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MemberCheckIns.
     * @param {MemberCheckInDeleteManyArgs} args - Arguments to filter MemberCheckIns to delete.
     * @example
     * // Delete a few MemberCheckIns
     * const { count } = await prisma.memberCheckIn.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MemberCheckInDeleteManyArgs>(args?: SelectSubset<T, MemberCheckInDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberCheckIns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCheckInUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MemberCheckIns
     * const memberCheckIn = await prisma.memberCheckIn.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MemberCheckInUpdateManyArgs>(args: SelectSubset<T, MemberCheckInUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberCheckIns and returns the data updated in the database.
     * @param {MemberCheckInUpdateManyAndReturnArgs} args - Arguments to update many MemberCheckIns.
     * @example
     * // Update many MemberCheckIns
     * const memberCheckIn = await prisma.memberCheckIn.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MemberCheckIns and only return the `id`
     * const memberCheckInWithIdOnly = await prisma.memberCheckIn.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MemberCheckInUpdateManyAndReturnArgs>(args: SelectSubset<T, MemberCheckInUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberCheckInPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MemberCheckIn.
     * @param {MemberCheckInUpsertArgs} args - Arguments to update or create a MemberCheckIn.
     * @example
     * // Update or create a MemberCheckIn
     * const memberCheckIn = await prisma.memberCheckIn.upsert({
     *   create: {
     *     // ... data to create a MemberCheckIn
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MemberCheckIn we want to update
     *   }
     * })
     */
    upsert<T extends MemberCheckInUpsertArgs>(args: SelectSubset<T, MemberCheckInUpsertArgs<ExtArgs>>): Prisma__MemberCheckInClient<$Result.GetResult<Prisma.$MemberCheckInPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MemberCheckIns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCheckInCountArgs} args - Arguments to filter MemberCheckIns to count.
     * @example
     * // Count the number of MemberCheckIns
     * const count = await prisma.memberCheckIn.count({
     *   where: {
     *     // ... the filter for the MemberCheckIns we want to count
     *   }
     * })
    **/
    count<T extends MemberCheckInCountArgs>(
      args?: Subset<T, MemberCheckInCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberCheckInCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MemberCheckIn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCheckInAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberCheckInAggregateArgs>(args: Subset<T, MemberCheckInAggregateArgs>): Prisma.PrismaPromise<GetMemberCheckInAggregateType<T>>

    /**
     * Group by MemberCheckIn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCheckInGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberCheckInGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberCheckInGroupByArgs['orderBy'] }
        : { orderBy?: MemberCheckInGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberCheckInGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberCheckInGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MemberCheckIn model
   */
  readonly fields: MemberCheckInFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MemberCheckIn.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberCheckInClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MemberCheckIn model
   */
  interface MemberCheckInFieldRefs {
    readonly id: FieldRef<"MemberCheckIn", 'String'>
    readonly memberId: FieldRef<"MemberCheckIn", 'String'>
    readonly checkInTime: FieldRef<"MemberCheckIn", 'DateTime'>
    readonly checkOutTime: FieldRef<"MemberCheckIn", 'DateTime'>
    readonly location: FieldRef<"MemberCheckIn", 'String'>
    readonly notes: FieldRef<"MemberCheckIn", 'String'>
    readonly createdAt: FieldRef<"MemberCheckIn", 'DateTime'>
    readonly updatedAt: FieldRef<"MemberCheckIn", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MemberCheckIn findUnique
   */
  export type MemberCheckInFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCheckIn
     */
    select?: MemberCheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberCheckIn
     */
    omit?: MemberCheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberCheckInInclude<ExtArgs> | null
    /**
     * Filter, which MemberCheckIn to fetch.
     */
    where: MemberCheckInWhereUniqueInput
  }

  /**
   * MemberCheckIn findUniqueOrThrow
   */
  export type MemberCheckInFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCheckIn
     */
    select?: MemberCheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberCheckIn
     */
    omit?: MemberCheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberCheckInInclude<ExtArgs> | null
    /**
     * Filter, which MemberCheckIn to fetch.
     */
    where: MemberCheckInWhereUniqueInput
  }

  /**
   * MemberCheckIn findFirst
   */
  export type MemberCheckInFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCheckIn
     */
    select?: MemberCheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberCheckIn
     */
    omit?: MemberCheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberCheckInInclude<ExtArgs> | null
    /**
     * Filter, which MemberCheckIn to fetch.
     */
    where?: MemberCheckInWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberCheckIns to fetch.
     */
    orderBy?: MemberCheckInOrderByWithRelationInput | MemberCheckInOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberCheckIns.
     */
    cursor?: MemberCheckInWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberCheckIns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberCheckIns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberCheckIns.
     */
    distinct?: MemberCheckInScalarFieldEnum | MemberCheckInScalarFieldEnum[]
  }

  /**
   * MemberCheckIn findFirstOrThrow
   */
  export type MemberCheckInFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCheckIn
     */
    select?: MemberCheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberCheckIn
     */
    omit?: MemberCheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberCheckInInclude<ExtArgs> | null
    /**
     * Filter, which MemberCheckIn to fetch.
     */
    where?: MemberCheckInWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberCheckIns to fetch.
     */
    orderBy?: MemberCheckInOrderByWithRelationInput | MemberCheckInOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberCheckIns.
     */
    cursor?: MemberCheckInWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberCheckIns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberCheckIns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberCheckIns.
     */
    distinct?: MemberCheckInScalarFieldEnum | MemberCheckInScalarFieldEnum[]
  }

  /**
   * MemberCheckIn findMany
   */
  export type MemberCheckInFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCheckIn
     */
    select?: MemberCheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberCheckIn
     */
    omit?: MemberCheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberCheckInInclude<ExtArgs> | null
    /**
     * Filter, which MemberCheckIns to fetch.
     */
    where?: MemberCheckInWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberCheckIns to fetch.
     */
    orderBy?: MemberCheckInOrderByWithRelationInput | MemberCheckInOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MemberCheckIns.
     */
    cursor?: MemberCheckInWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberCheckIns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberCheckIns.
     */
    skip?: number
    distinct?: MemberCheckInScalarFieldEnum | MemberCheckInScalarFieldEnum[]
  }

  /**
   * MemberCheckIn create
   */
  export type MemberCheckInCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCheckIn
     */
    select?: MemberCheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberCheckIn
     */
    omit?: MemberCheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberCheckInInclude<ExtArgs> | null
    /**
     * The data needed to create a MemberCheckIn.
     */
    data: XOR<MemberCheckInCreateInput, MemberCheckInUncheckedCreateInput>
  }

  /**
   * MemberCheckIn createMany
   */
  export type MemberCheckInCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MemberCheckIns.
     */
    data: MemberCheckInCreateManyInput | MemberCheckInCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MemberCheckIn createManyAndReturn
   */
  export type MemberCheckInCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCheckIn
     */
    select?: MemberCheckInSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MemberCheckIn
     */
    omit?: MemberCheckInOmit<ExtArgs> | null
    /**
     * The data used to create many MemberCheckIns.
     */
    data: MemberCheckInCreateManyInput | MemberCheckInCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberCheckInIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MemberCheckIn update
   */
  export type MemberCheckInUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCheckIn
     */
    select?: MemberCheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberCheckIn
     */
    omit?: MemberCheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberCheckInInclude<ExtArgs> | null
    /**
     * The data needed to update a MemberCheckIn.
     */
    data: XOR<MemberCheckInUpdateInput, MemberCheckInUncheckedUpdateInput>
    /**
     * Choose, which MemberCheckIn to update.
     */
    where: MemberCheckInWhereUniqueInput
  }

  /**
   * MemberCheckIn updateMany
   */
  export type MemberCheckInUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MemberCheckIns.
     */
    data: XOR<MemberCheckInUpdateManyMutationInput, MemberCheckInUncheckedUpdateManyInput>
    /**
     * Filter which MemberCheckIns to update
     */
    where?: MemberCheckInWhereInput
    /**
     * Limit how many MemberCheckIns to update.
     */
    limit?: number
  }

  /**
   * MemberCheckIn updateManyAndReturn
   */
  export type MemberCheckInUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCheckIn
     */
    select?: MemberCheckInSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MemberCheckIn
     */
    omit?: MemberCheckInOmit<ExtArgs> | null
    /**
     * The data used to update MemberCheckIns.
     */
    data: XOR<MemberCheckInUpdateManyMutationInput, MemberCheckInUncheckedUpdateManyInput>
    /**
     * Filter which MemberCheckIns to update
     */
    where?: MemberCheckInWhereInput
    /**
     * Limit how many MemberCheckIns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberCheckInIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MemberCheckIn upsert
   */
  export type MemberCheckInUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCheckIn
     */
    select?: MemberCheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberCheckIn
     */
    omit?: MemberCheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberCheckInInclude<ExtArgs> | null
    /**
     * The filter to search for the MemberCheckIn to update in case it exists.
     */
    where: MemberCheckInWhereUniqueInput
    /**
     * In case the MemberCheckIn found by the `where` argument doesn't exist, create a new MemberCheckIn with this data.
     */
    create: XOR<MemberCheckInCreateInput, MemberCheckInUncheckedCreateInput>
    /**
     * In case the MemberCheckIn was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberCheckInUpdateInput, MemberCheckInUncheckedUpdateInput>
  }

  /**
   * MemberCheckIn delete
   */
  export type MemberCheckInDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCheckIn
     */
    select?: MemberCheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberCheckIn
     */
    omit?: MemberCheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberCheckInInclude<ExtArgs> | null
    /**
     * Filter which MemberCheckIn to delete.
     */
    where: MemberCheckInWhereUniqueInput
  }

  /**
   * MemberCheckIn deleteMany
   */
  export type MemberCheckInDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberCheckIns to delete
     */
    where?: MemberCheckInWhereInput
    /**
     * Limit how many MemberCheckIns to delete.
     */
    limit?: number
  }

  /**
   * MemberCheckIn without action
   */
  export type MemberCheckInDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCheckIn
     */
    select?: MemberCheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberCheckIn
     */
    omit?: MemberCheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberCheckInInclude<ExtArgs> | null
  }


  /**
   * Model MemberAttendance
   */

  export type AggregateMemberAttendance = {
    _count: MemberAttendanceCountAggregateOutputType | null
    _avg: MemberAttendanceAvgAggregateOutputType | null
    _sum: MemberAttendanceSumAggregateOutputType | null
    _min: MemberAttendanceMinAggregateOutputType | null
    _max: MemberAttendanceMaxAggregateOutputType | null
  }

  export type MemberAttendanceAvgAggregateOutputType = {
    duration: number | null
  }

  export type MemberAttendanceSumAggregateOutputType = {
    duration: number | null
  }

  export type MemberAttendanceMinAggregateOutputType = {
    id: string | null
    memberId: string | null
    date: Date | null
    timeIn: Date | null
    timeOut: Date | null
    duration: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberAttendanceMaxAggregateOutputType = {
    id: string | null
    memberId: string | null
    date: Date | null
    timeIn: Date | null
    timeOut: Date | null
    duration: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberAttendanceCountAggregateOutputType = {
    id: number
    memberId: number
    date: number
    timeIn: number
    timeOut: number
    duration: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MemberAttendanceAvgAggregateInputType = {
    duration?: true
  }

  export type MemberAttendanceSumAggregateInputType = {
    duration?: true
  }

  export type MemberAttendanceMinAggregateInputType = {
    id?: true
    memberId?: true
    date?: true
    timeIn?: true
    timeOut?: true
    duration?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberAttendanceMaxAggregateInputType = {
    id?: true
    memberId?: true
    date?: true
    timeIn?: true
    timeOut?: true
    duration?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberAttendanceCountAggregateInputType = {
    id?: true
    memberId?: true
    date?: true
    timeIn?: true
    timeOut?: true
    duration?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MemberAttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberAttendance to aggregate.
     */
    where?: MemberAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberAttendances to fetch.
     */
    orderBy?: MemberAttendanceOrderByWithRelationInput | MemberAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MemberAttendances
    **/
    _count?: true | MemberAttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MemberAttendanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MemberAttendanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberAttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberAttendanceMaxAggregateInputType
  }

  export type GetMemberAttendanceAggregateType<T extends MemberAttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateMemberAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMemberAttendance[P]>
      : GetScalarType<T[P], AggregateMemberAttendance[P]>
  }




  export type MemberAttendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberAttendanceWhereInput
    orderBy?: MemberAttendanceOrderByWithAggregationInput | MemberAttendanceOrderByWithAggregationInput[]
    by: MemberAttendanceScalarFieldEnum[] | MemberAttendanceScalarFieldEnum
    having?: MemberAttendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberAttendanceCountAggregateInputType | true
    _avg?: MemberAttendanceAvgAggregateInputType
    _sum?: MemberAttendanceSumAggregateInputType
    _min?: MemberAttendanceMinAggregateInputType
    _max?: MemberAttendanceMaxAggregateInputType
  }

  export type MemberAttendanceGroupByOutputType = {
    id: string
    memberId: string
    date: Date
    timeIn: Date
    timeOut: Date | null
    duration: number | null
    createdAt: Date
    updatedAt: Date
    _count: MemberAttendanceCountAggregateOutputType | null
    _avg: MemberAttendanceAvgAggregateOutputType | null
    _sum: MemberAttendanceSumAggregateOutputType | null
    _min: MemberAttendanceMinAggregateOutputType | null
    _max: MemberAttendanceMaxAggregateOutputType | null
  }

  type GetMemberAttendanceGroupByPayload<T extends MemberAttendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberAttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberAttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberAttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], MemberAttendanceGroupByOutputType[P]>
        }
      >
    >


  export type MemberAttendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    date?: boolean
    timeIn?: boolean
    timeOut?: boolean
    duration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["memberAttendance"]>

  export type MemberAttendanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    date?: boolean
    timeIn?: boolean
    timeOut?: boolean
    duration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["memberAttendance"]>

  export type MemberAttendanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    date?: boolean
    timeIn?: boolean
    timeOut?: boolean
    duration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["memberAttendance"]>

  export type MemberAttendanceSelectScalar = {
    id?: boolean
    memberId?: boolean
    date?: boolean
    timeIn?: boolean
    timeOut?: boolean
    duration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MemberAttendanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "memberId" | "date" | "timeIn" | "timeOut" | "duration" | "createdAt" | "updatedAt", ExtArgs["result"]["memberAttendance"]>
  export type MemberAttendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type MemberAttendanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type MemberAttendanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }

  export type $MemberAttendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MemberAttendance"
    objects: {
      member: Prisma.$MemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      memberId: string
      date: Date
      timeIn: Date
      timeOut: Date | null
      duration: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["memberAttendance"]>
    composites: {}
  }

  type MemberAttendanceGetPayload<S extends boolean | null | undefined | MemberAttendanceDefaultArgs> = $Result.GetResult<Prisma.$MemberAttendancePayload, S>

  type MemberAttendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MemberAttendanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MemberAttendanceCountAggregateInputType | true
    }

  export interface MemberAttendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MemberAttendance'], meta: { name: 'MemberAttendance' } }
    /**
     * Find zero or one MemberAttendance that matches the filter.
     * @param {MemberAttendanceFindUniqueArgs} args - Arguments to find a MemberAttendance
     * @example
     * // Get one MemberAttendance
     * const memberAttendance = await prisma.memberAttendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MemberAttendanceFindUniqueArgs>(args: SelectSubset<T, MemberAttendanceFindUniqueArgs<ExtArgs>>): Prisma__MemberAttendanceClient<$Result.GetResult<Prisma.$MemberAttendancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MemberAttendance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MemberAttendanceFindUniqueOrThrowArgs} args - Arguments to find a MemberAttendance
     * @example
     * // Get one MemberAttendance
     * const memberAttendance = await prisma.memberAttendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MemberAttendanceFindUniqueOrThrowArgs>(args: SelectSubset<T, MemberAttendanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MemberAttendanceClient<$Result.GetResult<Prisma.$MemberAttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MemberAttendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAttendanceFindFirstArgs} args - Arguments to find a MemberAttendance
     * @example
     * // Get one MemberAttendance
     * const memberAttendance = await prisma.memberAttendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MemberAttendanceFindFirstArgs>(args?: SelectSubset<T, MemberAttendanceFindFirstArgs<ExtArgs>>): Prisma__MemberAttendanceClient<$Result.GetResult<Prisma.$MemberAttendancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MemberAttendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAttendanceFindFirstOrThrowArgs} args - Arguments to find a MemberAttendance
     * @example
     * // Get one MemberAttendance
     * const memberAttendance = await prisma.memberAttendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MemberAttendanceFindFirstOrThrowArgs>(args?: SelectSubset<T, MemberAttendanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__MemberAttendanceClient<$Result.GetResult<Prisma.$MemberAttendancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MemberAttendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAttendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MemberAttendances
     * const memberAttendances = await prisma.memberAttendance.findMany()
     * 
     * // Get first 10 MemberAttendances
     * const memberAttendances = await prisma.memberAttendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberAttendanceWithIdOnly = await prisma.memberAttendance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MemberAttendanceFindManyArgs>(args?: SelectSubset<T, MemberAttendanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberAttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MemberAttendance.
     * @param {MemberAttendanceCreateArgs} args - Arguments to create a MemberAttendance.
     * @example
     * // Create one MemberAttendance
     * const MemberAttendance = await prisma.memberAttendance.create({
     *   data: {
     *     // ... data to create a MemberAttendance
     *   }
     * })
     * 
     */
    create<T extends MemberAttendanceCreateArgs>(args: SelectSubset<T, MemberAttendanceCreateArgs<ExtArgs>>): Prisma__MemberAttendanceClient<$Result.GetResult<Prisma.$MemberAttendancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MemberAttendances.
     * @param {MemberAttendanceCreateManyArgs} args - Arguments to create many MemberAttendances.
     * @example
     * // Create many MemberAttendances
     * const memberAttendance = await prisma.memberAttendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MemberAttendanceCreateManyArgs>(args?: SelectSubset<T, MemberAttendanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MemberAttendances and returns the data saved in the database.
     * @param {MemberAttendanceCreateManyAndReturnArgs} args - Arguments to create many MemberAttendances.
     * @example
     * // Create many MemberAttendances
     * const memberAttendance = await prisma.memberAttendance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MemberAttendances and only return the `id`
     * const memberAttendanceWithIdOnly = await prisma.memberAttendance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MemberAttendanceCreateManyAndReturnArgs>(args?: SelectSubset<T, MemberAttendanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberAttendancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MemberAttendance.
     * @param {MemberAttendanceDeleteArgs} args - Arguments to delete one MemberAttendance.
     * @example
     * // Delete one MemberAttendance
     * const MemberAttendance = await prisma.memberAttendance.delete({
     *   where: {
     *     // ... filter to delete one MemberAttendance
     *   }
     * })
     * 
     */
    delete<T extends MemberAttendanceDeleteArgs>(args: SelectSubset<T, MemberAttendanceDeleteArgs<ExtArgs>>): Prisma__MemberAttendanceClient<$Result.GetResult<Prisma.$MemberAttendancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MemberAttendance.
     * @param {MemberAttendanceUpdateArgs} args - Arguments to update one MemberAttendance.
     * @example
     * // Update one MemberAttendance
     * const memberAttendance = await prisma.memberAttendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MemberAttendanceUpdateArgs>(args: SelectSubset<T, MemberAttendanceUpdateArgs<ExtArgs>>): Prisma__MemberAttendanceClient<$Result.GetResult<Prisma.$MemberAttendancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MemberAttendances.
     * @param {MemberAttendanceDeleteManyArgs} args - Arguments to filter MemberAttendances to delete.
     * @example
     * // Delete a few MemberAttendances
     * const { count } = await prisma.memberAttendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MemberAttendanceDeleteManyArgs>(args?: SelectSubset<T, MemberAttendanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberAttendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MemberAttendances
     * const memberAttendance = await prisma.memberAttendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MemberAttendanceUpdateManyArgs>(args: SelectSubset<T, MemberAttendanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberAttendances and returns the data updated in the database.
     * @param {MemberAttendanceUpdateManyAndReturnArgs} args - Arguments to update many MemberAttendances.
     * @example
     * // Update many MemberAttendances
     * const memberAttendance = await prisma.memberAttendance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MemberAttendances and only return the `id`
     * const memberAttendanceWithIdOnly = await prisma.memberAttendance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MemberAttendanceUpdateManyAndReturnArgs>(args: SelectSubset<T, MemberAttendanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberAttendancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MemberAttendance.
     * @param {MemberAttendanceUpsertArgs} args - Arguments to update or create a MemberAttendance.
     * @example
     * // Update or create a MemberAttendance
     * const memberAttendance = await prisma.memberAttendance.upsert({
     *   create: {
     *     // ... data to create a MemberAttendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MemberAttendance we want to update
     *   }
     * })
     */
    upsert<T extends MemberAttendanceUpsertArgs>(args: SelectSubset<T, MemberAttendanceUpsertArgs<ExtArgs>>): Prisma__MemberAttendanceClient<$Result.GetResult<Prisma.$MemberAttendancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MemberAttendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAttendanceCountArgs} args - Arguments to filter MemberAttendances to count.
     * @example
     * // Count the number of MemberAttendances
     * const count = await prisma.memberAttendance.count({
     *   where: {
     *     // ... the filter for the MemberAttendances we want to count
     *   }
     * })
    **/
    count<T extends MemberAttendanceCountArgs>(
      args?: Subset<T, MemberAttendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberAttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MemberAttendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberAttendanceAggregateArgs>(args: Subset<T, MemberAttendanceAggregateArgs>): Prisma.PrismaPromise<GetMemberAttendanceAggregateType<T>>

    /**
     * Group by MemberAttendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberAttendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberAttendanceGroupByArgs['orderBy'] }
        : { orderBy?: MemberAttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberAttendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MemberAttendance model
   */
  readonly fields: MemberAttendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MemberAttendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberAttendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MemberAttendance model
   */
  interface MemberAttendanceFieldRefs {
    readonly id: FieldRef<"MemberAttendance", 'String'>
    readonly memberId: FieldRef<"MemberAttendance", 'String'>
    readonly date: FieldRef<"MemberAttendance", 'DateTime'>
    readonly timeIn: FieldRef<"MemberAttendance", 'DateTime'>
    readonly timeOut: FieldRef<"MemberAttendance", 'DateTime'>
    readonly duration: FieldRef<"MemberAttendance", 'Int'>
    readonly createdAt: FieldRef<"MemberAttendance", 'DateTime'>
    readonly updatedAt: FieldRef<"MemberAttendance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MemberAttendance findUnique
   */
  export type MemberAttendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberAttendance
     */
    select?: MemberAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberAttendance
     */
    omit?: MemberAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which MemberAttendance to fetch.
     */
    where: MemberAttendanceWhereUniqueInput
  }

  /**
   * MemberAttendance findUniqueOrThrow
   */
  export type MemberAttendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberAttendance
     */
    select?: MemberAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberAttendance
     */
    omit?: MemberAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which MemberAttendance to fetch.
     */
    where: MemberAttendanceWhereUniqueInput
  }

  /**
   * MemberAttendance findFirst
   */
  export type MemberAttendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberAttendance
     */
    select?: MemberAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberAttendance
     */
    omit?: MemberAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which MemberAttendance to fetch.
     */
    where?: MemberAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberAttendances to fetch.
     */
    orderBy?: MemberAttendanceOrderByWithRelationInput | MemberAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberAttendances.
     */
    cursor?: MemberAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberAttendances.
     */
    distinct?: MemberAttendanceScalarFieldEnum | MemberAttendanceScalarFieldEnum[]
  }

  /**
   * MemberAttendance findFirstOrThrow
   */
  export type MemberAttendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberAttendance
     */
    select?: MemberAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberAttendance
     */
    omit?: MemberAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which MemberAttendance to fetch.
     */
    where?: MemberAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberAttendances to fetch.
     */
    orderBy?: MemberAttendanceOrderByWithRelationInput | MemberAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberAttendances.
     */
    cursor?: MemberAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberAttendances.
     */
    distinct?: MemberAttendanceScalarFieldEnum | MemberAttendanceScalarFieldEnum[]
  }

  /**
   * MemberAttendance findMany
   */
  export type MemberAttendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberAttendance
     */
    select?: MemberAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberAttendance
     */
    omit?: MemberAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which MemberAttendances to fetch.
     */
    where?: MemberAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberAttendances to fetch.
     */
    orderBy?: MemberAttendanceOrderByWithRelationInput | MemberAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MemberAttendances.
     */
    cursor?: MemberAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberAttendances.
     */
    skip?: number
    distinct?: MemberAttendanceScalarFieldEnum | MemberAttendanceScalarFieldEnum[]
  }

  /**
   * MemberAttendance create
   */
  export type MemberAttendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberAttendance
     */
    select?: MemberAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberAttendance
     */
    omit?: MemberAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberAttendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a MemberAttendance.
     */
    data: XOR<MemberAttendanceCreateInput, MemberAttendanceUncheckedCreateInput>
  }

  /**
   * MemberAttendance createMany
   */
  export type MemberAttendanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MemberAttendances.
     */
    data: MemberAttendanceCreateManyInput | MemberAttendanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MemberAttendance createManyAndReturn
   */
  export type MemberAttendanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberAttendance
     */
    select?: MemberAttendanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MemberAttendance
     */
    omit?: MemberAttendanceOmit<ExtArgs> | null
    /**
     * The data used to create many MemberAttendances.
     */
    data: MemberAttendanceCreateManyInput | MemberAttendanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberAttendanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MemberAttendance update
   */
  export type MemberAttendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberAttendance
     */
    select?: MemberAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberAttendance
     */
    omit?: MemberAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberAttendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a MemberAttendance.
     */
    data: XOR<MemberAttendanceUpdateInput, MemberAttendanceUncheckedUpdateInput>
    /**
     * Choose, which MemberAttendance to update.
     */
    where: MemberAttendanceWhereUniqueInput
  }

  /**
   * MemberAttendance updateMany
   */
  export type MemberAttendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MemberAttendances.
     */
    data: XOR<MemberAttendanceUpdateManyMutationInput, MemberAttendanceUncheckedUpdateManyInput>
    /**
     * Filter which MemberAttendances to update
     */
    where?: MemberAttendanceWhereInput
    /**
     * Limit how many MemberAttendances to update.
     */
    limit?: number
  }

  /**
   * MemberAttendance updateManyAndReturn
   */
  export type MemberAttendanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberAttendance
     */
    select?: MemberAttendanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MemberAttendance
     */
    omit?: MemberAttendanceOmit<ExtArgs> | null
    /**
     * The data used to update MemberAttendances.
     */
    data: XOR<MemberAttendanceUpdateManyMutationInput, MemberAttendanceUncheckedUpdateManyInput>
    /**
     * Filter which MemberAttendances to update
     */
    where?: MemberAttendanceWhereInput
    /**
     * Limit how many MemberAttendances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberAttendanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MemberAttendance upsert
   */
  export type MemberAttendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberAttendance
     */
    select?: MemberAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberAttendance
     */
    omit?: MemberAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberAttendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the MemberAttendance to update in case it exists.
     */
    where: MemberAttendanceWhereUniqueInput
    /**
     * In case the MemberAttendance found by the `where` argument doesn't exist, create a new MemberAttendance with this data.
     */
    create: XOR<MemberAttendanceCreateInput, MemberAttendanceUncheckedCreateInput>
    /**
     * In case the MemberAttendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberAttendanceUpdateInput, MemberAttendanceUncheckedUpdateInput>
  }

  /**
   * MemberAttendance delete
   */
  export type MemberAttendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberAttendance
     */
    select?: MemberAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberAttendance
     */
    omit?: MemberAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberAttendanceInclude<ExtArgs> | null
    /**
     * Filter which MemberAttendance to delete.
     */
    where: MemberAttendanceWhereUniqueInput
  }

  /**
   * MemberAttendance deleteMany
   */
  export type MemberAttendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberAttendances to delete
     */
    where?: MemberAttendanceWhereInput
    /**
     * Limit how many MemberAttendances to delete.
     */
    limit?: number
  }

  /**
   * MemberAttendance without action
   */
  export type MemberAttendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberAttendance
     */
    select?: MemberAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberAttendance
     */
    omit?: MemberAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberAttendanceInclude<ExtArgs> | null
  }


  /**
   * Model MemberFitnessGoal
   */

  export type AggregateMemberFitnessGoal = {
    _count: MemberFitnessGoalCountAggregateOutputType | null
    _avg: MemberFitnessGoalAvgAggregateOutputType | null
    _sum: MemberFitnessGoalSumAggregateOutputType | null
    _min: MemberFitnessGoalMinAggregateOutputType | null
    _max: MemberFitnessGoalMaxAggregateOutputType | null
  }

  export type MemberFitnessGoalAvgAggregateOutputType = {
    targetValue: number | null
    currentValue: number | null
  }

  export type MemberFitnessGoalSumAggregateOutputType = {
    targetValue: number | null
    currentValue: number | null
  }

  export type MemberFitnessGoalMinAggregateOutputType = {
    id: string | null
    memberId: string | null
    goalType: string | null
    targetValue: number | null
    currentValue: number | null
    unit: string | null
    targetDate: Date | null
    isCompleted: boolean | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberFitnessGoalMaxAggregateOutputType = {
    id: string | null
    memberId: string | null
    goalType: string | null
    targetValue: number | null
    currentValue: number | null
    unit: string | null
    targetDate: Date | null
    isCompleted: boolean | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberFitnessGoalCountAggregateOutputType = {
    id: number
    memberId: number
    goalType: number
    targetValue: number
    currentValue: number
    unit: number
    targetDate: number
    isCompleted: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MemberFitnessGoalAvgAggregateInputType = {
    targetValue?: true
    currentValue?: true
  }

  export type MemberFitnessGoalSumAggregateInputType = {
    targetValue?: true
    currentValue?: true
  }

  export type MemberFitnessGoalMinAggregateInputType = {
    id?: true
    memberId?: true
    goalType?: true
    targetValue?: true
    currentValue?: true
    unit?: true
    targetDate?: true
    isCompleted?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberFitnessGoalMaxAggregateInputType = {
    id?: true
    memberId?: true
    goalType?: true
    targetValue?: true
    currentValue?: true
    unit?: true
    targetDate?: true
    isCompleted?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberFitnessGoalCountAggregateInputType = {
    id?: true
    memberId?: true
    goalType?: true
    targetValue?: true
    currentValue?: true
    unit?: true
    targetDate?: true
    isCompleted?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MemberFitnessGoalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberFitnessGoal to aggregate.
     */
    where?: MemberFitnessGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberFitnessGoals to fetch.
     */
    orderBy?: MemberFitnessGoalOrderByWithRelationInput | MemberFitnessGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberFitnessGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberFitnessGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberFitnessGoals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MemberFitnessGoals
    **/
    _count?: true | MemberFitnessGoalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MemberFitnessGoalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MemberFitnessGoalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberFitnessGoalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberFitnessGoalMaxAggregateInputType
  }

  export type GetMemberFitnessGoalAggregateType<T extends MemberFitnessGoalAggregateArgs> = {
        [P in keyof T & keyof AggregateMemberFitnessGoal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMemberFitnessGoal[P]>
      : GetScalarType<T[P], AggregateMemberFitnessGoal[P]>
  }




  export type MemberFitnessGoalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberFitnessGoalWhereInput
    orderBy?: MemberFitnessGoalOrderByWithAggregationInput | MemberFitnessGoalOrderByWithAggregationInput[]
    by: MemberFitnessGoalScalarFieldEnum[] | MemberFitnessGoalScalarFieldEnum
    having?: MemberFitnessGoalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberFitnessGoalCountAggregateInputType | true
    _avg?: MemberFitnessGoalAvgAggregateInputType
    _sum?: MemberFitnessGoalSumAggregateInputType
    _min?: MemberFitnessGoalMinAggregateInputType
    _max?: MemberFitnessGoalMaxAggregateInputType
  }

  export type MemberFitnessGoalGroupByOutputType = {
    id: string
    memberId: string
    goalType: string
    targetValue: number
    currentValue: number
    unit: string
    targetDate: Date | null
    isCompleted: boolean
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: MemberFitnessGoalCountAggregateOutputType | null
    _avg: MemberFitnessGoalAvgAggregateOutputType | null
    _sum: MemberFitnessGoalSumAggregateOutputType | null
    _min: MemberFitnessGoalMinAggregateOutputType | null
    _max: MemberFitnessGoalMaxAggregateOutputType | null
  }

  type GetMemberFitnessGoalGroupByPayload<T extends MemberFitnessGoalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberFitnessGoalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberFitnessGoalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberFitnessGoalGroupByOutputType[P]>
            : GetScalarType<T[P], MemberFitnessGoalGroupByOutputType[P]>
        }
      >
    >


  export type MemberFitnessGoalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    goalType?: boolean
    targetValue?: boolean
    currentValue?: boolean
    unit?: boolean
    targetDate?: boolean
    isCompleted?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["memberFitnessGoal"]>

  export type MemberFitnessGoalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    goalType?: boolean
    targetValue?: boolean
    currentValue?: boolean
    unit?: boolean
    targetDate?: boolean
    isCompleted?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["memberFitnessGoal"]>

  export type MemberFitnessGoalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    goalType?: boolean
    targetValue?: boolean
    currentValue?: boolean
    unit?: boolean
    targetDate?: boolean
    isCompleted?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["memberFitnessGoal"]>

  export type MemberFitnessGoalSelectScalar = {
    id?: boolean
    memberId?: boolean
    goalType?: boolean
    targetValue?: boolean
    currentValue?: boolean
    unit?: boolean
    targetDate?: boolean
    isCompleted?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MemberFitnessGoalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "memberId" | "goalType" | "targetValue" | "currentValue" | "unit" | "targetDate" | "isCompleted" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["memberFitnessGoal"]>
  export type MemberFitnessGoalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type MemberFitnessGoalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type MemberFitnessGoalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }

  export type $MemberFitnessGoalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MemberFitnessGoal"
    objects: {
      member: Prisma.$MemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      memberId: string
      goalType: string
      targetValue: number
      currentValue: number
      unit: string
      targetDate: Date | null
      isCompleted: boolean
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["memberFitnessGoal"]>
    composites: {}
  }

  type MemberFitnessGoalGetPayload<S extends boolean | null | undefined | MemberFitnessGoalDefaultArgs> = $Result.GetResult<Prisma.$MemberFitnessGoalPayload, S>

  type MemberFitnessGoalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MemberFitnessGoalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MemberFitnessGoalCountAggregateInputType | true
    }

  export interface MemberFitnessGoalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MemberFitnessGoal'], meta: { name: 'MemberFitnessGoal' } }
    /**
     * Find zero or one MemberFitnessGoal that matches the filter.
     * @param {MemberFitnessGoalFindUniqueArgs} args - Arguments to find a MemberFitnessGoal
     * @example
     * // Get one MemberFitnessGoal
     * const memberFitnessGoal = await prisma.memberFitnessGoal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MemberFitnessGoalFindUniqueArgs>(args: SelectSubset<T, MemberFitnessGoalFindUniqueArgs<ExtArgs>>): Prisma__MemberFitnessGoalClient<$Result.GetResult<Prisma.$MemberFitnessGoalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MemberFitnessGoal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MemberFitnessGoalFindUniqueOrThrowArgs} args - Arguments to find a MemberFitnessGoal
     * @example
     * // Get one MemberFitnessGoal
     * const memberFitnessGoal = await prisma.memberFitnessGoal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MemberFitnessGoalFindUniqueOrThrowArgs>(args: SelectSubset<T, MemberFitnessGoalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MemberFitnessGoalClient<$Result.GetResult<Prisma.$MemberFitnessGoalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MemberFitnessGoal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFitnessGoalFindFirstArgs} args - Arguments to find a MemberFitnessGoal
     * @example
     * // Get one MemberFitnessGoal
     * const memberFitnessGoal = await prisma.memberFitnessGoal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MemberFitnessGoalFindFirstArgs>(args?: SelectSubset<T, MemberFitnessGoalFindFirstArgs<ExtArgs>>): Prisma__MemberFitnessGoalClient<$Result.GetResult<Prisma.$MemberFitnessGoalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MemberFitnessGoal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFitnessGoalFindFirstOrThrowArgs} args - Arguments to find a MemberFitnessGoal
     * @example
     * // Get one MemberFitnessGoal
     * const memberFitnessGoal = await prisma.memberFitnessGoal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MemberFitnessGoalFindFirstOrThrowArgs>(args?: SelectSubset<T, MemberFitnessGoalFindFirstOrThrowArgs<ExtArgs>>): Prisma__MemberFitnessGoalClient<$Result.GetResult<Prisma.$MemberFitnessGoalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MemberFitnessGoals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFitnessGoalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MemberFitnessGoals
     * const memberFitnessGoals = await prisma.memberFitnessGoal.findMany()
     * 
     * // Get first 10 MemberFitnessGoals
     * const memberFitnessGoals = await prisma.memberFitnessGoal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberFitnessGoalWithIdOnly = await prisma.memberFitnessGoal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MemberFitnessGoalFindManyArgs>(args?: SelectSubset<T, MemberFitnessGoalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberFitnessGoalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MemberFitnessGoal.
     * @param {MemberFitnessGoalCreateArgs} args - Arguments to create a MemberFitnessGoal.
     * @example
     * // Create one MemberFitnessGoal
     * const MemberFitnessGoal = await prisma.memberFitnessGoal.create({
     *   data: {
     *     // ... data to create a MemberFitnessGoal
     *   }
     * })
     * 
     */
    create<T extends MemberFitnessGoalCreateArgs>(args: SelectSubset<T, MemberFitnessGoalCreateArgs<ExtArgs>>): Prisma__MemberFitnessGoalClient<$Result.GetResult<Prisma.$MemberFitnessGoalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MemberFitnessGoals.
     * @param {MemberFitnessGoalCreateManyArgs} args - Arguments to create many MemberFitnessGoals.
     * @example
     * // Create many MemberFitnessGoals
     * const memberFitnessGoal = await prisma.memberFitnessGoal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MemberFitnessGoalCreateManyArgs>(args?: SelectSubset<T, MemberFitnessGoalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MemberFitnessGoals and returns the data saved in the database.
     * @param {MemberFitnessGoalCreateManyAndReturnArgs} args - Arguments to create many MemberFitnessGoals.
     * @example
     * // Create many MemberFitnessGoals
     * const memberFitnessGoal = await prisma.memberFitnessGoal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MemberFitnessGoals and only return the `id`
     * const memberFitnessGoalWithIdOnly = await prisma.memberFitnessGoal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MemberFitnessGoalCreateManyAndReturnArgs>(args?: SelectSubset<T, MemberFitnessGoalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberFitnessGoalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MemberFitnessGoal.
     * @param {MemberFitnessGoalDeleteArgs} args - Arguments to delete one MemberFitnessGoal.
     * @example
     * // Delete one MemberFitnessGoal
     * const MemberFitnessGoal = await prisma.memberFitnessGoal.delete({
     *   where: {
     *     // ... filter to delete one MemberFitnessGoal
     *   }
     * })
     * 
     */
    delete<T extends MemberFitnessGoalDeleteArgs>(args: SelectSubset<T, MemberFitnessGoalDeleteArgs<ExtArgs>>): Prisma__MemberFitnessGoalClient<$Result.GetResult<Prisma.$MemberFitnessGoalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MemberFitnessGoal.
     * @param {MemberFitnessGoalUpdateArgs} args - Arguments to update one MemberFitnessGoal.
     * @example
     * // Update one MemberFitnessGoal
     * const memberFitnessGoal = await prisma.memberFitnessGoal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MemberFitnessGoalUpdateArgs>(args: SelectSubset<T, MemberFitnessGoalUpdateArgs<ExtArgs>>): Prisma__MemberFitnessGoalClient<$Result.GetResult<Prisma.$MemberFitnessGoalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MemberFitnessGoals.
     * @param {MemberFitnessGoalDeleteManyArgs} args - Arguments to filter MemberFitnessGoals to delete.
     * @example
     * // Delete a few MemberFitnessGoals
     * const { count } = await prisma.memberFitnessGoal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MemberFitnessGoalDeleteManyArgs>(args?: SelectSubset<T, MemberFitnessGoalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberFitnessGoals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFitnessGoalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MemberFitnessGoals
     * const memberFitnessGoal = await prisma.memberFitnessGoal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MemberFitnessGoalUpdateManyArgs>(args: SelectSubset<T, MemberFitnessGoalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberFitnessGoals and returns the data updated in the database.
     * @param {MemberFitnessGoalUpdateManyAndReturnArgs} args - Arguments to update many MemberFitnessGoals.
     * @example
     * // Update many MemberFitnessGoals
     * const memberFitnessGoal = await prisma.memberFitnessGoal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MemberFitnessGoals and only return the `id`
     * const memberFitnessGoalWithIdOnly = await prisma.memberFitnessGoal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MemberFitnessGoalUpdateManyAndReturnArgs>(args: SelectSubset<T, MemberFitnessGoalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberFitnessGoalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MemberFitnessGoal.
     * @param {MemberFitnessGoalUpsertArgs} args - Arguments to update or create a MemberFitnessGoal.
     * @example
     * // Update or create a MemberFitnessGoal
     * const memberFitnessGoal = await prisma.memberFitnessGoal.upsert({
     *   create: {
     *     // ... data to create a MemberFitnessGoal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MemberFitnessGoal we want to update
     *   }
     * })
     */
    upsert<T extends MemberFitnessGoalUpsertArgs>(args: SelectSubset<T, MemberFitnessGoalUpsertArgs<ExtArgs>>): Prisma__MemberFitnessGoalClient<$Result.GetResult<Prisma.$MemberFitnessGoalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MemberFitnessGoals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFitnessGoalCountArgs} args - Arguments to filter MemberFitnessGoals to count.
     * @example
     * // Count the number of MemberFitnessGoals
     * const count = await prisma.memberFitnessGoal.count({
     *   where: {
     *     // ... the filter for the MemberFitnessGoals we want to count
     *   }
     * })
    **/
    count<T extends MemberFitnessGoalCountArgs>(
      args?: Subset<T, MemberFitnessGoalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberFitnessGoalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MemberFitnessGoal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFitnessGoalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberFitnessGoalAggregateArgs>(args: Subset<T, MemberFitnessGoalAggregateArgs>): Prisma.PrismaPromise<GetMemberFitnessGoalAggregateType<T>>

    /**
     * Group by MemberFitnessGoal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFitnessGoalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberFitnessGoalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberFitnessGoalGroupByArgs['orderBy'] }
        : { orderBy?: MemberFitnessGoalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberFitnessGoalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberFitnessGoalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MemberFitnessGoal model
   */
  readonly fields: MemberFitnessGoalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MemberFitnessGoal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberFitnessGoalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MemberFitnessGoal model
   */
  interface MemberFitnessGoalFieldRefs {
    readonly id: FieldRef<"MemberFitnessGoal", 'String'>
    readonly memberId: FieldRef<"MemberFitnessGoal", 'String'>
    readonly goalType: FieldRef<"MemberFitnessGoal", 'String'>
    readonly targetValue: FieldRef<"MemberFitnessGoal", 'Float'>
    readonly currentValue: FieldRef<"MemberFitnessGoal", 'Float'>
    readonly unit: FieldRef<"MemberFitnessGoal", 'String'>
    readonly targetDate: FieldRef<"MemberFitnessGoal", 'DateTime'>
    readonly isCompleted: FieldRef<"MemberFitnessGoal", 'Boolean'>
    readonly notes: FieldRef<"MemberFitnessGoal", 'String'>
    readonly createdAt: FieldRef<"MemberFitnessGoal", 'DateTime'>
    readonly updatedAt: FieldRef<"MemberFitnessGoal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MemberFitnessGoal findUnique
   */
  export type MemberFitnessGoalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberFitnessGoal
     */
    select?: MemberFitnessGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberFitnessGoal
     */
    omit?: MemberFitnessGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberFitnessGoalInclude<ExtArgs> | null
    /**
     * Filter, which MemberFitnessGoal to fetch.
     */
    where: MemberFitnessGoalWhereUniqueInput
  }

  /**
   * MemberFitnessGoal findUniqueOrThrow
   */
  export type MemberFitnessGoalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberFitnessGoal
     */
    select?: MemberFitnessGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberFitnessGoal
     */
    omit?: MemberFitnessGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberFitnessGoalInclude<ExtArgs> | null
    /**
     * Filter, which MemberFitnessGoal to fetch.
     */
    where: MemberFitnessGoalWhereUniqueInput
  }

  /**
   * MemberFitnessGoal findFirst
   */
  export type MemberFitnessGoalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberFitnessGoal
     */
    select?: MemberFitnessGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberFitnessGoal
     */
    omit?: MemberFitnessGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberFitnessGoalInclude<ExtArgs> | null
    /**
     * Filter, which MemberFitnessGoal to fetch.
     */
    where?: MemberFitnessGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberFitnessGoals to fetch.
     */
    orderBy?: MemberFitnessGoalOrderByWithRelationInput | MemberFitnessGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberFitnessGoals.
     */
    cursor?: MemberFitnessGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberFitnessGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberFitnessGoals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberFitnessGoals.
     */
    distinct?: MemberFitnessGoalScalarFieldEnum | MemberFitnessGoalScalarFieldEnum[]
  }

  /**
   * MemberFitnessGoal findFirstOrThrow
   */
  export type MemberFitnessGoalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberFitnessGoal
     */
    select?: MemberFitnessGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberFitnessGoal
     */
    omit?: MemberFitnessGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberFitnessGoalInclude<ExtArgs> | null
    /**
     * Filter, which MemberFitnessGoal to fetch.
     */
    where?: MemberFitnessGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberFitnessGoals to fetch.
     */
    orderBy?: MemberFitnessGoalOrderByWithRelationInput | MemberFitnessGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberFitnessGoals.
     */
    cursor?: MemberFitnessGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberFitnessGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberFitnessGoals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberFitnessGoals.
     */
    distinct?: MemberFitnessGoalScalarFieldEnum | MemberFitnessGoalScalarFieldEnum[]
  }

  /**
   * MemberFitnessGoal findMany
   */
  export type MemberFitnessGoalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberFitnessGoal
     */
    select?: MemberFitnessGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberFitnessGoal
     */
    omit?: MemberFitnessGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberFitnessGoalInclude<ExtArgs> | null
    /**
     * Filter, which MemberFitnessGoals to fetch.
     */
    where?: MemberFitnessGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberFitnessGoals to fetch.
     */
    orderBy?: MemberFitnessGoalOrderByWithRelationInput | MemberFitnessGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MemberFitnessGoals.
     */
    cursor?: MemberFitnessGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberFitnessGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberFitnessGoals.
     */
    skip?: number
    distinct?: MemberFitnessGoalScalarFieldEnum | MemberFitnessGoalScalarFieldEnum[]
  }

  /**
   * MemberFitnessGoal create
   */
  export type MemberFitnessGoalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberFitnessGoal
     */
    select?: MemberFitnessGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberFitnessGoal
     */
    omit?: MemberFitnessGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberFitnessGoalInclude<ExtArgs> | null
    /**
     * The data needed to create a MemberFitnessGoal.
     */
    data: XOR<MemberFitnessGoalCreateInput, MemberFitnessGoalUncheckedCreateInput>
  }

  /**
   * MemberFitnessGoal createMany
   */
  export type MemberFitnessGoalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MemberFitnessGoals.
     */
    data: MemberFitnessGoalCreateManyInput | MemberFitnessGoalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MemberFitnessGoal createManyAndReturn
   */
  export type MemberFitnessGoalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberFitnessGoal
     */
    select?: MemberFitnessGoalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MemberFitnessGoal
     */
    omit?: MemberFitnessGoalOmit<ExtArgs> | null
    /**
     * The data used to create many MemberFitnessGoals.
     */
    data: MemberFitnessGoalCreateManyInput | MemberFitnessGoalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberFitnessGoalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MemberFitnessGoal update
   */
  export type MemberFitnessGoalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberFitnessGoal
     */
    select?: MemberFitnessGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberFitnessGoal
     */
    omit?: MemberFitnessGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberFitnessGoalInclude<ExtArgs> | null
    /**
     * The data needed to update a MemberFitnessGoal.
     */
    data: XOR<MemberFitnessGoalUpdateInput, MemberFitnessGoalUncheckedUpdateInput>
    /**
     * Choose, which MemberFitnessGoal to update.
     */
    where: MemberFitnessGoalWhereUniqueInput
  }

  /**
   * MemberFitnessGoal updateMany
   */
  export type MemberFitnessGoalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MemberFitnessGoals.
     */
    data: XOR<MemberFitnessGoalUpdateManyMutationInput, MemberFitnessGoalUncheckedUpdateManyInput>
    /**
     * Filter which MemberFitnessGoals to update
     */
    where?: MemberFitnessGoalWhereInput
    /**
     * Limit how many MemberFitnessGoals to update.
     */
    limit?: number
  }

  /**
   * MemberFitnessGoal updateManyAndReturn
   */
  export type MemberFitnessGoalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberFitnessGoal
     */
    select?: MemberFitnessGoalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MemberFitnessGoal
     */
    omit?: MemberFitnessGoalOmit<ExtArgs> | null
    /**
     * The data used to update MemberFitnessGoals.
     */
    data: XOR<MemberFitnessGoalUpdateManyMutationInput, MemberFitnessGoalUncheckedUpdateManyInput>
    /**
     * Filter which MemberFitnessGoals to update
     */
    where?: MemberFitnessGoalWhereInput
    /**
     * Limit how many MemberFitnessGoals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberFitnessGoalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MemberFitnessGoal upsert
   */
  export type MemberFitnessGoalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberFitnessGoal
     */
    select?: MemberFitnessGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberFitnessGoal
     */
    omit?: MemberFitnessGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberFitnessGoalInclude<ExtArgs> | null
    /**
     * The filter to search for the MemberFitnessGoal to update in case it exists.
     */
    where: MemberFitnessGoalWhereUniqueInput
    /**
     * In case the MemberFitnessGoal found by the `where` argument doesn't exist, create a new MemberFitnessGoal with this data.
     */
    create: XOR<MemberFitnessGoalCreateInput, MemberFitnessGoalUncheckedCreateInput>
    /**
     * In case the MemberFitnessGoal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberFitnessGoalUpdateInput, MemberFitnessGoalUncheckedUpdateInput>
  }

  /**
   * MemberFitnessGoal delete
   */
  export type MemberFitnessGoalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberFitnessGoal
     */
    select?: MemberFitnessGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberFitnessGoal
     */
    omit?: MemberFitnessGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberFitnessGoalInclude<ExtArgs> | null
    /**
     * Filter which MemberFitnessGoal to delete.
     */
    where: MemberFitnessGoalWhereUniqueInput
  }

  /**
   * MemberFitnessGoal deleteMany
   */
  export type MemberFitnessGoalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberFitnessGoals to delete
     */
    where?: MemberFitnessGoalWhereInput
    /**
     * Limit how many MemberFitnessGoals to delete.
     */
    limit?: number
  }

  /**
   * MemberFitnessGoal without action
   */
  export type MemberFitnessGoalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberFitnessGoal
     */
    select?: MemberFitnessGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberFitnessGoal
     */
    omit?: MemberFitnessGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberFitnessGoalInclude<ExtArgs> | null
  }


  /**
   * Model Address
   */

  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  export type AddressMinAggregateOutputType = {
    id: string | null
    memberId: string | null
    street: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    country: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddressMaxAggregateOutputType = {
    id: string | null
    memberId: string | null
    street: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    country: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddressCountAggregateOutputType = {
    id: number
    memberId: number
    street: number
    city: number
    state: number
    zipCode: number
    country: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AddressMinAggregateInputType = {
    id?: true
    memberId?: true
    street?: true
    city?: true
    state?: true
    zipCode?: true
    country?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddressMaxAggregateInputType = {
    id?: true
    memberId?: true
    street?: true
    city?: true
    state?: true
    zipCode?: true
    country?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddressCountAggregateInputType = {
    id?: true
    memberId?: true
    street?: true
    city?: true
    state?: true
    zipCode?: true
    country?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Address to aggregate.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    _count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }




  export type AddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithAggregationInput | AddressOrderByWithAggregationInput[]
    by: AddressScalarFieldEnum[] | AddressScalarFieldEnum
    having?: AddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCountAggregateInputType | true
    _min?: AddressMinAggregateInputType
    _max?: AddressMaxAggregateInputType
  }

  export type AddressGroupByOutputType = {
    id: string
    memberId: string
    street: string
    city: string
    state: string
    zipCode: string
    country: string
    createdAt: Date
    updatedAt: Date
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
        }
      >
    >


  export type AddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    street?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    street?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    street?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectScalar = {
    id?: boolean
    memberId?: boolean
    street?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "memberId" | "street" | "city" | "state" | "zipCode" | "country" | "createdAt" | "updatedAt", ExtArgs["result"]["address"]>
  export type AddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type AddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type AddressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }

  export type $AddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Address"
    objects: {
      member: Prisma.$MemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      memberId: string
      street: string
      city: string
      state: string
      zipCode: string
      country: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["address"]>
    composites: {}
  }

  type AddressGetPayload<S extends boolean | null | undefined | AddressDefaultArgs> = $Result.GetResult<Prisma.$AddressPayload, S>

  type AddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddressCountAggregateInputType | true
    }

  export interface AddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Address'], meta: { name: 'Address' } }
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddressFindUniqueArgs>(args: SelectSubset<T, AddressFindUniqueArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Address that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddressFindUniqueOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddressFindUniqueOrThrowArgs>(args: SelectSubset<T, AddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddressFindFirstArgs>(args?: SelectSubset<T, AddressFindFirstArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Address that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddressFindFirstOrThrowArgs>(args?: SelectSubset<T, AddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddressFindManyArgs>(args?: SelectSubset<T, AddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
     */
    create<T extends AddressCreateArgs>(args: SelectSubset<T, AddressCreateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Addresses.
     * @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddressCreateManyArgs>(args?: SelectSubset<T, AddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Addresses and returns the data saved in the database.
     * @param {AddressCreateManyAndReturnArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AddressCreateManyAndReturnArgs>(args?: SelectSubset<T, AddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
     */
    delete<T extends AddressDeleteArgs>(args: SelectSubset<T, AddressDeleteArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddressUpdateArgs>(args: SelectSubset<T, AddressUpdateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddressDeleteManyArgs>(args?: SelectSubset<T, AddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddressUpdateManyArgs>(args: SelectSubset<T, AddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses and returns the data updated in the database.
     * @param {AddressUpdateManyAndReturnArgs} args - Arguments to update many Addresses.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AddressUpdateManyAndReturnArgs>(args: SelectSubset<T, AddressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
     */
    upsert<T extends AddressUpsertArgs>(args: SelectSubset<T, AddressUpsertArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): Prisma.PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Address model
   */
  readonly fields: AddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Address model
   */
  interface AddressFieldRefs {
    readonly id: FieldRef<"Address", 'String'>
    readonly memberId: FieldRef<"Address", 'String'>
    readonly street: FieldRef<"Address", 'String'>
    readonly city: FieldRef<"Address", 'String'>
    readonly state: FieldRef<"Address", 'String'>
    readonly zipCode: FieldRef<"Address", 'String'>
    readonly country: FieldRef<"Address", 'String'>
    readonly createdAt: FieldRef<"Address", 'DateTime'>
    readonly updatedAt: FieldRef<"Address", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Address findUnique
   */
  export type AddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findUniqueOrThrow
   */
  export type AddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findFirst
   */
  export type AddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findFirstOrThrow
   */
  export type AddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findMany
   */
  export type AddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address create
   */
  export type AddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to create a Address.
     */
    data: XOR<AddressCreateInput, AddressUncheckedCreateInput>
  }

  /**
   * Address createMany
   */
  export type AddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Address createManyAndReturn
   */
  export type AddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Address update
   */
  export type AddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to update a Address.
     */
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
    /**
     * Choose, which Address to update.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
  }

  /**
   * Address updateManyAndReturn
   */
  export type AddressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Address upsert
   */
  export type AddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The filter to search for the Address to update in case it exists.
     */
    where: AddressWhereUniqueInput
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
     */
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
  }

  /**
   * Address delete
   */
  export type AddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter which Address to delete.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Addresses to delete
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to delete.
     */
    limit?: number
  }

  /**
   * Address without action
   */
  export type AddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
  }


  /**
   * Model EmergencyContact
   */

  export type AggregateEmergencyContact = {
    _count: EmergencyContactCountAggregateOutputType | null
    _min: EmergencyContactMinAggregateOutputType | null
    _max: EmergencyContactMaxAggregateOutputType | null
  }

  export type EmergencyContactMinAggregateOutputType = {
    id: string | null
    memberId: string | null
    name: string | null
    relationship: string | null
    phone: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmergencyContactMaxAggregateOutputType = {
    id: string | null
    memberId: string | null
    name: string | null
    relationship: string | null
    phone: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmergencyContactCountAggregateOutputType = {
    id: number
    memberId: number
    name: number
    relationship: number
    phone: number
    email: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmergencyContactMinAggregateInputType = {
    id?: true
    memberId?: true
    name?: true
    relationship?: true
    phone?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmergencyContactMaxAggregateInputType = {
    id?: true
    memberId?: true
    name?: true
    relationship?: true
    phone?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmergencyContactCountAggregateInputType = {
    id?: true
    memberId?: true
    name?: true
    relationship?: true
    phone?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmergencyContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmergencyContact to aggregate.
     */
    where?: EmergencyContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyContacts to fetch.
     */
    orderBy?: EmergencyContactOrderByWithRelationInput | EmergencyContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmergencyContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmergencyContacts
    **/
    _count?: true | EmergencyContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmergencyContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmergencyContactMaxAggregateInputType
  }

  export type GetEmergencyContactAggregateType<T extends EmergencyContactAggregateArgs> = {
        [P in keyof T & keyof AggregateEmergencyContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmergencyContact[P]>
      : GetScalarType<T[P], AggregateEmergencyContact[P]>
  }




  export type EmergencyContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmergencyContactWhereInput
    orderBy?: EmergencyContactOrderByWithAggregationInput | EmergencyContactOrderByWithAggregationInput[]
    by: EmergencyContactScalarFieldEnum[] | EmergencyContactScalarFieldEnum
    having?: EmergencyContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmergencyContactCountAggregateInputType | true
    _min?: EmergencyContactMinAggregateInputType
    _max?: EmergencyContactMaxAggregateInputType
  }

  export type EmergencyContactGroupByOutputType = {
    id: string
    memberId: string
    name: string
    relationship: string
    phone: string
    email: string | null
    createdAt: Date
    updatedAt: Date
    _count: EmergencyContactCountAggregateOutputType | null
    _min: EmergencyContactMinAggregateOutputType | null
    _max: EmergencyContactMaxAggregateOutputType | null
  }

  type GetEmergencyContactGroupByPayload<T extends EmergencyContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmergencyContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmergencyContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmergencyContactGroupByOutputType[P]>
            : GetScalarType<T[P], EmergencyContactGroupByOutputType[P]>
        }
      >
    >


  export type EmergencyContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    name?: boolean
    relationship?: boolean
    phone?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emergencyContact"]>

  export type EmergencyContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    name?: boolean
    relationship?: boolean
    phone?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emergencyContact"]>

  export type EmergencyContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    name?: boolean
    relationship?: boolean
    phone?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emergencyContact"]>

  export type EmergencyContactSelectScalar = {
    id?: boolean
    memberId?: boolean
    name?: boolean
    relationship?: boolean
    phone?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmergencyContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "memberId" | "name" | "relationship" | "phone" | "email" | "createdAt" | "updatedAt", ExtArgs["result"]["emergencyContact"]>
  export type EmergencyContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type EmergencyContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type EmergencyContactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }

  export type $EmergencyContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmergencyContact"
    objects: {
      member: Prisma.$MemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      memberId: string
      name: string
      relationship: string
      phone: string
      email: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emergencyContact"]>
    composites: {}
  }

  type EmergencyContactGetPayload<S extends boolean | null | undefined | EmergencyContactDefaultArgs> = $Result.GetResult<Prisma.$EmergencyContactPayload, S>

  type EmergencyContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmergencyContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmergencyContactCountAggregateInputType | true
    }

  export interface EmergencyContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmergencyContact'], meta: { name: 'EmergencyContact' } }
    /**
     * Find zero or one EmergencyContact that matches the filter.
     * @param {EmergencyContactFindUniqueArgs} args - Arguments to find a EmergencyContact
     * @example
     * // Get one EmergencyContact
     * const emergencyContact = await prisma.emergencyContact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmergencyContactFindUniqueArgs>(args: SelectSubset<T, EmergencyContactFindUniqueArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmergencyContact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmergencyContactFindUniqueOrThrowArgs} args - Arguments to find a EmergencyContact
     * @example
     * // Get one EmergencyContact
     * const emergencyContact = await prisma.emergencyContact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmergencyContactFindUniqueOrThrowArgs>(args: SelectSubset<T, EmergencyContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmergencyContact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyContactFindFirstArgs} args - Arguments to find a EmergencyContact
     * @example
     * // Get one EmergencyContact
     * const emergencyContact = await prisma.emergencyContact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmergencyContactFindFirstArgs>(args?: SelectSubset<T, EmergencyContactFindFirstArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmergencyContact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyContactFindFirstOrThrowArgs} args - Arguments to find a EmergencyContact
     * @example
     * // Get one EmergencyContact
     * const emergencyContact = await prisma.emergencyContact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmergencyContactFindFirstOrThrowArgs>(args?: SelectSubset<T, EmergencyContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmergencyContacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmergencyContacts
     * const emergencyContacts = await prisma.emergencyContact.findMany()
     * 
     * // Get first 10 EmergencyContacts
     * const emergencyContacts = await prisma.emergencyContact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emergencyContactWithIdOnly = await prisma.emergencyContact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmergencyContactFindManyArgs>(args?: SelectSubset<T, EmergencyContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmergencyContact.
     * @param {EmergencyContactCreateArgs} args - Arguments to create a EmergencyContact.
     * @example
     * // Create one EmergencyContact
     * const EmergencyContact = await prisma.emergencyContact.create({
     *   data: {
     *     // ... data to create a EmergencyContact
     *   }
     * })
     * 
     */
    create<T extends EmergencyContactCreateArgs>(args: SelectSubset<T, EmergencyContactCreateArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmergencyContacts.
     * @param {EmergencyContactCreateManyArgs} args - Arguments to create many EmergencyContacts.
     * @example
     * // Create many EmergencyContacts
     * const emergencyContact = await prisma.emergencyContact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmergencyContactCreateManyArgs>(args?: SelectSubset<T, EmergencyContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmergencyContacts and returns the data saved in the database.
     * @param {EmergencyContactCreateManyAndReturnArgs} args - Arguments to create many EmergencyContacts.
     * @example
     * // Create many EmergencyContacts
     * const emergencyContact = await prisma.emergencyContact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmergencyContacts and only return the `id`
     * const emergencyContactWithIdOnly = await prisma.emergencyContact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmergencyContactCreateManyAndReturnArgs>(args?: SelectSubset<T, EmergencyContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmergencyContact.
     * @param {EmergencyContactDeleteArgs} args - Arguments to delete one EmergencyContact.
     * @example
     * // Delete one EmergencyContact
     * const EmergencyContact = await prisma.emergencyContact.delete({
     *   where: {
     *     // ... filter to delete one EmergencyContact
     *   }
     * })
     * 
     */
    delete<T extends EmergencyContactDeleteArgs>(args: SelectSubset<T, EmergencyContactDeleteArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmergencyContact.
     * @param {EmergencyContactUpdateArgs} args - Arguments to update one EmergencyContact.
     * @example
     * // Update one EmergencyContact
     * const emergencyContact = await prisma.emergencyContact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmergencyContactUpdateArgs>(args: SelectSubset<T, EmergencyContactUpdateArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmergencyContacts.
     * @param {EmergencyContactDeleteManyArgs} args - Arguments to filter EmergencyContacts to delete.
     * @example
     * // Delete a few EmergencyContacts
     * const { count } = await prisma.emergencyContact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmergencyContactDeleteManyArgs>(args?: SelectSubset<T, EmergencyContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmergencyContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmergencyContacts
     * const emergencyContact = await prisma.emergencyContact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmergencyContactUpdateManyArgs>(args: SelectSubset<T, EmergencyContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmergencyContacts and returns the data updated in the database.
     * @param {EmergencyContactUpdateManyAndReturnArgs} args - Arguments to update many EmergencyContacts.
     * @example
     * // Update many EmergencyContacts
     * const emergencyContact = await prisma.emergencyContact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmergencyContacts and only return the `id`
     * const emergencyContactWithIdOnly = await prisma.emergencyContact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmergencyContactUpdateManyAndReturnArgs>(args: SelectSubset<T, EmergencyContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmergencyContact.
     * @param {EmergencyContactUpsertArgs} args - Arguments to update or create a EmergencyContact.
     * @example
     * // Update or create a EmergencyContact
     * const emergencyContact = await prisma.emergencyContact.upsert({
     *   create: {
     *     // ... data to create a EmergencyContact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmergencyContact we want to update
     *   }
     * })
     */
    upsert<T extends EmergencyContactUpsertArgs>(args: SelectSubset<T, EmergencyContactUpsertArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmergencyContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyContactCountArgs} args - Arguments to filter EmergencyContacts to count.
     * @example
     * // Count the number of EmergencyContacts
     * const count = await prisma.emergencyContact.count({
     *   where: {
     *     // ... the filter for the EmergencyContacts we want to count
     *   }
     * })
    **/
    count<T extends EmergencyContactCountArgs>(
      args?: Subset<T, EmergencyContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmergencyContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmergencyContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmergencyContactAggregateArgs>(args: Subset<T, EmergencyContactAggregateArgs>): Prisma.PrismaPromise<GetEmergencyContactAggregateType<T>>

    /**
     * Group by EmergencyContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmergencyContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmergencyContactGroupByArgs['orderBy'] }
        : { orderBy?: EmergencyContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmergencyContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmergencyContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmergencyContact model
   */
  readonly fields: EmergencyContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmergencyContact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmergencyContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmergencyContact model
   */
  interface EmergencyContactFieldRefs {
    readonly id: FieldRef<"EmergencyContact", 'String'>
    readonly memberId: FieldRef<"EmergencyContact", 'String'>
    readonly name: FieldRef<"EmergencyContact", 'String'>
    readonly relationship: FieldRef<"EmergencyContact", 'String'>
    readonly phone: FieldRef<"EmergencyContact", 'String'>
    readonly email: FieldRef<"EmergencyContact", 'String'>
    readonly createdAt: FieldRef<"EmergencyContact", 'DateTime'>
    readonly updatedAt: FieldRef<"EmergencyContact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmergencyContact findUnique
   */
  export type EmergencyContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyContact to fetch.
     */
    where: EmergencyContactWhereUniqueInput
  }

  /**
   * EmergencyContact findUniqueOrThrow
   */
  export type EmergencyContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyContact to fetch.
     */
    where: EmergencyContactWhereUniqueInput
  }

  /**
   * EmergencyContact findFirst
   */
  export type EmergencyContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyContact to fetch.
     */
    where?: EmergencyContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyContacts to fetch.
     */
    orderBy?: EmergencyContactOrderByWithRelationInput | EmergencyContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmergencyContacts.
     */
    cursor?: EmergencyContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmergencyContacts.
     */
    distinct?: EmergencyContactScalarFieldEnum | EmergencyContactScalarFieldEnum[]
  }

  /**
   * EmergencyContact findFirstOrThrow
   */
  export type EmergencyContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyContact to fetch.
     */
    where?: EmergencyContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyContacts to fetch.
     */
    orderBy?: EmergencyContactOrderByWithRelationInput | EmergencyContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmergencyContacts.
     */
    cursor?: EmergencyContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmergencyContacts.
     */
    distinct?: EmergencyContactScalarFieldEnum | EmergencyContactScalarFieldEnum[]
  }

  /**
   * EmergencyContact findMany
   */
  export type EmergencyContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyContacts to fetch.
     */
    where?: EmergencyContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyContacts to fetch.
     */
    orderBy?: EmergencyContactOrderByWithRelationInput | EmergencyContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmergencyContacts.
     */
    cursor?: EmergencyContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyContacts.
     */
    skip?: number
    distinct?: EmergencyContactScalarFieldEnum | EmergencyContactScalarFieldEnum[]
  }

  /**
   * EmergencyContact create
   */
  export type EmergencyContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * The data needed to create a EmergencyContact.
     */
    data: XOR<EmergencyContactCreateInput, EmergencyContactUncheckedCreateInput>
  }

  /**
   * EmergencyContact createMany
   */
  export type EmergencyContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmergencyContacts.
     */
    data: EmergencyContactCreateManyInput | EmergencyContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmergencyContact createManyAndReturn
   */
  export type EmergencyContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * The data used to create many EmergencyContacts.
     */
    data: EmergencyContactCreateManyInput | EmergencyContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmergencyContact update
   */
  export type EmergencyContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * The data needed to update a EmergencyContact.
     */
    data: XOR<EmergencyContactUpdateInput, EmergencyContactUncheckedUpdateInput>
    /**
     * Choose, which EmergencyContact to update.
     */
    where: EmergencyContactWhereUniqueInput
  }

  /**
   * EmergencyContact updateMany
   */
  export type EmergencyContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmergencyContacts.
     */
    data: XOR<EmergencyContactUpdateManyMutationInput, EmergencyContactUncheckedUpdateManyInput>
    /**
     * Filter which EmergencyContacts to update
     */
    where?: EmergencyContactWhereInput
    /**
     * Limit how many EmergencyContacts to update.
     */
    limit?: number
  }

  /**
   * EmergencyContact updateManyAndReturn
   */
  export type EmergencyContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * The data used to update EmergencyContacts.
     */
    data: XOR<EmergencyContactUpdateManyMutationInput, EmergencyContactUncheckedUpdateManyInput>
    /**
     * Filter which EmergencyContacts to update
     */
    where?: EmergencyContactWhereInput
    /**
     * Limit how many EmergencyContacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmergencyContact upsert
   */
  export type EmergencyContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * The filter to search for the EmergencyContact to update in case it exists.
     */
    where: EmergencyContactWhereUniqueInput
    /**
     * In case the EmergencyContact found by the `where` argument doesn't exist, create a new EmergencyContact with this data.
     */
    create: XOR<EmergencyContactCreateInput, EmergencyContactUncheckedCreateInput>
    /**
     * In case the EmergencyContact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmergencyContactUpdateInput, EmergencyContactUncheckedUpdateInput>
  }

  /**
   * EmergencyContact delete
   */
  export type EmergencyContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * Filter which EmergencyContact to delete.
     */
    where: EmergencyContactWhereUniqueInput
  }

  /**
   * EmergencyContact deleteMany
   */
  export type EmergencyContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmergencyContacts to delete
     */
    where?: EmergencyContactWhereInput
    /**
     * Limit how many EmergencyContacts to delete.
     */
    limit?: number
  }

  /**
   * EmergencyContact without action
   */
  export type EmergencyContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
  }


  /**
   * Model MedicalInfo
   */

  export type AggregateMedicalInfo = {
    _count: MedicalInfoCountAggregateOutputType | null
    _min: MedicalInfoMinAggregateOutputType | null
    _max: MedicalInfoMaxAggregateOutputType | null
  }

  export type MedicalInfoMinAggregateOutputType = {
    id: string | null
    memberId: string | null
    emergency_notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicalInfoMaxAggregateOutputType = {
    id: string | null
    memberId: string | null
    emergency_notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicalInfoCountAggregateOutputType = {
    id: number
    memberId: number
    fitness_goals: number
    health_conditions: number
    allergies: number
    medications: number
    emergency_notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MedicalInfoMinAggregateInputType = {
    id?: true
    memberId?: true
    emergency_notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicalInfoMaxAggregateInputType = {
    id?: true
    memberId?: true
    emergency_notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicalInfoCountAggregateInputType = {
    id?: true
    memberId?: true
    fitness_goals?: true
    health_conditions?: true
    allergies?: true
    medications?: true
    emergency_notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MedicalInfoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalInfo to aggregate.
     */
    where?: MedicalInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalInfos to fetch.
     */
    orderBy?: MedicalInfoOrderByWithRelationInput | MedicalInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicalInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MedicalInfos
    **/
    _count?: true | MedicalInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicalInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicalInfoMaxAggregateInputType
  }

  export type GetMedicalInfoAggregateType<T extends MedicalInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicalInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicalInfo[P]>
      : GetScalarType<T[P], AggregateMedicalInfo[P]>
  }




  export type MedicalInfoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalInfoWhereInput
    orderBy?: MedicalInfoOrderByWithAggregationInput | MedicalInfoOrderByWithAggregationInput[]
    by: MedicalInfoScalarFieldEnum[] | MedicalInfoScalarFieldEnum
    having?: MedicalInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicalInfoCountAggregateInputType | true
    _min?: MedicalInfoMinAggregateInputType
    _max?: MedicalInfoMaxAggregateInputType
  }

  export type MedicalInfoGroupByOutputType = {
    id: string
    memberId: string
    fitness_goals: string[]
    health_conditions: string[]
    allergies: string[]
    medications: string[]
    emergency_notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: MedicalInfoCountAggregateOutputType | null
    _min: MedicalInfoMinAggregateOutputType | null
    _max: MedicalInfoMaxAggregateOutputType | null
  }

  type GetMedicalInfoGroupByPayload<T extends MedicalInfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicalInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicalInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicalInfoGroupByOutputType[P]>
            : GetScalarType<T[P], MedicalInfoGroupByOutputType[P]>
        }
      >
    >


  export type MedicalInfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    fitness_goals?: boolean
    health_conditions?: boolean
    allergies?: boolean
    medications?: boolean
    emergency_notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicalInfo"]>

  export type MedicalInfoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    fitness_goals?: boolean
    health_conditions?: boolean
    allergies?: boolean
    medications?: boolean
    emergency_notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicalInfo"]>

  export type MedicalInfoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    fitness_goals?: boolean
    health_conditions?: boolean
    allergies?: boolean
    medications?: boolean
    emergency_notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicalInfo"]>

  export type MedicalInfoSelectScalar = {
    id?: boolean
    memberId?: boolean
    fitness_goals?: boolean
    health_conditions?: boolean
    allergies?: boolean
    medications?: boolean
    emergency_notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MedicalInfoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "memberId" | "fitness_goals" | "health_conditions" | "allergies" | "medications" | "emergency_notes" | "createdAt" | "updatedAt", ExtArgs["result"]["medicalInfo"]>
  export type MedicalInfoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type MedicalInfoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type MedicalInfoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }

  export type $MedicalInfoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MedicalInfo"
    objects: {
      member: Prisma.$MemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      memberId: string
      fitness_goals: string[]
      health_conditions: string[]
      allergies: string[]
      medications: string[]
      emergency_notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["medicalInfo"]>
    composites: {}
  }

  type MedicalInfoGetPayload<S extends boolean | null | undefined | MedicalInfoDefaultArgs> = $Result.GetResult<Prisma.$MedicalInfoPayload, S>

  type MedicalInfoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MedicalInfoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicalInfoCountAggregateInputType | true
    }

  export interface MedicalInfoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MedicalInfo'], meta: { name: 'MedicalInfo' } }
    /**
     * Find zero or one MedicalInfo that matches the filter.
     * @param {MedicalInfoFindUniqueArgs} args - Arguments to find a MedicalInfo
     * @example
     * // Get one MedicalInfo
     * const medicalInfo = await prisma.medicalInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicalInfoFindUniqueArgs>(args: SelectSubset<T, MedicalInfoFindUniqueArgs<ExtArgs>>): Prisma__MedicalInfoClient<$Result.GetResult<Prisma.$MedicalInfoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MedicalInfo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MedicalInfoFindUniqueOrThrowArgs} args - Arguments to find a MedicalInfo
     * @example
     * // Get one MedicalInfo
     * const medicalInfo = await prisma.medicalInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicalInfoFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicalInfoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicalInfoClient<$Result.GetResult<Prisma.$MedicalInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicalInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalInfoFindFirstArgs} args - Arguments to find a MedicalInfo
     * @example
     * // Get one MedicalInfo
     * const medicalInfo = await prisma.medicalInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicalInfoFindFirstArgs>(args?: SelectSubset<T, MedicalInfoFindFirstArgs<ExtArgs>>): Prisma__MedicalInfoClient<$Result.GetResult<Prisma.$MedicalInfoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicalInfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalInfoFindFirstOrThrowArgs} args - Arguments to find a MedicalInfo
     * @example
     * // Get one MedicalInfo
     * const medicalInfo = await prisma.medicalInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicalInfoFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicalInfoFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicalInfoClient<$Result.GetResult<Prisma.$MedicalInfoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MedicalInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalInfoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MedicalInfos
     * const medicalInfos = await prisma.medicalInfo.findMany()
     * 
     * // Get first 10 MedicalInfos
     * const medicalInfos = await prisma.medicalInfo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicalInfoWithIdOnly = await prisma.medicalInfo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicalInfoFindManyArgs>(args?: SelectSubset<T, MedicalInfoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MedicalInfo.
     * @param {MedicalInfoCreateArgs} args - Arguments to create a MedicalInfo.
     * @example
     * // Create one MedicalInfo
     * const MedicalInfo = await prisma.medicalInfo.create({
     *   data: {
     *     // ... data to create a MedicalInfo
     *   }
     * })
     * 
     */
    create<T extends MedicalInfoCreateArgs>(args: SelectSubset<T, MedicalInfoCreateArgs<ExtArgs>>): Prisma__MedicalInfoClient<$Result.GetResult<Prisma.$MedicalInfoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MedicalInfos.
     * @param {MedicalInfoCreateManyArgs} args - Arguments to create many MedicalInfos.
     * @example
     * // Create many MedicalInfos
     * const medicalInfo = await prisma.medicalInfo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicalInfoCreateManyArgs>(args?: SelectSubset<T, MedicalInfoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MedicalInfos and returns the data saved in the database.
     * @param {MedicalInfoCreateManyAndReturnArgs} args - Arguments to create many MedicalInfos.
     * @example
     * // Create many MedicalInfos
     * const medicalInfo = await prisma.medicalInfo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MedicalInfos and only return the `id`
     * const medicalInfoWithIdOnly = await prisma.medicalInfo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicalInfoCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicalInfoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalInfoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MedicalInfo.
     * @param {MedicalInfoDeleteArgs} args - Arguments to delete one MedicalInfo.
     * @example
     * // Delete one MedicalInfo
     * const MedicalInfo = await prisma.medicalInfo.delete({
     *   where: {
     *     // ... filter to delete one MedicalInfo
     *   }
     * })
     * 
     */
    delete<T extends MedicalInfoDeleteArgs>(args: SelectSubset<T, MedicalInfoDeleteArgs<ExtArgs>>): Prisma__MedicalInfoClient<$Result.GetResult<Prisma.$MedicalInfoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MedicalInfo.
     * @param {MedicalInfoUpdateArgs} args - Arguments to update one MedicalInfo.
     * @example
     * // Update one MedicalInfo
     * const medicalInfo = await prisma.medicalInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicalInfoUpdateArgs>(args: SelectSubset<T, MedicalInfoUpdateArgs<ExtArgs>>): Prisma__MedicalInfoClient<$Result.GetResult<Prisma.$MedicalInfoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MedicalInfos.
     * @param {MedicalInfoDeleteManyArgs} args - Arguments to filter MedicalInfos to delete.
     * @example
     * // Delete a few MedicalInfos
     * const { count } = await prisma.medicalInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicalInfoDeleteManyArgs>(args?: SelectSubset<T, MedicalInfoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicalInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MedicalInfos
     * const medicalInfo = await prisma.medicalInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicalInfoUpdateManyArgs>(args: SelectSubset<T, MedicalInfoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicalInfos and returns the data updated in the database.
     * @param {MedicalInfoUpdateManyAndReturnArgs} args - Arguments to update many MedicalInfos.
     * @example
     * // Update many MedicalInfos
     * const medicalInfo = await prisma.medicalInfo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MedicalInfos and only return the `id`
     * const medicalInfoWithIdOnly = await prisma.medicalInfo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MedicalInfoUpdateManyAndReturnArgs>(args: SelectSubset<T, MedicalInfoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalInfoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MedicalInfo.
     * @param {MedicalInfoUpsertArgs} args - Arguments to update or create a MedicalInfo.
     * @example
     * // Update or create a MedicalInfo
     * const medicalInfo = await prisma.medicalInfo.upsert({
     *   create: {
     *     // ... data to create a MedicalInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MedicalInfo we want to update
     *   }
     * })
     */
    upsert<T extends MedicalInfoUpsertArgs>(args: SelectSubset<T, MedicalInfoUpsertArgs<ExtArgs>>): Prisma__MedicalInfoClient<$Result.GetResult<Prisma.$MedicalInfoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MedicalInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalInfoCountArgs} args - Arguments to filter MedicalInfos to count.
     * @example
     * // Count the number of MedicalInfos
     * const count = await prisma.medicalInfo.count({
     *   where: {
     *     // ... the filter for the MedicalInfos we want to count
     *   }
     * })
    **/
    count<T extends MedicalInfoCountArgs>(
      args?: Subset<T, MedicalInfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicalInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MedicalInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicalInfoAggregateArgs>(args: Subset<T, MedicalInfoAggregateArgs>): Prisma.PrismaPromise<GetMedicalInfoAggregateType<T>>

    /**
     * Group by MedicalInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicalInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicalInfoGroupByArgs['orderBy'] }
        : { orderBy?: MedicalInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicalInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicalInfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MedicalInfo model
   */
  readonly fields: MedicalInfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MedicalInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicalInfoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MedicalInfo model
   */
  interface MedicalInfoFieldRefs {
    readonly id: FieldRef<"MedicalInfo", 'String'>
    readonly memberId: FieldRef<"MedicalInfo", 'String'>
    readonly fitness_goals: FieldRef<"MedicalInfo", 'String[]'>
    readonly health_conditions: FieldRef<"MedicalInfo", 'String[]'>
    readonly allergies: FieldRef<"MedicalInfo", 'String[]'>
    readonly medications: FieldRef<"MedicalInfo", 'String[]'>
    readonly emergency_notes: FieldRef<"MedicalInfo", 'String'>
    readonly createdAt: FieldRef<"MedicalInfo", 'DateTime'>
    readonly updatedAt: FieldRef<"MedicalInfo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MedicalInfo findUnique
   */
  export type MedicalInfoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalInfo
     */
    select?: MedicalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalInfo
     */
    omit?: MedicalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalInfoInclude<ExtArgs> | null
    /**
     * Filter, which MedicalInfo to fetch.
     */
    where: MedicalInfoWhereUniqueInput
  }

  /**
   * MedicalInfo findUniqueOrThrow
   */
  export type MedicalInfoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalInfo
     */
    select?: MedicalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalInfo
     */
    omit?: MedicalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalInfoInclude<ExtArgs> | null
    /**
     * Filter, which MedicalInfo to fetch.
     */
    where: MedicalInfoWhereUniqueInput
  }

  /**
   * MedicalInfo findFirst
   */
  export type MedicalInfoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalInfo
     */
    select?: MedicalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalInfo
     */
    omit?: MedicalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalInfoInclude<ExtArgs> | null
    /**
     * Filter, which MedicalInfo to fetch.
     */
    where?: MedicalInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalInfos to fetch.
     */
    orderBy?: MedicalInfoOrderByWithRelationInput | MedicalInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalInfos.
     */
    cursor?: MedicalInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalInfos.
     */
    distinct?: MedicalInfoScalarFieldEnum | MedicalInfoScalarFieldEnum[]
  }

  /**
   * MedicalInfo findFirstOrThrow
   */
  export type MedicalInfoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalInfo
     */
    select?: MedicalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalInfo
     */
    omit?: MedicalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalInfoInclude<ExtArgs> | null
    /**
     * Filter, which MedicalInfo to fetch.
     */
    where?: MedicalInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalInfos to fetch.
     */
    orderBy?: MedicalInfoOrderByWithRelationInput | MedicalInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalInfos.
     */
    cursor?: MedicalInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalInfos.
     */
    distinct?: MedicalInfoScalarFieldEnum | MedicalInfoScalarFieldEnum[]
  }

  /**
   * MedicalInfo findMany
   */
  export type MedicalInfoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalInfo
     */
    select?: MedicalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalInfo
     */
    omit?: MedicalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalInfoInclude<ExtArgs> | null
    /**
     * Filter, which MedicalInfos to fetch.
     */
    where?: MedicalInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalInfos to fetch.
     */
    orderBy?: MedicalInfoOrderByWithRelationInput | MedicalInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MedicalInfos.
     */
    cursor?: MedicalInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalInfos.
     */
    skip?: number
    distinct?: MedicalInfoScalarFieldEnum | MedicalInfoScalarFieldEnum[]
  }

  /**
   * MedicalInfo create
   */
  export type MedicalInfoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalInfo
     */
    select?: MedicalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalInfo
     */
    omit?: MedicalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalInfoInclude<ExtArgs> | null
    /**
     * The data needed to create a MedicalInfo.
     */
    data: XOR<MedicalInfoCreateInput, MedicalInfoUncheckedCreateInput>
  }

  /**
   * MedicalInfo createMany
   */
  export type MedicalInfoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MedicalInfos.
     */
    data: MedicalInfoCreateManyInput | MedicalInfoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MedicalInfo createManyAndReturn
   */
  export type MedicalInfoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalInfo
     */
    select?: MedicalInfoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalInfo
     */
    omit?: MedicalInfoOmit<ExtArgs> | null
    /**
     * The data used to create many MedicalInfos.
     */
    data: MedicalInfoCreateManyInput | MedicalInfoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalInfoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicalInfo update
   */
  export type MedicalInfoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalInfo
     */
    select?: MedicalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalInfo
     */
    omit?: MedicalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalInfoInclude<ExtArgs> | null
    /**
     * The data needed to update a MedicalInfo.
     */
    data: XOR<MedicalInfoUpdateInput, MedicalInfoUncheckedUpdateInput>
    /**
     * Choose, which MedicalInfo to update.
     */
    where: MedicalInfoWhereUniqueInput
  }

  /**
   * MedicalInfo updateMany
   */
  export type MedicalInfoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MedicalInfos.
     */
    data: XOR<MedicalInfoUpdateManyMutationInput, MedicalInfoUncheckedUpdateManyInput>
    /**
     * Filter which MedicalInfos to update
     */
    where?: MedicalInfoWhereInput
    /**
     * Limit how many MedicalInfos to update.
     */
    limit?: number
  }

  /**
   * MedicalInfo updateManyAndReturn
   */
  export type MedicalInfoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalInfo
     */
    select?: MedicalInfoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalInfo
     */
    omit?: MedicalInfoOmit<ExtArgs> | null
    /**
     * The data used to update MedicalInfos.
     */
    data: XOR<MedicalInfoUpdateManyMutationInput, MedicalInfoUncheckedUpdateManyInput>
    /**
     * Filter which MedicalInfos to update
     */
    where?: MedicalInfoWhereInput
    /**
     * Limit how many MedicalInfos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalInfoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicalInfo upsert
   */
  export type MedicalInfoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalInfo
     */
    select?: MedicalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalInfo
     */
    omit?: MedicalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalInfoInclude<ExtArgs> | null
    /**
     * The filter to search for the MedicalInfo to update in case it exists.
     */
    where: MedicalInfoWhereUniqueInput
    /**
     * In case the MedicalInfo found by the `where` argument doesn't exist, create a new MedicalInfo with this data.
     */
    create: XOR<MedicalInfoCreateInput, MedicalInfoUncheckedCreateInput>
    /**
     * In case the MedicalInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicalInfoUpdateInput, MedicalInfoUncheckedUpdateInput>
  }

  /**
   * MedicalInfo delete
   */
  export type MedicalInfoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalInfo
     */
    select?: MedicalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalInfo
     */
    omit?: MedicalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalInfoInclude<ExtArgs> | null
    /**
     * Filter which MedicalInfo to delete.
     */
    where: MedicalInfoWhereUniqueInput
  }

  /**
   * MedicalInfo deleteMany
   */
  export type MedicalInfoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalInfos to delete
     */
    where?: MedicalInfoWhereInput
    /**
     * Limit how many MedicalInfos to delete.
     */
    limit?: number
  }

  /**
   * MedicalInfo without action
   */
  export type MedicalInfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalInfo
     */
    select?: MedicalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalInfo
     */
    omit?: MedicalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalInfoInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    amount: number | null
    memberId: string | null
    method: string | null
    createdAt: Date | null
    status: string | null
    description: string | null
    reference: string | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    amount: number | null
    memberId: string | null
    method: string | null
    createdAt: Date | null
    status: string | null
    description: string | null
    reference: string | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    amount: number
    memberId: number
    method: number
    createdAt: number
    status: number
    description: number
    reference: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    amount?: true
    memberId?: true
    method?: true
    createdAt?: true
    status?: true
    description?: true
    reference?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    amount?: true
    memberId?: true
    method?: true
    createdAt?: true
    status?: true
    description?: true
    reference?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    amount?: true
    memberId?: true
    method?: true
    createdAt?: true
    status?: true
    description?: true
    reference?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    amount: number
    memberId: string
    method: string
    createdAt: Date
    status: string
    description: string | null
    reference: string | null
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    memberId?: boolean
    method?: boolean
    createdAt?: boolean
    status?: boolean
    description?: boolean
    reference?: boolean
    updatedAt?: boolean
    Member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    memberId?: boolean
    method?: boolean
    createdAt?: boolean
    status?: boolean
    description?: boolean
    reference?: boolean
    updatedAt?: boolean
    Member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    memberId?: boolean
    method?: boolean
    createdAt?: boolean
    status?: boolean
    description?: boolean
    reference?: boolean
    updatedAt?: boolean
    Member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    amount?: boolean
    memberId?: boolean
    method?: boolean
    createdAt?: boolean
    status?: boolean
    description?: boolean
    reference?: boolean
    updatedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amount" | "memberId" | "method" | "createdAt" | "status" | "description" | "reference" | "updatedAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Member?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Member?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Member?: boolean | MemberDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      Member: Prisma.$MemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      amount: number
      memberId: string
      method: string
      createdAt: Date
      status: string
      description: string | null
      reference: string | null
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly memberId: FieldRef<"Payment", 'String'>
    readonly method: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly status: FieldRef<"Payment", 'String'>
    readonly description: FieldRef<"Payment", 'String'>
    readonly reference: FieldRef<"Payment", 'String'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    amount: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    amount: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    memberId: string | null
    amount: number | null
    details: string | null
    createdAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    memberId: string | null
    amount: number | null
    details: string | null
    createdAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    memberId: number
    amount: number
    details: number
    createdAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    amount?: true
  }

  export type InvoiceSumAggregateInputType = {
    amount?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    memberId?: true
    amount?: true
    details?: true
    createdAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    memberId?: true
    amount?: true
    details?: true
    createdAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    memberId?: true
    amount?: true
    details?: true
    createdAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    memberId: string
    amount: number
    details: string
    createdAt: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    amount?: boolean
    details?: boolean
    createdAt?: boolean
    Member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    amount?: boolean
    details?: boolean
    createdAt?: boolean
    Member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    amount?: boolean
    details?: boolean
    createdAt?: boolean
    Member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    memberId?: boolean
    amount?: boolean
    details?: boolean
    createdAt?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "memberId" | "amount" | "details" | "createdAt", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Member?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Member?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Member?: boolean | MemberDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      Member: Prisma.$MemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      memberId: string
      amount: number
      details: string
      createdAt: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {InvoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly memberId: FieldRef<"Invoice", 'String'>
    readonly amount: FieldRef<"Invoice", 'Float'>
    readonly details: FieldRef<"Invoice", 'String'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice updateManyAndReturn
   */
  export type InvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model MembershipPlan
   */

  export type AggregateMembershipPlan = {
    _count: MembershipPlanCountAggregateOutputType | null
    _avg: MembershipPlanAvgAggregateOutputType | null
    _sum: MembershipPlanSumAggregateOutputType | null
    _min: MembershipPlanMinAggregateOutputType | null
    _max: MembershipPlanMaxAggregateOutputType | null
  }

  export type MembershipPlanAvgAggregateOutputType = {
    price: number | null
    duration: number | null
  }

  export type MembershipPlanSumAggregateOutputType = {
    price: number | null
    duration: number | null
  }

  export type MembershipPlanMinAggregateOutputType = {
    id: string | null
    name: string | null
    price: number | null
    duration: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MembershipPlanMaxAggregateOutputType = {
    id: string | null
    name: string | null
    price: number | null
    duration: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MembershipPlanCountAggregateOutputType = {
    id: number
    name: number
    price: number
    duration: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MembershipPlanAvgAggregateInputType = {
    price?: true
    duration?: true
  }

  export type MembershipPlanSumAggregateInputType = {
    price?: true
    duration?: true
  }

  export type MembershipPlanMinAggregateInputType = {
    id?: true
    name?: true
    price?: true
    duration?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MembershipPlanMaxAggregateInputType = {
    id?: true
    name?: true
    price?: true
    duration?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MembershipPlanCountAggregateInputType = {
    id?: true
    name?: true
    price?: true
    duration?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MembershipPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MembershipPlan to aggregate.
     */
    where?: MembershipPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MembershipPlans to fetch.
     */
    orderBy?: MembershipPlanOrderByWithRelationInput | MembershipPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MembershipPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MembershipPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MembershipPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MembershipPlans
    **/
    _count?: true | MembershipPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MembershipPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MembershipPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MembershipPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MembershipPlanMaxAggregateInputType
  }

  export type GetMembershipPlanAggregateType<T extends MembershipPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateMembershipPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMembershipPlan[P]>
      : GetScalarType<T[P], AggregateMembershipPlan[P]>
  }




  export type MembershipPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MembershipPlanWhereInput
    orderBy?: MembershipPlanOrderByWithAggregationInput | MembershipPlanOrderByWithAggregationInput[]
    by: MembershipPlanScalarFieldEnum[] | MembershipPlanScalarFieldEnum
    having?: MembershipPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MembershipPlanCountAggregateInputType | true
    _avg?: MembershipPlanAvgAggregateInputType
    _sum?: MembershipPlanSumAggregateInputType
    _min?: MembershipPlanMinAggregateInputType
    _max?: MembershipPlanMaxAggregateInputType
  }

  export type MembershipPlanGroupByOutputType = {
    id: string
    name: string
    price: number
    duration: number
    createdAt: Date
    updatedAt: Date
    _count: MembershipPlanCountAggregateOutputType | null
    _avg: MembershipPlanAvgAggregateOutputType | null
    _sum: MembershipPlanSumAggregateOutputType | null
    _min: MembershipPlanMinAggregateOutputType | null
    _max: MembershipPlanMaxAggregateOutputType | null
  }

  type GetMembershipPlanGroupByPayload<T extends MembershipPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MembershipPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MembershipPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MembershipPlanGroupByOutputType[P]>
            : GetScalarType<T[P], MembershipPlanGroupByOutputType[P]>
        }
      >
    >


  export type MembershipPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    duration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscriptions?: boolean | MembershipPlan$subscriptionsArgs<ExtArgs>
    _count?: boolean | MembershipPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["membershipPlan"]>

  export type MembershipPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    duration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["membershipPlan"]>

  export type MembershipPlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    duration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["membershipPlan"]>

  export type MembershipPlanSelectScalar = {
    id?: boolean
    name?: boolean
    price?: boolean
    duration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MembershipPlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "price" | "duration" | "createdAt" | "updatedAt", ExtArgs["result"]["membershipPlan"]>
  export type MembershipPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | MembershipPlan$subscriptionsArgs<ExtArgs>
    _count?: boolean | MembershipPlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MembershipPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MembershipPlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MembershipPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MembershipPlan"
    objects: {
      subscriptions: Prisma.$SubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      price: number
      duration: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["membershipPlan"]>
    composites: {}
  }

  type MembershipPlanGetPayload<S extends boolean | null | undefined | MembershipPlanDefaultArgs> = $Result.GetResult<Prisma.$MembershipPlanPayload, S>

  type MembershipPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MembershipPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MembershipPlanCountAggregateInputType | true
    }

  export interface MembershipPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MembershipPlan'], meta: { name: 'MembershipPlan' } }
    /**
     * Find zero or one MembershipPlan that matches the filter.
     * @param {MembershipPlanFindUniqueArgs} args - Arguments to find a MembershipPlan
     * @example
     * // Get one MembershipPlan
     * const membershipPlan = await prisma.membershipPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MembershipPlanFindUniqueArgs>(args: SelectSubset<T, MembershipPlanFindUniqueArgs<ExtArgs>>): Prisma__MembershipPlanClient<$Result.GetResult<Prisma.$MembershipPlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MembershipPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MembershipPlanFindUniqueOrThrowArgs} args - Arguments to find a MembershipPlan
     * @example
     * // Get one MembershipPlan
     * const membershipPlan = await prisma.membershipPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MembershipPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, MembershipPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MembershipPlanClient<$Result.GetResult<Prisma.$MembershipPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MembershipPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipPlanFindFirstArgs} args - Arguments to find a MembershipPlan
     * @example
     * // Get one MembershipPlan
     * const membershipPlan = await prisma.membershipPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MembershipPlanFindFirstArgs>(args?: SelectSubset<T, MembershipPlanFindFirstArgs<ExtArgs>>): Prisma__MembershipPlanClient<$Result.GetResult<Prisma.$MembershipPlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MembershipPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipPlanFindFirstOrThrowArgs} args - Arguments to find a MembershipPlan
     * @example
     * // Get one MembershipPlan
     * const membershipPlan = await prisma.membershipPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MembershipPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, MembershipPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__MembershipPlanClient<$Result.GetResult<Prisma.$MembershipPlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MembershipPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MembershipPlans
     * const membershipPlans = await prisma.membershipPlan.findMany()
     * 
     * // Get first 10 MembershipPlans
     * const membershipPlans = await prisma.membershipPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const membershipPlanWithIdOnly = await prisma.membershipPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MembershipPlanFindManyArgs>(args?: SelectSubset<T, MembershipPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MembershipPlan.
     * @param {MembershipPlanCreateArgs} args - Arguments to create a MembershipPlan.
     * @example
     * // Create one MembershipPlan
     * const MembershipPlan = await prisma.membershipPlan.create({
     *   data: {
     *     // ... data to create a MembershipPlan
     *   }
     * })
     * 
     */
    create<T extends MembershipPlanCreateArgs>(args: SelectSubset<T, MembershipPlanCreateArgs<ExtArgs>>): Prisma__MembershipPlanClient<$Result.GetResult<Prisma.$MembershipPlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MembershipPlans.
     * @param {MembershipPlanCreateManyArgs} args - Arguments to create many MembershipPlans.
     * @example
     * // Create many MembershipPlans
     * const membershipPlan = await prisma.membershipPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MembershipPlanCreateManyArgs>(args?: SelectSubset<T, MembershipPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MembershipPlans and returns the data saved in the database.
     * @param {MembershipPlanCreateManyAndReturnArgs} args - Arguments to create many MembershipPlans.
     * @example
     * // Create many MembershipPlans
     * const membershipPlan = await prisma.membershipPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MembershipPlans and only return the `id`
     * const membershipPlanWithIdOnly = await prisma.membershipPlan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MembershipPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, MembershipPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipPlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MembershipPlan.
     * @param {MembershipPlanDeleteArgs} args - Arguments to delete one MembershipPlan.
     * @example
     * // Delete one MembershipPlan
     * const MembershipPlan = await prisma.membershipPlan.delete({
     *   where: {
     *     // ... filter to delete one MembershipPlan
     *   }
     * })
     * 
     */
    delete<T extends MembershipPlanDeleteArgs>(args: SelectSubset<T, MembershipPlanDeleteArgs<ExtArgs>>): Prisma__MembershipPlanClient<$Result.GetResult<Prisma.$MembershipPlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MembershipPlan.
     * @param {MembershipPlanUpdateArgs} args - Arguments to update one MembershipPlan.
     * @example
     * // Update one MembershipPlan
     * const membershipPlan = await prisma.membershipPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MembershipPlanUpdateArgs>(args: SelectSubset<T, MembershipPlanUpdateArgs<ExtArgs>>): Prisma__MembershipPlanClient<$Result.GetResult<Prisma.$MembershipPlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MembershipPlans.
     * @param {MembershipPlanDeleteManyArgs} args - Arguments to filter MembershipPlans to delete.
     * @example
     * // Delete a few MembershipPlans
     * const { count } = await prisma.membershipPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MembershipPlanDeleteManyArgs>(args?: SelectSubset<T, MembershipPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MembershipPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MembershipPlans
     * const membershipPlan = await prisma.membershipPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MembershipPlanUpdateManyArgs>(args: SelectSubset<T, MembershipPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MembershipPlans and returns the data updated in the database.
     * @param {MembershipPlanUpdateManyAndReturnArgs} args - Arguments to update many MembershipPlans.
     * @example
     * // Update many MembershipPlans
     * const membershipPlan = await prisma.membershipPlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MembershipPlans and only return the `id`
     * const membershipPlanWithIdOnly = await prisma.membershipPlan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MembershipPlanUpdateManyAndReturnArgs>(args: SelectSubset<T, MembershipPlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipPlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MembershipPlan.
     * @param {MembershipPlanUpsertArgs} args - Arguments to update or create a MembershipPlan.
     * @example
     * // Update or create a MembershipPlan
     * const membershipPlan = await prisma.membershipPlan.upsert({
     *   create: {
     *     // ... data to create a MembershipPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MembershipPlan we want to update
     *   }
     * })
     */
    upsert<T extends MembershipPlanUpsertArgs>(args: SelectSubset<T, MembershipPlanUpsertArgs<ExtArgs>>): Prisma__MembershipPlanClient<$Result.GetResult<Prisma.$MembershipPlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MembershipPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipPlanCountArgs} args - Arguments to filter MembershipPlans to count.
     * @example
     * // Count the number of MembershipPlans
     * const count = await prisma.membershipPlan.count({
     *   where: {
     *     // ... the filter for the MembershipPlans we want to count
     *   }
     * })
    **/
    count<T extends MembershipPlanCountArgs>(
      args?: Subset<T, MembershipPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MembershipPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MembershipPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MembershipPlanAggregateArgs>(args: Subset<T, MembershipPlanAggregateArgs>): Prisma.PrismaPromise<GetMembershipPlanAggregateType<T>>

    /**
     * Group by MembershipPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MembershipPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MembershipPlanGroupByArgs['orderBy'] }
        : { orderBy?: MembershipPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MembershipPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMembershipPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MembershipPlan model
   */
  readonly fields: MembershipPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MembershipPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MembershipPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscriptions<T extends MembershipPlan$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, MembershipPlan$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MembershipPlan model
   */
  interface MembershipPlanFieldRefs {
    readonly id: FieldRef<"MembershipPlan", 'String'>
    readonly name: FieldRef<"MembershipPlan", 'String'>
    readonly price: FieldRef<"MembershipPlan", 'Float'>
    readonly duration: FieldRef<"MembershipPlan", 'Int'>
    readonly createdAt: FieldRef<"MembershipPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"MembershipPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MembershipPlan findUnique
   */
  export type MembershipPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipPlan
     */
    select?: MembershipPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipPlan
     */
    omit?: MembershipPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipPlanInclude<ExtArgs> | null
    /**
     * Filter, which MembershipPlan to fetch.
     */
    where: MembershipPlanWhereUniqueInput
  }

  /**
   * MembershipPlan findUniqueOrThrow
   */
  export type MembershipPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipPlan
     */
    select?: MembershipPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipPlan
     */
    omit?: MembershipPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipPlanInclude<ExtArgs> | null
    /**
     * Filter, which MembershipPlan to fetch.
     */
    where: MembershipPlanWhereUniqueInput
  }

  /**
   * MembershipPlan findFirst
   */
  export type MembershipPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipPlan
     */
    select?: MembershipPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipPlan
     */
    omit?: MembershipPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipPlanInclude<ExtArgs> | null
    /**
     * Filter, which MembershipPlan to fetch.
     */
    where?: MembershipPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MembershipPlans to fetch.
     */
    orderBy?: MembershipPlanOrderByWithRelationInput | MembershipPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MembershipPlans.
     */
    cursor?: MembershipPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MembershipPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MembershipPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MembershipPlans.
     */
    distinct?: MembershipPlanScalarFieldEnum | MembershipPlanScalarFieldEnum[]
  }

  /**
   * MembershipPlan findFirstOrThrow
   */
  export type MembershipPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipPlan
     */
    select?: MembershipPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipPlan
     */
    omit?: MembershipPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipPlanInclude<ExtArgs> | null
    /**
     * Filter, which MembershipPlan to fetch.
     */
    where?: MembershipPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MembershipPlans to fetch.
     */
    orderBy?: MembershipPlanOrderByWithRelationInput | MembershipPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MembershipPlans.
     */
    cursor?: MembershipPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MembershipPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MembershipPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MembershipPlans.
     */
    distinct?: MembershipPlanScalarFieldEnum | MembershipPlanScalarFieldEnum[]
  }

  /**
   * MembershipPlan findMany
   */
  export type MembershipPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipPlan
     */
    select?: MembershipPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipPlan
     */
    omit?: MembershipPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipPlanInclude<ExtArgs> | null
    /**
     * Filter, which MembershipPlans to fetch.
     */
    where?: MembershipPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MembershipPlans to fetch.
     */
    orderBy?: MembershipPlanOrderByWithRelationInput | MembershipPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MembershipPlans.
     */
    cursor?: MembershipPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MembershipPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MembershipPlans.
     */
    skip?: number
    distinct?: MembershipPlanScalarFieldEnum | MembershipPlanScalarFieldEnum[]
  }

  /**
   * MembershipPlan create
   */
  export type MembershipPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipPlan
     */
    select?: MembershipPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipPlan
     */
    omit?: MembershipPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a MembershipPlan.
     */
    data: XOR<MembershipPlanCreateInput, MembershipPlanUncheckedCreateInput>
  }

  /**
   * MembershipPlan createMany
   */
  export type MembershipPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MembershipPlans.
     */
    data: MembershipPlanCreateManyInput | MembershipPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MembershipPlan createManyAndReturn
   */
  export type MembershipPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipPlan
     */
    select?: MembershipPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipPlan
     */
    omit?: MembershipPlanOmit<ExtArgs> | null
    /**
     * The data used to create many MembershipPlans.
     */
    data: MembershipPlanCreateManyInput | MembershipPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MembershipPlan update
   */
  export type MembershipPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipPlan
     */
    select?: MembershipPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipPlan
     */
    omit?: MembershipPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a MembershipPlan.
     */
    data: XOR<MembershipPlanUpdateInput, MembershipPlanUncheckedUpdateInput>
    /**
     * Choose, which MembershipPlan to update.
     */
    where: MembershipPlanWhereUniqueInput
  }

  /**
   * MembershipPlan updateMany
   */
  export type MembershipPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MembershipPlans.
     */
    data: XOR<MembershipPlanUpdateManyMutationInput, MembershipPlanUncheckedUpdateManyInput>
    /**
     * Filter which MembershipPlans to update
     */
    where?: MembershipPlanWhereInput
    /**
     * Limit how many MembershipPlans to update.
     */
    limit?: number
  }

  /**
   * MembershipPlan updateManyAndReturn
   */
  export type MembershipPlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipPlan
     */
    select?: MembershipPlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipPlan
     */
    omit?: MembershipPlanOmit<ExtArgs> | null
    /**
     * The data used to update MembershipPlans.
     */
    data: XOR<MembershipPlanUpdateManyMutationInput, MembershipPlanUncheckedUpdateManyInput>
    /**
     * Filter which MembershipPlans to update
     */
    where?: MembershipPlanWhereInput
    /**
     * Limit how many MembershipPlans to update.
     */
    limit?: number
  }

  /**
   * MembershipPlan upsert
   */
  export type MembershipPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipPlan
     */
    select?: MembershipPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipPlan
     */
    omit?: MembershipPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the MembershipPlan to update in case it exists.
     */
    where: MembershipPlanWhereUniqueInput
    /**
     * In case the MembershipPlan found by the `where` argument doesn't exist, create a new MembershipPlan with this data.
     */
    create: XOR<MembershipPlanCreateInput, MembershipPlanUncheckedCreateInput>
    /**
     * In case the MembershipPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MembershipPlanUpdateInput, MembershipPlanUncheckedUpdateInput>
  }

  /**
   * MembershipPlan delete
   */
  export type MembershipPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipPlan
     */
    select?: MembershipPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipPlan
     */
    omit?: MembershipPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipPlanInclude<ExtArgs> | null
    /**
     * Filter which MembershipPlan to delete.
     */
    where: MembershipPlanWhereUniqueInput
  }

  /**
   * MembershipPlan deleteMany
   */
  export type MembershipPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MembershipPlans to delete
     */
    where?: MembershipPlanWhereInput
    /**
     * Limit how many MembershipPlans to delete.
     */
    limit?: number
  }

  /**
   * MembershipPlan.subscriptions
   */
  export type MembershipPlan$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * MembershipPlan without action
   */
  export type MembershipPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipPlan
     */
    select?: MembershipPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipPlan
     */
    omit?: MembershipPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipPlanInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    memberId: string | null
    planId: string | null
    startDate: Date | null
    endDate: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    memberId: string | null
    planId: string | null
    startDate: Date | null
    endDate: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    memberId: number
    planId: number
    startDate: number
    endDate: number
    _all: number
  }


  export type SubscriptionMinAggregateInputType = {
    id?: true
    memberId?: true
    planId?: true
    startDate?: true
    endDate?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    memberId?: true
    planId?: true
    startDate?: true
    endDate?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    memberId?: true
    planId?: true
    startDate?: true
    endDate?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    memberId: string
    planId: string
    startDate: Date
    endDate: Date
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    planId?: boolean
    startDate?: boolean
    endDate?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
    plan?: boolean | MembershipPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    planId?: boolean
    startDate?: boolean
    endDate?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
    plan?: boolean | MembershipPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    planId?: boolean
    startDate?: boolean
    endDate?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
    plan?: boolean | MembershipPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    memberId?: boolean
    planId?: boolean
    startDate?: boolean
    endDate?: boolean
  }

  export type SubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "memberId" | "planId" | "startDate" | "endDate", ExtArgs["result"]["subscription"]>
  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
    plan?: boolean | MembershipPlanDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
    plan?: boolean | MembershipPlanDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
    plan?: boolean | MembershipPlanDefaultArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      member: Prisma.$MemberPayload<ExtArgs>
      plan: Prisma.$MembershipPlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      memberId: string
      planId: string
      startDate: Date
      endDate: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions and returns the data updated in the database.
     * @param {SubscriptionUpdateManyAndReturnArgs} args - Arguments to update many Subscriptions.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    plan<T extends MembershipPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MembershipPlanDefaultArgs<ExtArgs>>): Prisma__MembershipPlanClient<$Result.GetResult<Prisma.$MembershipPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly memberId: FieldRef<"Subscription", 'String'>
    readonly planId: FieldRef<"Subscription", 'String'>
    readonly startDate: FieldRef<"Subscription", 'DateTime'>
    readonly endDate: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
  }

  /**
   * Subscription updateManyAndReturn
   */
  export type SubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to delete.
     */
    limit?: number
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model Equipment
   */

  export type AggregateEquipment = {
    _count: EquipmentCountAggregateOutputType | null
    _avg: EquipmentAvgAggregateOutputType | null
    _sum: EquipmentSumAggregateOutputType | null
    _min: EquipmentMinAggregateOutputType | null
    _max: EquipmentMaxAggregateOutputType | null
  }

  export type EquipmentAvgAggregateOutputType = {
    quantity: number | null
    available: number | null
    cost: number | null
    inUse: number | null
  }

  export type EquipmentSumAggregateOutputType = {
    quantity: number | null
    available: number | null
    cost: number | null
    inUse: number | null
  }

  export type EquipmentMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    quantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
    available: number | null
    brand: string | null
    category: string | null
    cost: number | null
    description: string | null
    imageUrl: string | null
    inUse: number | null
    lastMaintenance: Date | null
    location: string | null
    maintenance: boolean | null
    model: string | null
    nextMaintenance: Date | null
    purchaseDate: Date | null
    serialNumber: string | null
    status: $Enums.EquipmentStatus | null
    warrantyExpiry: Date | null
  }

  export type EquipmentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    quantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
    available: number | null
    brand: string | null
    category: string | null
    cost: number | null
    description: string | null
    imageUrl: string | null
    inUse: number | null
    lastMaintenance: Date | null
    location: string | null
    maintenance: boolean | null
    model: string | null
    nextMaintenance: Date | null
    purchaseDate: Date | null
    serialNumber: string | null
    status: $Enums.EquipmentStatus | null
    warrantyExpiry: Date | null
  }

  export type EquipmentCountAggregateOutputType = {
    id: number
    name: number
    type: number
    quantity: number
    createdAt: number
    updatedAt: number
    available: number
    brand: number
    category: number
    cost: number
    description: number
    imageUrl: number
    inUse: number
    lastMaintenance: number
    location: number
    maintenance: number
    model: number
    nextMaintenance: number
    purchaseDate: number
    serialNumber: number
    status: number
    warrantyExpiry: number
    _all: number
  }


  export type EquipmentAvgAggregateInputType = {
    quantity?: true
    available?: true
    cost?: true
    inUse?: true
  }

  export type EquipmentSumAggregateInputType = {
    quantity?: true
    available?: true
    cost?: true
    inUse?: true
  }

  export type EquipmentMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
    available?: true
    brand?: true
    category?: true
    cost?: true
    description?: true
    imageUrl?: true
    inUse?: true
    lastMaintenance?: true
    location?: true
    maintenance?: true
    model?: true
    nextMaintenance?: true
    purchaseDate?: true
    serialNumber?: true
    status?: true
    warrantyExpiry?: true
  }

  export type EquipmentMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
    available?: true
    brand?: true
    category?: true
    cost?: true
    description?: true
    imageUrl?: true
    inUse?: true
    lastMaintenance?: true
    location?: true
    maintenance?: true
    model?: true
    nextMaintenance?: true
    purchaseDate?: true
    serialNumber?: true
    status?: true
    warrantyExpiry?: true
  }

  export type EquipmentCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
    available?: true
    brand?: true
    category?: true
    cost?: true
    description?: true
    imageUrl?: true
    inUse?: true
    lastMaintenance?: true
    location?: true
    maintenance?: true
    model?: true
    nextMaintenance?: true
    purchaseDate?: true
    serialNumber?: true
    status?: true
    warrantyExpiry?: true
    _all?: true
  }

  export type EquipmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Equipment to aggregate.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Equipment
    **/
    _count?: true | EquipmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EquipmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EquipmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipmentMaxAggregateInputType
  }

  export type GetEquipmentAggregateType<T extends EquipmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipment[P]>
      : GetScalarType<T[P], AggregateEquipment[P]>
  }




  export type EquipmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentWhereInput
    orderBy?: EquipmentOrderByWithAggregationInput | EquipmentOrderByWithAggregationInput[]
    by: EquipmentScalarFieldEnum[] | EquipmentScalarFieldEnum
    having?: EquipmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipmentCountAggregateInputType | true
    _avg?: EquipmentAvgAggregateInputType
    _sum?: EquipmentSumAggregateInputType
    _min?: EquipmentMinAggregateInputType
    _max?: EquipmentMaxAggregateInputType
  }

  export type EquipmentGroupByOutputType = {
    id: string
    name: string
    type: string
    quantity: number
    createdAt: Date
    updatedAt: Date
    available: number
    brand: string | null
    category: string
    cost: number | null
    description: string | null
    imageUrl: string | null
    inUse: number
    lastMaintenance: Date | null
    location: string | null
    maintenance: boolean
    model: string | null
    nextMaintenance: Date | null
    purchaseDate: Date | null
    serialNumber: string | null
    status: $Enums.EquipmentStatus
    warrantyExpiry: Date | null
    _count: EquipmentCountAggregateOutputType | null
    _avg: EquipmentAvgAggregateOutputType | null
    _sum: EquipmentSumAggregateOutputType | null
    _min: EquipmentMinAggregateOutputType | null
    _max: EquipmentMaxAggregateOutputType | null
  }

  type GetEquipmentGroupByPayload<T extends EquipmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipmentGroupByOutputType[P]>
            : GetScalarType<T[P], EquipmentGroupByOutputType[P]>
        }
      >
    >


  export type EquipmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    available?: boolean
    brand?: boolean
    category?: boolean
    cost?: boolean
    description?: boolean
    imageUrl?: boolean
    inUse?: boolean
    lastMaintenance?: boolean
    location?: boolean
    maintenance?: boolean
    model?: boolean
    nextMaintenance?: boolean
    purchaseDate?: boolean
    serialNumber?: boolean
    status?: boolean
    warrantyExpiry?: boolean
    maintenanceLogs?: boolean | Equipment$maintenanceLogsArgs<ExtArgs>
    _count?: boolean | EquipmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipment"]>

  export type EquipmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    available?: boolean
    brand?: boolean
    category?: boolean
    cost?: boolean
    description?: boolean
    imageUrl?: boolean
    inUse?: boolean
    lastMaintenance?: boolean
    location?: boolean
    maintenance?: boolean
    model?: boolean
    nextMaintenance?: boolean
    purchaseDate?: boolean
    serialNumber?: boolean
    status?: boolean
    warrantyExpiry?: boolean
  }, ExtArgs["result"]["equipment"]>

  export type EquipmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    available?: boolean
    brand?: boolean
    category?: boolean
    cost?: boolean
    description?: boolean
    imageUrl?: boolean
    inUse?: boolean
    lastMaintenance?: boolean
    location?: boolean
    maintenance?: boolean
    model?: boolean
    nextMaintenance?: boolean
    purchaseDate?: boolean
    serialNumber?: boolean
    status?: boolean
    warrantyExpiry?: boolean
  }, ExtArgs["result"]["equipment"]>

  export type EquipmentSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    available?: boolean
    brand?: boolean
    category?: boolean
    cost?: boolean
    description?: boolean
    imageUrl?: boolean
    inUse?: boolean
    lastMaintenance?: boolean
    location?: boolean
    maintenance?: boolean
    model?: boolean
    nextMaintenance?: boolean
    purchaseDate?: boolean
    serialNumber?: boolean
    status?: boolean
    warrantyExpiry?: boolean
  }

  export type EquipmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "quantity" | "createdAt" | "updatedAt" | "available" | "brand" | "category" | "cost" | "description" | "imageUrl" | "inUse" | "lastMaintenance" | "location" | "maintenance" | "model" | "nextMaintenance" | "purchaseDate" | "serialNumber" | "status" | "warrantyExpiry", ExtArgs["result"]["equipment"]>
  export type EquipmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    maintenanceLogs?: boolean | Equipment$maintenanceLogsArgs<ExtArgs>
    _count?: boolean | EquipmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EquipmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type EquipmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EquipmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Equipment"
    objects: {
      maintenanceLogs: Prisma.$MaintenanceLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      quantity: number
      createdAt: Date
      updatedAt: Date
      available: number
      brand: string | null
      category: string
      cost: number | null
      description: string | null
      imageUrl: string | null
      inUse: number
      lastMaintenance: Date | null
      location: string | null
      maintenance: boolean
      model: string | null
      nextMaintenance: Date | null
      purchaseDate: Date | null
      serialNumber: string | null
      status: $Enums.EquipmentStatus
      warrantyExpiry: Date | null
    }, ExtArgs["result"]["equipment"]>
    composites: {}
  }

  type EquipmentGetPayload<S extends boolean | null | undefined | EquipmentDefaultArgs> = $Result.GetResult<Prisma.$EquipmentPayload, S>

  type EquipmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EquipmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EquipmentCountAggregateInputType | true
    }

  export interface EquipmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Equipment'], meta: { name: 'Equipment' } }
    /**
     * Find zero or one Equipment that matches the filter.
     * @param {EquipmentFindUniqueArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EquipmentFindUniqueArgs>(args: SelectSubset<T, EquipmentFindUniqueArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Equipment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EquipmentFindUniqueOrThrowArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EquipmentFindUniqueOrThrowArgs>(args: SelectSubset<T, EquipmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Equipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindFirstArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EquipmentFindFirstArgs>(args?: SelectSubset<T, EquipmentFindFirstArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Equipment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindFirstOrThrowArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EquipmentFindFirstOrThrowArgs>(args?: SelectSubset<T, EquipmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Equipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Equipment
     * const equipment = await prisma.equipment.findMany()
     * 
     * // Get first 10 Equipment
     * const equipment = await prisma.equipment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipmentWithIdOnly = await prisma.equipment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EquipmentFindManyArgs>(args?: SelectSubset<T, EquipmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Equipment.
     * @param {EquipmentCreateArgs} args - Arguments to create a Equipment.
     * @example
     * // Create one Equipment
     * const Equipment = await prisma.equipment.create({
     *   data: {
     *     // ... data to create a Equipment
     *   }
     * })
     * 
     */
    create<T extends EquipmentCreateArgs>(args: SelectSubset<T, EquipmentCreateArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Equipment.
     * @param {EquipmentCreateManyArgs} args - Arguments to create many Equipment.
     * @example
     * // Create many Equipment
     * const equipment = await prisma.equipment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EquipmentCreateManyArgs>(args?: SelectSubset<T, EquipmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Equipment and returns the data saved in the database.
     * @param {EquipmentCreateManyAndReturnArgs} args - Arguments to create many Equipment.
     * @example
     * // Create many Equipment
     * const equipment = await prisma.equipment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Equipment and only return the `id`
     * const equipmentWithIdOnly = await prisma.equipment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EquipmentCreateManyAndReturnArgs>(args?: SelectSubset<T, EquipmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Equipment.
     * @param {EquipmentDeleteArgs} args - Arguments to delete one Equipment.
     * @example
     * // Delete one Equipment
     * const Equipment = await prisma.equipment.delete({
     *   where: {
     *     // ... filter to delete one Equipment
     *   }
     * })
     * 
     */
    delete<T extends EquipmentDeleteArgs>(args: SelectSubset<T, EquipmentDeleteArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Equipment.
     * @param {EquipmentUpdateArgs} args - Arguments to update one Equipment.
     * @example
     * // Update one Equipment
     * const equipment = await prisma.equipment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EquipmentUpdateArgs>(args: SelectSubset<T, EquipmentUpdateArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Equipment.
     * @param {EquipmentDeleteManyArgs} args - Arguments to filter Equipment to delete.
     * @example
     * // Delete a few Equipment
     * const { count } = await prisma.equipment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EquipmentDeleteManyArgs>(args?: SelectSubset<T, EquipmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Equipment
     * const equipment = await prisma.equipment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EquipmentUpdateManyArgs>(args: SelectSubset<T, EquipmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Equipment and returns the data updated in the database.
     * @param {EquipmentUpdateManyAndReturnArgs} args - Arguments to update many Equipment.
     * @example
     * // Update many Equipment
     * const equipment = await prisma.equipment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Equipment and only return the `id`
     * const equipmentWithIdOnly = await prisma.equipment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EquipmentUpdateManyAndReturnArgs>(args: SelectSubset<T, EquipmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Equipment.
     * @param {EquipmentUpsertArgs} args - Arguments to update or create a Equipment.
     * @example
     * // Update or create a Equipment
     * const equipment = await prisma.equipment.upsert({
     *   create: {
     *     // ... data to create a Equipment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Equipment we want to update
     *   }
     * })
     */
    upsert<T extends EquipmentUpsertArgs>(args: SelectSubset<T, EquipmentUpsertArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentCountArgs} args - Arguments to filter Equipment to count.
     * @example
     * // Count the number of Equipment
     * const count = await prisma.equipment.count({
     *   where: {
     *     // ... the filter for the Equipment we want to count
     *   }
     * })
    **/
    count<T extends EquipmentCountArgs>(
      args?: Subset<T, EquipmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipmentAggregateArgs>(args: Subset<T, EquipmentAggregateArgs>): Prisma.PrismaPromise<GetEquipmentAggregateType<T>>

    /**
     * Group by Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EquipmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EquipmentGroupByArgs['orderBy'] }
        : { orderBy?: EquipmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EquipmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Equipment model
   */
  readonly fields: EquipmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Equipment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EquipmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    maintenanceLogs<T extends Equipment$maintenanceLogsArgs<ExtArgs> = {}>(args?: Subset<T, Equipment$maintenanceLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Equipment model
   */
  interface EquipmentFieldRefs {
    readonly id: FieldRef<"Equipment", 'String'>
    readonly name: FieldRef<"Equipment", 'String'>
    readonly type: FieldRef<"Equipment", 'String'>
    readonly quantity: FieldRef<"Equipment", 'Int'>
    readonly createdAt: FieldRef<"Equipment", 'DateTime'>
    readonly updatedAt: FieldRef<"Equipment", 'DateTime'>
    readonly available: FieldRef<"Equipment", 'Int'>
    readonly brand: FieldRef<"Equipment", 'String'>
    readonly category: FieldRef<"Equipment", 'String'>
    readonly cost: FieldRef<"Equipment", 'Float'>
    readonly description: FieldRef<"Equipment", 'String'>
    readonly imageUrl: FieldRef<"Equipment", 'String'>
    readonly inUse: FieldRef<"Equipment", 'Int'>
    readonly lastMaintenance: FieldRef<"Equipment", 'DateTime'>
    readonly location: FieldRef<"Equipment", 'String'>
    readonly maintenance: FieldRef<"Equipment", 'Boolean'>
    readonly model: FieldRef<"Equipment", 'String'>
    readonly nextMaintenance: FieldRef<"Equipment", 'DateTime'>
    readonly purchaseDate: FieldRef<"Equipment", 'DateTime'>
    readonly serialNumber: FieldRef<"Equipment", 'String'>
    readonly status: FieldRef<"Equipment", 'EquipmentStatus'>
    readonly warrantyExpiry: FieldRef<"Equipment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Equipment findUnique
   */
  export type EquipmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment findUniqueOrThrow
   */
  export type EquipmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment findFirst
   */
  export type EquipmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Equipment.
     */
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Equipment findFirstOrThrow
   */
  export type EquipmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Equipment.
     */
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Equipment findMany
   */
  export type EquipmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Equipment create
   */
  export type EquipmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Equipment.
     */
    data: XOR<EquipmentCreateInput, EquipmentUncheckedCreateInput>
  }

  /**
   * Equipment createMany
   */
  export type EquipmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Equipment.
     */
    data: EquipmentCreateManyInput | EquipmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Equipment createManyAndReturn
   */
  export type EquipmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * The data used to create many Equipment.
     */
    data: EquipmentCreateManyInput | EquipmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Equipment update
   */
  export type EquipmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Equipment.
     */
    data: XOR<EquipmentUpdateInput, EquipmentUncheckedUpdateInput>
    /**
     * Choose, which Equipment to update.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment updateMany
   */
  export type EquipmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Equipment.
     */
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyInput>
    /**
     * Filter which Equipment to update
     */
    where?: EquipmentWhereInput
    /**
     * Limit how many Equipment to update.
     */
    limit?: number
  }

  /**
   * Equipment updateManyAndReturn
   */
  export type EquipmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * The data used to update Equipment.
     */
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyInput>
    /**
     * Filter which Equipment to update
     */
    where?: EquipmentWhereInput
    /**
     * Limit how many Equipment to update.
     */
    limit?: number
  }

  /**
   * Equipment upsert
   */
  export type EquipmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Equipment to update in case it exists.
     */
    where: EquipmentWhereUniqueInput
    /**
     * In case the Equipment found by the `where` argument doesn't exist, create a new Equipment with this data.
     */
    create: XOR<EquipmentCreateInput, EquipmentUncheckedCreateInput>
    /**
     * In case the Equipment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EquipmentUpdateInput, EquipmentUncheckedUpdateInput>
  }

  /**
   * Equipment delete
   */
  export type EquipmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter which Equipment to delete.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment deleteMany
   */
  export type EquipmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Equipment to delete
     */
    where?: EquipmentWhereInput
    /**
     * Limit how many Equipment to delete.
     */
    limit?: number
  }

  /**
   * Equipment.maintenanceLogs
   */
  export type Equipment$maintenanceLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceLog
     */
    select?: MaintenanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceLog
     */
    omit?: MaintenanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceLogInclude<ExtArgs> | null
    where?: MaintenanceLogWhereInput
    orderBy?: MaintenanceLogOrderByWithRelationInput | MaintenanceLogOrderByWithRelationInput[]
    cursor?: MaintenanceLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaintenanceLogScalarFieldEnum | MaintenanceLogScalarFieldEnum[]
  }

  /**
   * Equipment without action
   */
  export type EquipmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
  }


  /**
   * Model MaintenanceLog
   */

  export type AggregateMaintenanceLog = {
    _count: MaintenanceLogCountAggregateOutputType | null
    _avg: MaintenanceLogAvgAggregateOutputType | null
    _sum: MaintenanceLogSumAggregateOutputType | null
    _min: MaintenanceLogMinAggregateOutputType | null
    _max: MaintenanceLogMaxAggregateOutputType | null
  }

  export type MaintenanceLogAvgAggregateOutputType = {
    cost: number | null
  }

  export type MaintenanceLogSumAggregateOutputType = {
    cost: number | null
  }

  export type MaintenanceLogMinAggregateOutputType = {
    id: string | null
    equipmentId: string | null
    type: $Enums.MaintenanceType | null
    description: string | null
    cost: number | null
    performedBy: string | null
    performedAt: Date | null
    nextDue: Date | null
  }

  export type MaintenanceLogMaxAggregateOutputType = {
    id: string | null
    equipmentId: string | null
    type: $Enums.MaintenanceType | null
    description: string | null
    cost: number | null
    performedBy: string | null
    performedAt: Date | null
    nextDue: Date | null
  }

  export type MaintenanceLogCountAggregateOutputType = {
    id: number
    equipmentId: number
    type: number
    description: number
    cost: number
    performedBy: number
    performedAt: number
    nextDue: number
    _all: number
  }


  export type MaintenanceLogAvgAggregateInputType = {
    cost?: true
  }

  export type MaintenanceLogSumAggregateInputType = {
    cost?: true
  }

  export type MaintenanceLogMinAggregateInputType = {
    id?: true
    equipmentId?: true
    type?: true
    description?: true
    cost?: true
    performedBy?: true
    performedAt?: true
    nextDue?: true
  }

  export type MaintenanceLogMaxAggregateInputType = {
    id?: true
    equipmentId?: true
    type?: true
    description?: true
    cost?: true
    performedBy?: true
    performedAt?: true
    nextDue?: true
  }

  export type MaintenanceLogCountAggregateInputType = {
    id?: true
    equipmentId?: true
    type?: true
    description?: true
    cost?: true
    performedBy?: true
    performedAt?: true
    nextDue?: true
    _all?: true
  }

  export type MaintenanceLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaintenanceLog to aggregate.
     */
    where?: MaintenanceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceLogs to fetch.
     */
    orderBy?: MaintenanceLogOrderByWithRelationInput | MaintenanceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaintenanceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaintenanceLogs
    **/
    _count?: true | MaintenanceLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaintenanceLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaintenanceLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaintenanceLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaintenanceLogMaxAggregateInputType
  }

  export type GetMaintenanceLogAggregateType<T extends MaintenanceLogAggregateArgs> = {
        [P in keyof T & keyof AggregateMaintenanceLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaintenanceLog[P]>
      : GetScalarType<T[P], AggregateMaintenanceLog[P]>
  }




  export type MaintenanceLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceLogWhereInput
    orderBy?: MaintenanceLogOrderByWithAggregationInput | MaintenanceLogOrderByWithAggregationInput[]
    by: MaintenanceLogScalarFieldEnum[] | MaintenanceLogScalarFieldEnum
    having?: MaintenanceLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaintenanceLogCountAggregateInputType | true
    _avg?: MaintenanceLogAvgAggregateInputType
    _sum?: MaintenanceLogSumAggregateInputType
    _min?: MaintenanceLogMinAggregateInputType
    _max?: MaintenanceLogMaxAggregateInputType
  }

  export type MaintenanceLogGroupByOutputType = {
    id: string
    equipmentId: string
    type: $Enums.MaintenanceType
    description: string
    cost: number | null
    performedBy: string | null
    performedAt: Date
    nextDue: Date | null
    _count: MaintenanceLogCountAggregateOutputType | null
    _avg: MaintenanceLogAvgAggregateOutputType | null
    _sum: MaintenanceLogSumAggregateOutputType | null
    _min: MaintenanceLogMinAggregateOutputType | null
    _max: MaintenanceLogMaxAggregateOutputType | null
  }

  type GetMaintenanceLogGroupByPayload<T extends MaintenanceLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaintenanceLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaintenanceLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaintenanceLogGroupByOutputType[P]>
            : GetScalarType<T[P], MaintenanceLogGroupByOutputType[P]>
        }
      >
    >


  export type MaintenanceLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equipmentId?: boolean
    type?: boolean
    description?: boolean
    cost?: boolean
    performedBy?: boolean
    performedAt?: boolean
    nextDue?: boolean
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceLog"]>

  export type MaintenanceLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equipmentId?: boolean
    type?: boolean
    description?: boolean
    cost?: boolean
    performedBy?: boolean
    performedAt?: boolean
    nextDue?: boolean
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceLog"]>

  export type MaintenanceLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equipmentId?: boolean
    type?: boolean
    description?: boolean
    cost?: boolean
    performedBy?: boolean
    performedAt?: boolean
    nextDue?: boolean
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceLog"]>

  export type MaintenanceLogSelectScalar = {
    id?: boolean
    equipmentId?: boolean
    type?: boolean
    description?: boolean
    cost?: boolean
    performedBy?: boolean
    performedAt?: boolean
    nextDue?: boolean
  }

  export type MaintenanceLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "equipmentId" | "type" | "description" | "cost" | "performedBy" | "performedAt" | "nextDue", ExtArgs["result"]["maintenanceLog"]>
  export type MaintenanceLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }
  export type MaintenanceLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }
  export type MaintenanceLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }

  export type $MaintenanceLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MaintenanceLog"
    objects: {
      equipment: Prisma.$EquipmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      equipmentId: string
      type: $Enums.MaintenanceType
      description: string
      cost: number | null
      performedBy: string | null
      performedAt: Date
      nextDue: Date | null
    }, ExtArgs["result"]["maintenanceLog"]>
    composites: {}
  }

  type MaintenanceLogGetPayload<S extends boolean | null | undefined | MaintenanceLogDefaultArgs> = $Result.GetResult<Prisma.$MaintenanceLogPayload, S>

  type MaintenanceLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MaintenanceLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaintenanceLogCountAggregateInputType | true
    }

  export interface MaintenanceLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MaintenanceLog'], meta: { name: 'MaintenanceLog' } }
    /**
     * Find zero or one MaintenanceLog that matches the filter.
     * @param {MaintenanceLogFindUniqueArgs} args - Arguments to find a MaintenanceLog
     * @example
     * // Get one MaintenanceLog
     * const maintenanceLog = await prisma.maintenanceLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaintenanceLogFindUniqueArgs>(args: SelectSubset<T, MaintenanceLogFindUniqueArgs<ExtArgs>>): Prisma__MaintenanceLogClient<$Result.GetResult<Prisma.$MaintenanceLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MaintenanceLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MaintenanceLogFindUniqueOrThrowArgs} args - Arguments to find a MaintenanceLog
     * @example
     * // Get one MaintenanceLog
     * const maintenanceLog = await prisma.maintenanceLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaintenanceLogFindUniqueOrThrowArgs>(args: SelectSubset<T, MaintenanceLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaintenanceLogClient<$Result.GetResult<Prisma.$MaintenanceLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaintenanceLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceLogFindFirstArgs} args - Arguments to find a MaintenanceLog
     * @example
     * // Get one MaintenanceLog
     * const maintenanceLog = await prisma.maintenanceLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaintenanceLogFindFirstArgs>(args?: SelectSubset<T, MaintenanceLogFindFirstArgs<ExtArgs>>): Prisma__MaintenanceLogClient<$Result.GetResult<Prisma.$MaintenanceLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaintenanceLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceLogFindFirstOrThrowArgs} args - Arguments to find a MaintenanceLog
     * @example
     * // Get one MaintenanceLog
     * const maintenanceLog = await prisma.maintenanceLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaintenanceLogFindFirstOrThrowArgs>(args?: SelectSubset<T, MaintenanceLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaintenanceLogClient<$Result.GetResult<Prisma.$MaintenanceLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MaintenanceLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaintenanceLogs
     * const maintenanceLogs = await prisma.maintenanceLog.findMany()
     * 
     * // Get first 10 MaintenanceLogs
     * const maintenanceLogs = await prisma.maintenanceLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const maintenanceLogWithIdOnly = await prisma.maintenanceLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaintenanceLogFindManyArgs>(args?: SelectSubset<T, MaintenanceLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MaintenanceLog.
     * @param {MaintenanceLogCreateArgs} args - Arguments to create a MaintenanceLog.
     * @example
     * // Create one MaintenanceLog
     * const MaintenanceLog = await prisma.maintenanceLog.create({
     *   data: {
     *     // ... data to create a MaintenanceLog
     *   }
     * })
     * 
     */
    create<T extends MaintenanceLogCreateArgs>(args: SelectSubset<T, MaintenanceLogCreateArgs<ExtArgs>>): Prisma__MaintenanceLogClient<$Result.GetResult<Prisma.$MaintenanceLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MaintenanceLogs.
     * @param {MaintenanceLogCreateManyArgs} args - Arguments to create many MaintenanceLogs.
     * @example
     * // Create many MaintenanceLogs
     * const maintenanceLog = await prisma.maintenanceLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaintenanceLogCreateManyArgs>(args?: SelectSubset<T, MaintenanceLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MaintenanceLogs and returns the data saved in the database.
     * @param {MaintenanceLogCreateManyAndReturnArgs} args - Arguments to create many MaintenanceLogs.
     * @example
     * // Create many MaintenanceLogs
     * const maintenanceLog = await prisma.maintenanceLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MaintenanceLogs and only return the `id`
     * const maintenanceLogWithIdOnly = await prisma.maintenanceLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaintenanceLogCreateManyAndReturnArgs>(args?: SelectSubset<T, MaintenanceLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MaintenanceLog.
     * @param {MaintenanceLogDeleteArgs} args - Arguments to delete one MaintenanceLog.
     * @example
     * // Delete one MaintenanceLog
     * const MaintenanceLog = await prisma.maintenanceLog.delete({
     *   where: {
     *     // ... filter to delete one MaintenanceLog
     *   }
     * })
     * 
     */
    delete<T extends MaintenanceLogDeleteArgs>(args: SelectSubset<T, MaintenanceLogDeleteArgs<ExtArgs>>): Prisma__MaintenanceLogClient<$Result.GetResult<Prisma.$MaintenanceLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MaintenanceLog.
     * @param {MaintenanceLogUpdateArgs} args - Arguments to update one MaintenanceLog.
     * @example
     * // Update one MaintenanceLog
     * const maintenanceLog = await prisma.maintenanceLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaintenanceLogUpdateArgs>(args: SelectSubset<T, MaintenanceLogUpdateArgs<ExtArgs>>): Prisma__MaintenanceLogClient<$Result.GetResult<Prisma.$MaintenanceLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MaintenanceLogs.
     * @param {MaintenanceLogDeleteManyArgs} args - Arguments to filter MaintenanceLogs to delete.
     * @example
     * // Delete a few MaintenanceLogs
     * const { count } = await prisma.maintenanceLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaintenanceLogDeleteManyArgs>(args?: SelectSubset<T, MaintenanceLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaintenanceLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaintenanceLogs
     * const maintenanceLog = await prisma.maintenanceLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaintenanceLogUpdateManyArgs>(args: SelectSubset<T, MaintenanceLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaintenanceLogs and returns the data updated in the database.
     * @param {MaintenanceLogUpdateManyAndReturnArgs} args - Arguments to update many MaintenanceLogs.
     * @example
     * // Update many MaintenanceLogs
     * const maintenanceLog = await prisma.maintenanceLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MaintenanceLogs and only return the `id`
     * const maintenanceLogWithIdOnly = await prisma.maintenanceLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MaintenanceLogUpdateManyAndReturnArgs>(args: SelectSubset<T, MaintenanceLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MaintenanceLog.
     * @param {MaintenanceLogUpsertArgs} args - Arguments to update or create a MaintenanceLog.
     * @example
     * // Update or create a MaintenanceLog
     * const maintenanceLog = await prisma.maintenanceLog.upsert({
     *   create: {
     *     // ... data to create a MaintenanceLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaintenanceLog we want to update
     *   }
     * })
     */
    upsert<T extends MaintenanceLogUpsertArgs>(args: SelectSubset<T, MaintenanceLogUpsertArgs<ExtArgs>>): Prisma__MaintenanceLogClient<$Result.GetResult<Prisma.$MaintenanceLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MaintenanceLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceLogCountArgs} args - Arguments to filter MaintenanceLogs to count.
     * @example
     * // Count the number of MaintenanceLogs
     * const count = await prisma.maintenanceLog.count({
     *   where: {
     *     // ... the filter for the MaintenanceLogs we want to count
     *   }
     * })
    **/
    count<T extends MaintenanceLogCountArgs>(
      args?: Subset<T, MaintenanceLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaintenanceLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaintenanceLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaintenanceLogAggregateArgs>(args: Subset<T, MaintenanceLogAggregateArgs>): Prisma.PrismaPromise<GetMaintenanceLogAggregateType<T>>

    /**
     * Group by MaintenanceLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaintenanceLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaintenanceLogGroupByArgs['orderBy'] }
        : { orderBy?: MaintenanceLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaintenanceLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaintenanceLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MaintenanceLog model
   */
  readonly fields: MaintenanceLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaintenanceLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaintenanceLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    equipment<T extends EquipmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EquipmentDefaultArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MaintenanceLog model
   */
  interface MaintenanceLogFieldRefs {
    readonly id: FieldRef<"MaintenanceLog", 'String'>
    readonly equipmentId: FieldRef<"MaintenanceLog", 'String'>
    readonly type: FieldRef<"MaintenanceLog", 'MaintenanceType'>
    readonly description: FieldRef<"MaintenanceLog", 'String'>
    readonly cost: FieldRef<"MaintenanceLog", 'Float'>
    readonly performedBy: FieldRef<"MaintenanceLog", 'String'>
    readonly performedAt: FieldRef<"MaintenanceLog", 'DateTime'>
    readonly nextDue: FieldRef<"MaintenanceLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MaintenanceLog findUnique
   */
  export type MaintenanceLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceLog
     */
    select?: MaintenanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceLog
     */
    omit?: MaintenanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceLogInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceLog to fetch.
     */
    where: MaintenanceLogWhereUniqueInput
  }

  /**
   * MaintenanceLog findUniqueOrThrow
   */
  export type MaintenanceLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceLog
     */
    select?: MaintenanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceLog
     */
    omit?: MaintenanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceLogInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceLog to fetch.
     */
    where: MaintenanceLogWhereUniqueInput
  }

  /**
   * MaintenanceLog findFirst
   */
  export type MaintenanceLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceLog
     */
    select?: MaintenanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceLog
     */
    omit?: MaintenanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceLogInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceLog to fetch.
     */
    where?: MaintenanceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceLogs to fetch.
     */
    orderBy?: MaintenanceLogOrderByWithRelationInput | MaintenanceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaintenanceLogs.
     */
    cursor?: MaintenanceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaintenanceLogs.
     */
    distinct?: MaintenanceLogScalarFieldEnum | MaintenanceLogScalarFieldEnum[]
  }

  /**
   * MaintenanceLog findFirstOrThrow
   */
  export type MaintenanceLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceLog
     */
    select?: MaintenanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceLog
     */
    omit?: MaintenanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceLogInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceLog to fetch.
     */
    where?: MaintenanceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceLogs to fetch.
     */
    orderBy?: MaintenanceLogOrderByWithRelationInput | MaintenanceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaintenanceLogs.
     */
    cursor?: MaintenanceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaintenanceLogs.
     */
    distinct?: MaintenanceLogScalarFieldEnum | MaintenanceLogScalarFieldEnum[]
  }

  /**
   * MaintenanceLog findMany
   */
  export type MaintenanceLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceLog
     */
    select?: MaintenanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceLog
     */
    omit?: MaintenanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceLogInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceLogs to fetch.
     */
    where?: MaintenanceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceLogs to fetch.
     */
    orderBy?: MaintenanceLogOrderByWithRelationInput | MaintenanceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaintenanceLogs.
     */
    cursor?: MaintenanceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceLogs.
     */
    skip?: number
    distinct?: MaintenanceLogScalarFieldEnum | MaintenanceLogScalarFieldEnum[]
  }

  /**
   * MaintenanceLog create
   */
  export type MaintenanceLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceLog
     */
    select?: MaintenanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceLog
     */
    omit?: MaintenanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceLogInclude<ExtArgs> | null
    /**
     * The data needed to create a MaintenanceLog.
     */
    data: XOR<MaintenanceLogCreateInput, MaintenanceLogUncheckedCreateInput>
  }

  /**
   * MaintenanceLog createMany
   */
  export type MaintenanceLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MaintenanceLogs.
     */
    data: MaintenanceLogCreateManyInput | MaintenanceLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MaintenanceLog createManyAndReturn
   */
  export type MaintenanceLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceLog
     */
    select?: MaintenanceLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceLog
     */
    omit?: MaintenanceLogOmit<ExtArgs> | null
    /**
     * The data used to create many MaintenanceLogs.
     */
    data: MaintenanceLogCreateManyInput | MaintenanceLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaintenanceLog update
   */
  export type MaintenanceLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceLog
     */
    select?: MaintenanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceLog
     */
    omit?: MaintenanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceLogInclude<ExtArgs> | null
    /**
     * The data needed to update a MaintenanceLog.
     */
    data: XOR<MaintenanceLogUpdateInput, MaintenanceLogUncheckedUpdateInput>
    /**
     * Choose, which MaintenanceLog to update.
     */
    where: MaintenanceLogWhereUniqueInput
  }

  /**
   * MaintenanceLog updateMany
   */
  export type MaintenanceLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MaintenanceLogs.
     */
    data: XOR<MaintenanceLogUpdateManyMutationInput, MaintenanceLogUncheckedUpdateManyInput>
    /**
     * Filter which MaintenanceLogs to update
     */
    where?: MaintenanceLogWhereInput
    /**
     * Limit how many MaintenanceLogs to update.
     */
    limit?: number
  }

  /**
   * MaintenanceLog updateManyAndReturn
   */
  export type MaintenanceLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceLog
     */
    select?: MaintenanceLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceLog
     */
    omit?: MaintenanceLogOmit<ExtArgs> | null
    /**
     * The data used to update MaintenanceLogs.
     */
    data: XOR<MaintenanceLogUpdateManyMutationInput, MaintenanceLogUncheckedUpdateManyInput>
    /**
     * Filter which MaintenanceLogs to update
     */
    where?: MaintenanceLogWhereInput
    /**
     * Limit how many MaintenanceLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaintenanceLog upsert
   */
  export type MaintenanceLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceLog
     */
    select?: MaintenanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceLog
     */
    omit?: MaintenanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceLogInclude<ExtArgs> | null
    /**
     * The filter to search for the MaintenanceLog to update in case it exists.
     */
    where: MaintenanceLogWhereUniqueInput
    /**
     * In case the MaintenanceLog found by the `where` argument doesn't exist, create a new MaintenanceLog with this data.
     */
    create: XOR<MaintenanceLogCreateInput, MaintenanceLogUncheckedCreateInput>
    /**
     * In case the MaintenanceLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaintenanceLogUpdateInput, MaintenanceLogUncheckedUpdateInput>
  }

  /**
   * MaintenanceLog delete
   */
  export type MaintenanceLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceLog
     */
    select?: MaintenanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceLog
     */
    omit?: MaintenanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceLogInclude<ExtArgs> | null
    /**
     * Filter which MaintenanceLog to delete.
     */
    where: MaintenanceLogWhereUniqueInput
  }

  /**
   * MaintenanceLog deleteMany
   */
  export type MaintenanceLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaintenanceLogs to delete
     */
    where?: MaintenanceLogWhereInput
    /**
     * Limit how many MaintenanceLogs to delete.
     */
    limit?: number
  }

  /**
   * MaintenanceLog without action
   */
  export type MaintenanceLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceLog
     */
    select?: MaintenanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceLog
     */
    omit?: MaintenanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceLogInclude<ExtArgs> | null
  }


  /**
   * Model SystemIntegration
   */

  export type AggregateSystemIntegration = {
    _count: SystemIntegrationCountAggregateOutputType | null
    _avg: SystemIntegrationAvgAggregateOutputType | null
    _sum: SystemIntegrationSumAggregateOutputType | null
    _min: SystemIntegrationMinAggregateOutputType | null
    _max: SystemIntegrationMaxAggregateOutputType | null
  }

  export type SystemIntegrationAvgAggregateOutputType = {
    healthScore: number | null
    errorCount: number | null
  }

  export type SystemIntegrationSumAggregateOutputType = {
    healthScore: number | null
    errorCount: number | null
  }

  export type SystemIntegrationMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    status: string | null
    healthScore: number | null
    endpoint: string | null
    apiKey: string | null
    lastSync: Date | null
    errorCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemIntegrationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    status: string | null
    healthScore: number | null
    endpoint: string | null
    apiKey: string | null
    lastSync: Date | null
    errorCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemIntegrationCountAggregateOutputType = {
    id: number
    name: number
    type: number
    status: number
    healthScore: number
    endpoint: number
    apiKey: number
    config: number
    lastSync: number
    errorCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SystemIntegrationAvgAggregateInputType = {
    healthScore?: true
    errorCount?: true
  }

  export type SystemIntegrationSumAggregateInputType = {
    healthScore?: true
    errorCount?: true
  }

  export type SystemIntegrationMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    status?: true
    healthScore?: true
    endpoint?: true
    apiKey?: true
    lastSync?: true
    errorCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemIntegrationMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    status?: true
    healthScore?: true
    endpoint?: true
    apiKey?: true
    lastSync?: true
    errorCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemIntegrationCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    status?: true
    healthScore?: true
    endpoint?: true
    apiKey?: true
    config?: true
    lastSync?: true
    errorCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemIntegrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemIntegration to aggregate.
     */
    where?: SystemIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemIntegrations to fetch.
     */
    orderBy?: SystemIntegrationOrderByWithRelationInput | SystemIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemIntegrations
    **/
    _count?: true | SystemIntegrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemIntegrationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemIntegrationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemIntegrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemIntegrationMaxAggregateInputType
  }

  export type GetSystemIntegrationAggregateType<T extends SystemIntegrationAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemIntegration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemIntegration[P]>
      : GetScalarType<T[P], AggregateSystemIntegration[P]>
  }




  export type SystemIntegrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemIntegrationWhereInput
    orderBy?: SystemIntegrationOrderByWithAggregationInput | SystemIntegrationOrderByWithAggregationInput[]
    by: SystemIntegrationScalarFieldEnum[] | SystemIntegrationScalarFieldEnum
    having?: SystemIntegrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemIntegrationCountAggregateInputType | true
    _avg?: SystemIntegrationAvgAggregateInputType
    _sum?: SystemIntegrationSumAggregateInputType
    _min?: SystemIntegrationMinAggregateInputType
    _max?: SystemIntegrationMaxAggregateInputType
  }

  export type SystemIntegrationGroupByOutputType = {
    id: string
    name: string
    type: string
    status: string
    healthScore: number
    endpoint: string | null
    apiKey: string | null
    config: JsonValue | null
    lastSync: Date | null
    errorCount: number
    createdAt: Date
    updatedAt: Date
    _count: SystemIntegrationCountAggregateOutputType | null
    _avg: SystemIntegrationAvgAggregateOutputType | null
    _sum: SystemIntegrationSumAggregateOutputType | null
    _min: SystemIntegrationMinAggregateOutputType | null
    _max: SystemIntegrationMaxAggregateOutputType | null
  }

  type GetSystemIntegrationGroupByPayload<T extends SystemIntegrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemIntegrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemIntegrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemIntegrationGroupByOutputType[P]>
            : GetScalarType<T[P], SystemIntegrationGroupByOutputType[P]>
        }
      >
    >


  export type SystemIntegrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    healthScore?: boolean
    endpoint?: boolean
    apiKey?: boolean
    config?: boolean
    lastSync?: boolean
    errorCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemIntegration"]>

  export type SystemIntegrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    healthScore?: boolean
    endpoint?: boolean
    apiKey?: boolean
    config?: boolean
    lastSync?: boolean
    errorCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemIntegration"]>

  export type SystemIntegrationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    healthScore?: boolean
    endpoint?: boolean
    apiKey?: boolean
    config?: boolean
    lastSync?: boolean
    errorCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemIntegration"]>

  export type SystemIntegrationSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    healthScore?: boolean
    endpoint?: boolean
    apiKey?: boolean
    config?: boolean
    lastSync?: boolean
    errorCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SystemIntegrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "status" | "healthScore" | "endpoint" | "apiKey" | "config" | "lastSync" | "errorCount" | "createdAt" | "updatedAt", ExtArgs["result"]["systemIntegration"]>

  export type $SystemIntegrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemIntegration"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      status: string
      healthScore: number
      endpoint: string | null
      apiKey: string | null
      config: Prisma.JsonValue | null
      lastSync: Date | null
      errorCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["systemIntegration"]>
    composites: {}
  }

  type SystemIntegrationGetPayload<S extends boolean | null | undefined | SystemIntegrationDefaultArgs> = $Result.GetResult<Prisma.$SystemIntegrationPayload, S>

  type SystemIntegrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemIntegrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemIntegrationCountAggregateInputType | true
    }

  export interface SystemIntegrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemIntegration'], meta: { name: 'SystemIntegration' } }
    /**
     * Find zero or one SystemIntegration that matches the filter.
     * @param {SystemIntegrationFindUniqueArgs} args - Arguments to find a SystemIntegration
     * @example
     * // Get one SystemIntegration
     * const systemIntegration = await prisma.systemIntegration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemIntegrationFindUniqueArgs>(args: SelectSubset<T, SystemIntegrationFindUniqueArgs<ExtArgs>>): Prisma__SystemIntegrationClient<$Result.GetResult<Prisma.$SystemIntegrationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemIntegration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemIntegrationFindUniqueOrThrowArgs} args - Arguments to find a SystemIntegration
     * @example
     * // Get one SystemIntegration
     * const systemIntegration = await prisma.systemIntegration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemIntegrationFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemIntegrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemIntegrationClient<$Result.GetResult<Prisma.$SystemIntegrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemIntegration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemIntegrationFindFirstArgs} args - Arguments to find a SystemIntegration
     * @example
     * // Get one SystemIntegration
     * const systemIntegration = await prisma.systemIntegration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemIntegrationFindFirstArgs>(args?: SelectSubset<T, SystemIntegrationFindFirstArgs<ExtArgs>>): Prisma__SystemIntegrationClient<$Result.GetResult<Prisma.$SystemIntegrationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemIntegration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemIntegrationFindFirstOrThrowArgs} args - Arguments to find a SystemIntegration
     * @example
     * // Get one SystemIntegration
     * const systemIntegration = await prisma.systemIntegration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemIntegrationFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemIntegrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemIntegrationClient<$Result.GetResult<Prisma.$SystemIntegrationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemIntegrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemIntegrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemIntegrations
     * const systemIntegrations = await prisma.systemIntegration.findMany()
     * 
     * // Get first 10 SystemIntegrations
     * const systemIntegrations = await prisma.systemIntegration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemIntegrationWithIdOnly = await prisma.systemIntegration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemIntegrationFindManyArgs>(args?: SelectSubset<T, SystemIntegrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemIntegrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemIntegration.
     * @param {SystemIntegrationCreateArgs} args - Arguments to create a SystemIntegration.
     * @example
     * // Create one SystemIntegration
     * const SystemIntegration = await prisma.systemIntegration.create({
     *   data: {
     *     // ... data to create a SystemIntegration
     *   }
     * })
     * 
     */
    create<T extends SystemIntegrationCreateArgs>(args: SelectSubset<T, SystemIntegrationCreateArgs<ExtArgs>>): Prisma__SystemIntegrationClient<$Result.GetResult<Prisma.$SystemIntegrationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemIntegrations.
     * @param {SystemIntegrationCreateManyArgs} args - Arguments to create many SystemIntegrations.
     * @example
     * // Create many SystemIntegrations
     * const systemIntegration = await prisma.systemIntegration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemIntegrationCreateManyArgs>(args?: SelectSubset<T, SystemIntegrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemIntegrations and returns the data saved in the database.
     * @param {SystemIntegrationCreateManyAndReturnArgs} args - Arguments to create many SystemIntegrations.
     * @example
     * // Create many SystemIntegrations
     * const systemIntegration = await prisma.systemIntegration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemIntegrations and only return the `id`
     * const systemIntegrationWithIdOnly = await prisma.systemIntegration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemIntegrationCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemIntegrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemIntegrationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemIntegration.
     * @param {SystemIntegrationDeleteArgs} args - Arguments to delete one SystemIntegration.
     * @example
     * // Delete one SystemIntegration
     * const SystemIntegration = await prisma.systemIntegration.delete({
     *   where: {
     *     // ... filter to delete one SystemIntegration
     *   }
     * })
     * 
     */
    delete<T extends SystemIntegrationDeleteArgs>(args: SelectSubset<T, SystemIntegrationDeleteArgs<ExtArgs>>): Prisma__SystemIntegrationClient<$Result.GetResult<Prisma.$SystemIntegrationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemIntegration.
     * @param {SystemIntegrationUpdateArgs} args - Arguments to update one SystemIntegration.
     * @example
     * // Update one SystemIntegration
     * const systemIntegration = await prisma.systemIntegration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemIntegrationUpdateArgs>(args: SelectSubset<T, SystemIntegrationUpdateArgs<ExtArgs>>): Prisma__SystemIntegrationClient<$Result.GetResult<Prisma.$SystemIntegrationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemIntegrations.
     * @param {SystemIntegrationDeleteManyArgs} args - Arguments to filter SystemIntegrations to delete.
     * @example
     * // Delete a few SystemIntegrations
     * const { count } = await prisma.systemIntegration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemIntegrationDeleteManyArgs>(args?: SelectSubset<T, SystemIntegrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemIntegrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemIntegrations
     * const systemIntegration = await prisma.systemIntegration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemIntegrationUpdateManyArgs>(args: SelectSubset<T, SystemIntegrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemIntegrations and returns the data updated in the database.
     * @param {SystemIntegrationUpdateManyAndReturnArgs} args - Arguments to update many SystemIntegrations.
     * @example
     * // Update many SystemIntegrations
     * const systemIntegration = await prisma.systemIntegration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemIntegrations and only return the `id`
     * const systemIntegrationWithIdOnly = await prisma.systemIntegration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemIntegrationUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemIntegrationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemIntegrationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemIntegration.
     * @param {SystemIntegrationUpsertArgs} args - Arguments to update or create a SystemIntegration.
     * @example
     * // Update or create a SystemIntegration
     * const systemIntegration = await prisma.systemIntegration.upsert({
     *   create: {
     *     // ... data to create a SystemIntegration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemIntegration we want to update
     *   }
     * })
     */
    upsert<T extends SystemIntegrationUpsertArgs>(args: SelectSubset<T, SystemIntegrationUpsertArgs<ExtArgs>>): Prisma__SystemIntegrationClient<$Result.GetResult<Prisma.$SystemIntegrationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemIntegrationCountArgs} args - Arguments to filter SystemIntegrations to count.
     * @example
     * // Count the number of SystemIntegrations
     * const count = await prisma.systemIntegration.count({
     *   where: {
     *     // ... the filter for the SystemIntegrations we want to count
     *   }
     * })
    **/
    count<T extends SystemIntegrationCountArgs>(
      args?: Subset<T, SystemIntegrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemIntegrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemIntegrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemIntegrationAggregateArgs>(args: Subset<T, SystemIntegrationAggregateArgs>): Prisma.PrismaPromise<GetSystemIntegrationAggregateType<T>>

    /**
     * Group by SystemIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemIntegrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemIntegrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemIntegrationGroupByArgs['orderBy'] }
        : { orderBy?: SystemIntegrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemIntegrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemIntegrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemIntegration model
   */
  readonly fields: SystemIntegrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemIntegration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemIntegrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemIntegration model
   */
  interface SystemIntegrationFieldRefs {
    readonly id: FieldRef<"SystemIntegration", 'String'>
    readonly name: FieldRef<"SystemIntegration", 'String'>
    readonly type: FieldRef<"SystemIntegration", 'String'>
    readonly status: FieldRef<"SystemIntegration", 'String'>
    readonly healthScore: FieldRef<"SystemIntegration", 'Int'>
    readonly endpoint: FieldRef<"SystemIntegration", 'String'>
    readonly apiKey: FieldRef<"SystemIntegration", 'String'>
    readonly config: FieldRef<"SystemIntegration", 'Json'>
    readonly lastSync: FieldRef<"SystemIntegration", 'DateTime'>
    readonly errorCount: FieldRef<"SystemIntegration", 'Int'>
    readonly createdAt: FieldRef<"SystemIntegration", 'DateTime'>
    readonly updatedAt: FieldRef<"SystemIntegration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemIntegration findUnique
   */
  export type SystemIntegrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemIntegration
     */
    select?: SystemIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemIntegration
     */
    omit?: SystemIntegrationOmit<ExtArgs> | null
    /**
     * Filter, which SystemIntegration to fetch.
     */
    where: SystemIntegrationWhereUniqueInput
  }

  /**
   * SystemIntegration findUniqueOrThrow
   */
  export type SystemIntegrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemIntegration
     */
    select?: SystemIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemIntegration
     */
    omit?: SystemIntegrationOmit<ExtArgs> | null
    /**
     * Filter, which SystemIntegration to fetch.
     */
    where: SystemIntegrationWhereUniqueInput
  }

  /**
   * SystemIntegration findFirst
   */
  export type SystemIntegrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemIntegration
     */
    select?: SystemIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemIntegration
     */
    omit?: SystemIntegrationOmit<ExtArgs> | null
    /**
     * Filter, which SystemIntegration to fetch.
     */
    where?: SystemIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemIntegrations to fetch.
     */
    orderBy?: SystemIntegrationOrderByWithRelationInput | SystemIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemIntegrations.
     */
    cursor?: SystemIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemIntegrations.
     */
    distinct?: SystemIntegrationScalarFieldEnum | SystemIntegrationScalarFieldEnum[]
  }

  /**
   * SystemIntegration findFirstOrThrow
   */
  export type SystemIntegrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemIntegration
     */
    select?: SystemIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemIntegration
     */
    omit?: SystemIntegrationOmit<ExtArgs> | null
    /**
     * Filter, which SystemIntegration to fetch.
     */
    where?: SystemIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemIntegrations to fetch.
     */
    orderBy?: SystemIntegrationOrderByWithRelationInput | SystemIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemIntegrations.
     */
    cursor?: SystemIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemIntegrations.
     */
    distinct?: SystemIntegrationScalarFieldEnum | SystemIntegrationScalarFieldEnum[]
  }

  /**
   * SystemIntegration findMany
   */
  export type SystemIntegrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemIntegration
     */
    select?: SystemIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemIntegration
     */
    omit?: SystemIntegrationOmit<ExtArgs> | null
    /**
     * Filter, which SystemIntegrations to fetch.
     */
    where?: SystemIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemIntegrations to fetch.
     */
    orderBy?: SystemIntegrationOrderByWithRelationInput | SystemIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemIntegrations.
     */
    cursor?: SystemIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemIntegrations.
     */
    skip?: number
    distinct?: SystemIntegrationScalarFieldEnum | SystemIntegrationScalarFieldEnum[]
  }

  /**
   * SystemIntegration create
   */
  export type SystemIntegrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemIntegration
     */
    select?: SystemIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemIntegration
     */
    omit?: SystemIntegrationOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemIntegration.
     */
    data: XOR<SystemIntegrationCreateInput, SystemIntegrationUncheckedCreateInput>
  }

  /**
   * SystemIntegration createMany
   */
  export type SystemIntegrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemIntegrations.
     */
    data: SystemIntegrationCreateManyInput | SystemIntegrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemIntegration createManyAndReturn
   */
  export type SystemIntegrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemIntegration
     */
    select?: SystemIntegrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemIntegration
     */
    omit?: SystemIntegrationOmit<ExtArgs> | null
    /**
     * The data used to create many SystemIntegrations.
     */
    data: SystemIntegrationCreateManyInput | SystemIntegrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemIntegration update
   */
  export type SystemIntegrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemIntegration
     */
    select?: SystemIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemIntegration
     */
    omit?: SystemIntegrationOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemIntegration.
     */
    data: XOR<SystemIntegrationUpdateInput, SystemIntegrationUncheckedUpdateInput>
    /**
     * Choose, which SystemIntegration to update.
     */
    where: SystemIntegrationWhereUniqueInput
  }

  /**
   * SystemIntegration updateMany
   */
  export type SystemIntegrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemIntegrations.
     */
    data: XOR<SystemIntegrationUpdateManyMutationInput, SystemIntegrationUncheckedUpdateManyInput>
    /**
     * Filter which SystemIntegrations to update
     */
    where?: SystemIntegrationWhereInput
    /**
     * Limit how many SystemIntegrations to update.
     */
    limit?: number
  }

  /**
   * SystemIntegration updateManyAndReturn
   */
  export type SystemIntegrationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemIntegration
     */
    select?: SystemIntegrationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemIntegration
     */
    omit?: SystemIntegrationOmit<ExtArgs> | null
    /**
     * The data used to update SystemIntegrations.
     */
    data: XOR<SystemIntegrationUpdateManyMutationInput, SystemIntegrationUncheckedUpdateManyInput>
    /**
     * Filter which SystemIntegrations to update
     */
    where?: SystemIntegrationWhereInput
    /**
     * Limit how many SystemIntegrations to update.
     */
    limit?: number
  }

  /**
   * SystemIntegration upsert
   */
  export type SystemIntegrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemIntegration
     */
    select?: SystemIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemIntegration
     */
    omit?: SystemIntegrationOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemIntegration to update in case it exists.
     */
    where: SystemIntegrationWhereUniqueInput
    /**
     * In case the SystemIntegration found by the `where` argument doesn't exist, create a new SystemIntegration with this data.
     */
    create: XOR<SystemIntegrationCreateInput, SystemIntegrationUncheckedCreateInput>
    /**
     * In case the SystemIntegration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemIntegrationUpdateInput, SystemIntegrationUncheckedUpdateInput>
  }

  /**
   * SystemIntegration delete
   */
  export type SystemIntegrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemIntegration
     */
    select?: SystemIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemIntegration
     */
    omit?: SystemIntegrationOmit<ExtArgs> | null
    /**
     * Filter which SystemIntegration to delete.
     */
    where: SystemIntegrationWhereUniqueInput
  }

  /**
   * SystemIntegration deleteMany
   */
  export type SystemIntegrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemIntegrations to delete
     */
    where?: SystemIntegrationWhereInput
    /**
     * Limit how many SystemIntegrations to delete.
     */
    limit?: number
  }

  /**
   * SystemIntegration without action
   */
  export type SystemIntegrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemIntegration
     */
    select?: SystemIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemIntegration
     */
    omit?: SystemIntegrationOmit<ExtArgs> | null
  }


  /**
   * Model AutomationWorkflow
   */

  export type AggregateAutomationWorkflow = {
    _count: AutomationWorkflowCountAggregateOutputType | null
    _avg: AutomationWorkflowAvgAggregateOutputType | null
    _sum: AutomationWorkflowSumAggregateOutputType | null
    _min: AutomationWorkflowMinAggregateOutputType | null
    _max: AutomationWorkflowMaxAggregateOutputType | null
  }

  export type AutomationWorkflowAvgAggregateOutputType = {
    successCount: number | null
    failureCount: number | null
  }

  export type AutomationWorkflowSumAggregateOutputType = {
    successCount: number | null
    failureCount: number | null
  }

  export type AutomationWorkflowMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: string | null
    status: string | null
    priority: string | null
    trigger: string | null
    schedule: string | null
    successCount: number | null
    failureCount: number | null
    lastRun: Date | null
    nextRun: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AutomationWorkflowMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: string | null
    status: string | null
    priority: string | null
    trigger: string | null
    schedule: string | null
    successCount: number | null
    failureCount: number | null
    lastRun: Date | null
    nextRun: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AutomationWorkflowCountAggregateOutputType = {
    id: number
    name: number
    description: number
    category: number
    status: number
    priority: number
    trigger: number
    schedule: number
    config: number
    successCount: number
    failureCount: number
    lastRun: number
    nextRun: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AutomationWorkflowAvgAggregateInputType = {
    successCount?: true
    failureCount?: true
  }

  export type AutomationWorkflowSumAggregateInputType = {
    successCount?: true
    failureCount?: true
  }

  export type AutomationWorkflowMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    status?: true
    priority?: true
    trigger?: true
    schedule?: true
    successCount?: true
    failureCount?: true
    lastRun?: true
    nextRun?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AutomationWorkflowMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    status?: true
    priority?: true
    trigger?: true
    schedule?: true
    successCount?: true
    failureCount?: true
    lastRun?: true
    nextRun?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AutomationWorkflowCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    status?: true
    priority?: true
    trigger?: true
    schedule?: true
    config?: true
    successCount?: true
    failureCount?: true
    lastRun?: true
    nextRun?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AutomationWorkflowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutomationWorkflow to aggregate.
     */
    where?: AutomationWorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationWorkflows to fetch.
     */
    orderBy?: AutomationWorkflowOrderByWithRelationInput | AutomationWorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutomationWorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationWorkflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationWorkflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AutomationWorkflows
    **/
    _count?: true | AutomationWorkflowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AutomationWorkflowAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AutomationWorkflowSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutomationWorkflowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutomationWorkflowMaxAggregateInputType
  }

  export type GetAutomationWorkflowAggregateType<T extends AutomationWorkflowAggregateArgs> = {
        [P in keyof T & keyof AggregateAutomationWorkflow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutomationWorkflow[P]>
      : GetScalarType<T[P], AggregateAutomationWorkflow[P]>
  }




  export type AutomationWorkflowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationWorkflowWhereInput
    orderBy?: AutomationWorkflowOrderByWithAggregationInput | AutomationWorkflowOrderByWithAggregationInput[]
    by: AutomationWorkflowScalarFieldEnum[] | AutomationWorkflowScalarFieldEnum
    having?: AutomationWorkflowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutomationWorkflowCountAggregateInputType | true
    _avg?: AutomationWorkflowAvgAggregateInputType
    _sum?: AutomationWorkflowSumAggregateInputType
    _min?: AutomationWorkflowMinAggregateInputType
    _max?: AutomationWorkflowMaxAggregateInputType
  }

  export type AutomationWorkflowGroupByOutputType = {
    id: string
    name: string
    description: string | null
    category: string
    status: string
    priority: string
    trigger: string
    schedule: string | null
    config: JsonValue | null
    successCount: number
    failureCount: number
    lastRun: Date | null
    nextRun: Date | null
    createdAt: Date
    updatedAt: Date
    _count: AutomationWorkflowCountAggregateOutputType | null
    _avg: AutomationWorkflowAvgAggregateOutputType | null
    _sum: AutomationWorkflowSumAggregateOutputType | null
    _min: AutomationWorkflowMinAggregateOutputType | null
    _max: AutomationWorkflowMaxAggregateOutputType | null
  }

  type GetAutomationWorkflowGroupByPayload<T extends AutomationWorkflowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutomationWorkflowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutomationWorkflowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutomationWorkflowGroupByOutputType[P]>
            : GetScalarType<T[P], AutomationWorkflowGroupByOutputType[P]>
        }
      >
    >


  export type AutomationWorkflowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    status?: boolean
    priority?: boolean
    trigger?: boolean
    schedule?: boolean
    config?: boolean
    successCount?: boolean
    failureCount?: boolean
    lastRun?: boolean
    nextRun?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["automationWorkflow"]>

  export type AutomationWorkflowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    status?: boolean
    priority?: boolean
    trigger?: boolean
    schedule?: boolean
    config?: boolean
    successCount?: boolean
    failureCount?: boolean
    lastRun?: boolean
    nextRun?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["automationWorkflow"]>

  export type AutomationWorkflowSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    status?: boolean
    priority?: boolean
    trigger?: boolean
    schedule?: boolean
    config?: boolean
    successCount?: boolean
    failureCount?: boolean
    lastRun?: boolean
    nextRun?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["automationWorkflow"]>

  export type AutomationWorkflowSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    status?: boolean
    priority?: boolean
    trigger?: boolean
    schedule?: boolean
    config?: boolean
    successCount?: boolean
    failureCount?: boolean
    lastRun?: boolean
    nextRun?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AutomationWorkflowOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "category" | "status" | "priority" | "trigger" | "schedule" | "config" | "successCount" | "failureCount" | "lastRun" | "nextRun" | "createdAt" | "updatedAt", ExtArgs["result"]["automationWorkflow"]>

  export type $AutomationWorkflowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AutomationWorkflow"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      category: string
      status: string
      priority: string
      trigger: string
      schedule: string | null
      config: Prisma.JsonValue | null
      successCount: number
      failureCount: number
      lastRun: Date | null
      nextRun: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["automationWorkflow"]>
    composites: {}
  }

  type AutomationWorkflowGetPayload<S extends boolean | null | undefined | AutomationWorkflowDefaultArgs> = $Result.GetResult<Prisma.$AutomationWorkflowPayload, S>

  type AutomationWorkflowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AutomationWorkflowFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AutomationWorkflowCountAggregateInputType | true
    }

  export interface AutomationWorkflowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AutomationWorkflow'], meta: { name: 'AutomationWorkflow' } }
    /**
     * Find zero or one AutomationWorkflow that matches the filter.
     * @param {AutomationWorkflowFindUniqueArgs} args - Arguments to find a AutomationWorkflow
     * @example
     * // Get one AutomationWorkflow
     * const automationWorkflow = await prisma.automationWorkflow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AutomationWorkflowFindUniqueArgs>(args: SelectSubset<T, AutomationWorkflowFindUniqueArgs<ExtArgs>>): Prisma__AutomationWorkflowClient<$Result.GetResult<Prisma.$AutomationWorkflowPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AutomationWorkflow that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AutomationWorkflowFindUniqueOrThrowArgs} args - Arguments to find a AutomationWorkflow
     * @example
     * // Get one AutomationWorkflow
     * const automationWorkflow = await prisma.automationWorkflow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AutomationWorkflowFindUniqueOrThrowArgs>(args: SelectSubset<T, AutomationWorkflowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AutomationWorkflowClient<$Result.GetResult<Prisma.$AutomationWorkflowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AutomationWorkflow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationWorkflowFindFirstArgs} args - Arguments to find a AutomationWorkflow
     * @example
     * // Get one AutomationWorkflow
     * const automationWorkflow = await prisma.automationWorkflow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AutomationWorkflowFindFirstArgs>(args?: SelectSubset<T, AutomationWorkflowFindFirstArgs<ExtArgs>>): Prisma__AutomationWorkflowClient<$Result.GetResult<Prisma.$AutomationWorkflowPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AutomationWorkflow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationWorkflowFindFirstOrThrowArgs} args - Arguments to find a AutomationWorkflow
     * @example
     * // Get one AutomationWorkflow
     * const automationWorkflow = await prisma.automationWorkflow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AutomationWorkflowFindFirstOrThrowArgs>(args?: SelectSubset<T, AutomationWorkflowFindFirstOrThrowArgs<ExtArgs>>): Prisma__AutomationWorkflowClient<$Result.GetResult<Prisma.$AutomationWorkflowPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AutomationWorkflows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationWorkflowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AutomationWorkflows
     * const automationWorkflows = await prisma.automationWorkflow.findMany()
     * 
     * // Get first 10 AutomationWorkflows
     * const automationWorkflows = await prisma.automationWorkflow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const automationWorkflowWithIdOnly = await prisma.automationWorkflow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AutomationWorkflowFindManyArgs>(args?: SelectSubset<T, AutomationWorkflowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationWorkflowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AutomationWorkflow.
     * @param {AutomationWorkflowCreateArgs} args - Arguments to create a AutomationWorkflow.
     * @example
     * // Create one AutomationWorkflow
     * const AutomationWorkflow = await prisma.automationWorkflow.create({
     *   data: {
     *     // ... data to create a AutomationWorkflow
     *   }
     * })
     * 
     */
    create<T extends AutomationWorkflowCreateArgs>(args: SelectSubset<T, AutomationWorkflowCreateArgs<ExtArgs>>): Prisma__AutomationWorkflowClient<$Result.GetResult<Prisma.$AutomationWorkflowPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AutomationWorkflows.
     * @param {AutomationWorkflowCreateManyArgs} args - Arguments to create many AutomationWorkflows.
     * @example
     * // Create many AutomationWorkflows
     * const automationWorkflow = await prisma.automationWorkflow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AutomationWorkflowCreateManyArgs>(args?: SelectSubset<T, AutomationWorkflowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AutomationWorkflows and returns the data saved in the database.
     * @param {AutomationWorkflowCreateManyAndReturnArgs} args - Arguments to create many AutomationWorkflows.
     * @example
     * // Create many AutomationWorkflows
     * const automationWorkflow = await prisma.automationWorkflow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AutomationWorkflows and only return the `id`
     * const automationWorkflowWithIdOnly = await prisma.automationWorkflow.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AutomationWorkflowCreateManyAndReturnArgs>(args?: SelectSubset<T, AutomationWorkflowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationWorkflowPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AutomationWorkflow.
     * @param {AutomationWorkflowDeleteArgs} args - Arguments to delete one AutomationWorkflow.
     * @example
     * // Delete one AutomationWorkflow
     * const AutomationWorkflow = await prisma.automationWorkflow.delete({
     *   where: {
     *     // ... filter to delete one AutomationWorkflow
     *   }
     * })
     * 
     */
    delete<T extends AutomationWorkflowDeleteArgs>(args: SelectSubset<T, AutomationWorkflowDeleteArgs<ExtArgs>>): Prisma__AutomationWorkflowClient<$Result.GetResult<Prisma.$AutomationWorkflowPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AutomationWorkflow.
     * @param {AutomationWorkflowUpdateArgs} args - Arguments to update one AutomationWorkflow.
     * @example
     * // Update one AutomationWorkflow
     * const automationWorkflow = await prisma.automationWorkflow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AutomationWorkflowUpdateArgs>(args: SelectSubset<T, AutomationWorkflowUpdateArgs<ExtArgs>>): Prisma__AutomationWorkflowClient<$Result.GetResult<Prisma.$AutomationWorkflowPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AutomationWorkflows.
     * @param {AutomationWorkflowDeleteManyArgs} args - Arguments to filter AutomationWorkflows to delete.
     * @example
     * // Delete a few AutomationWorkflows
     * const { count } = await prisma.automationWorkflow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AutomationWorkflowDeleteManyArgs>(args?: SelectSubset<T, AutomationWorkflowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutomationWorkflows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationWorkflowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AutomationWorkflows
     * const automationWorkflow = await prisma.automationWorkflow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AutomationWorkflowUpdateManyArgs>(args: SelectSubset<T, AutomationWorkflowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutomationWorkflows and returns the data updated in the database.
     * @param {AutomationWorkflowUpdateManyAndReturnArgs} args - Arguments to update many AutomationWorkflows.
     * @example
     * // Update many AutomationWorkflows
     * const automationWorkflow = await prisma.automationWorkflow.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AutomationWorkflows and only return the `id`
     * const automationWorkflowWithIdOnly = await prisma.automationWorkflow.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AutomationWorkflowUpdateManyAndReturnArgs>(args: SelectSubset<T, AutomationWorkflowUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationWorkflowPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AutomationWorkflow.
     * @param {AutomationWorkflowUpsertArgs} args - Arguments to update or create a AutomationWorkflow.
     * @example
     * // Update or create a AutomationWorkflow
     * const automationWorkflow = await prisma.automationWorkflow.upsert({
     *   create: {
     *     // ... data to create a AutomationWorkflow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AutomationWorkflow we want to update
     *   }
     * })
     */
    upsert<T extends AutomationWorkflowUpsertArgs>(args: SelectSubset<T, AutomationWorkflowUpsertArgs<ExtArgs>>): Prisma__AutomationWorkflowClient<$Result.GetResult<Prisma.$AutomationWorkflowPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AutomationWorkflows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationWorkflowCountArgs} args - Arguments to filter AutomationWorkflows to count.
     * @example
     * // Count the number of AutomationWorkflows
     * const count = await prisma.automationWorkflow.count({
     *   where: {
     *     // ... the filter for the AutomationWorkflows we want to count
     *   }
     * })
    **/
    count<T extends AutomationWorkflowCountArgs>(
      args?: Subset<T, AutomationWorkflowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutomationWorkflowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AutomationWorkflow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationWorkflowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutomationWorkflowAggregateArgs>(args: Subset<T, AutomationWorkflowAggregateArgs>): Prisma.PrismaPromise<GetAutomationWorkflowAggregateType<T>>

    /**
     * Group by AutomationWorkflow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationWorkflowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutomationWorkflowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutomationWorkflowGroupByArgs['orderBy'] }
        : { orderBy?: AutomationWorkflowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutomationWorkflowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutomationWorkflowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AutomationWorkflow model
   */
  readonly fields: AutomationWorkflowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AutomationWorkflow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AutomationWorkflowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AutomationWorkflow model
   */
  interface AutomationWorkflowFieldRefs {
    readonly id: FieldRef<"AutomationWorkflow", 'String'>
    readonly name: FieldRef<"AutomationWorkflow", 'String'>
    readonly description: FieldRef<"AutomationWorkflow", 'String'>
    readonly category: FieldRef<"AutomationWorkflow", 'String'>
    readonly status: FieldRef<"AutomationWorkflow", 'String'>
    readonly priority: FieldRef<"AutomationWorkflow", 'String'>
    readonly trigger: FieldRef<"AutomationWorkflow", 'String'>
    readonly schedule: FieldRef<"AutomationWorkflow", 'String'>
    readonly config: FieldRef<"AutomationWorkflow", 'Json'>
    readonly successCount: FieldRef<"AutomationWorkflow", 'Int'>
    readonly failureCount: FieldRef<"AutomationWorkflow", 'Int'>
    readonly lastRun: FieldRef<"AutomationWorkflow", 'DateTime'>
    readonly nextRun: FieldRef<"AutomationWorkflow", 'DateTime'>
    readonly createdAt: FieldRef<"AutomationWorkflow", 'DateTime'>
    readonly updatedAt: FieldRef<"AutomationWorkflow", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AutomationWorkflow findUnique
   */
  export type AutomationWorkflowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationWorkflow
     */
    select?: AutomationWorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationWorkflow
     */
    omit?: AutomationWorkflowOmit<ExtArgs> | null
    /**
     * Filter, which AutomationWorkflow to fetch.
     */
    where: AutomationWorkflowWhereUniqueInput
  }

  /**
   * AutomationWorkflow findUniqueOrThrow
   */
  export type AutomationWorkflowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationWorkflow
     */
    select?: AutomationWorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationWorkflow
     */
    omit?: AutomationWorkflowOmit<ExtArgs> | null
    /**
     * Filter, which AutomationWorkflow to fetch.
     */
    where: AutomationWorkflowWhereUniqueInput
  }

  /**
   * AutomationWorkflow findFirst
   */
  export type AutomationWorkflowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationWorkflow
     */
    select?: AutomationWorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationWorkflow
     */
    omit?: AutomationWorkflowOmit<ExtArgs> | null
    /**
     * Filter, which AutomationWorkflow to fetch.
     */
    where?: AutomationWorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationWorkflows to fetch.
     */
    orderBy?: AutomationWorkflowOrderByWithRelationInput | AutomationWorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutomationWorkflows.
     */
    cursor?: AutomationWorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationWorkflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationWorkflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutomationWorkflows.
     */
    distinct?: AutomationWorkflowScalarFieldEnum | AutomationWorkflowScalarFieldEnum[]
  }

  /**
   * AutomationWorkflow findFirstOrThrow
   */
  export type AutomationWorkflowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationWorkflow
     */
    select?: AutomationWorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationWorkflow
     */
    omit?: AutomationWorkflowOmit<ExtArgs> | null
    /**
     * Filter, which AutomationWorkflow to fetch.
     */
    where?: AutomationWorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationWorkflows to fetch.
     */
    orderBy?: AutomationWorkflowOrderByWithRelationInput | AutomationWorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutomationWorkflows.
     */
    cursor?: AutomationWorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationWorkflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationWorkflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutomationWorkflows.
     */
    distinct?: AutomationWorkflowScalarFieldEnum | AutomationWorkflowScalarFieldEnum[]
  }

  /**
   * AutomationWorkflow findMany
   */
  export type AutomationWorkflowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationWorkflow
     */
    select?: AutomationWorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationWorkflow
     */
    omit?: AutomationWorkflowOmit<ExtArgs> | null
    /**
     * Filter, which AutomationWorkflows to fetch.
     */
    where?: AutomationWorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationWorkflows to fetch.
     */
    orderBy?: AutomationWorkflowOrderByWithRelationInput | AutomationWorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AutomationWorkflows.
     */
    cursor?: AutomationWorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationWorkflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationWorkflows.
     */
    skip?: number
    distinct?: AutomationWorkflowScalarFieldEnum | AutomationWorkflowScalarFieldEnum[]
  }

  /**
   * AutomationWorkflow create
   */
  export type AutomationWorkflowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationWorkflow
     */
    select?: AutomationWorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationWorkflow
     */
    omit?: AutomationWorkflowOmit<ExtArgs> | null
    /**
     * The data needed to create a AutomationWorkflow.
     */
    data: XOR<AutomationWorkflowCreateInput, AutomationWorkflowUncheckedCreateInput>
  }

  /**
   * AutomationWorkflow createMany
   */
  export type AutomationWorkflowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AutomationWorkflows.
     */
    data: AutomationWorkflowCreateManyInput | AutomationWorkflowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AutomationWorkflow createManyAndReturn
   */
  export type AutomationWorkflowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationWorkflow
     */
    select?: AutomationWorkflowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationWorkflow
     */
    omit?: AutomationWorkflowOmit<ExtArgs> | null
    /**
     * The data used to create many AutomationWorkflows.
     */
    data: AutomationWorkflowCreateManyInput | AutomationWorkflowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AutomationWorkflow update
   */
  export type AutomationWorkflowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationWorkflow
     */
    select?: AutomationWorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationWorkflow
     */
    omit?: AutomationWorkflowOmit<ExtArgs> | null
    /**
     * The data needed to update a AutomationWorkflow.
     */
    data: XOR<AutomationWorkflowUpdateInput, AutomationWorkflowUncheckedUpdateInput>
    /**
     * Choose, which AutomationWorkflow to update.
     */
    where: AutomationWorkflowWhereUniqueInput
  }

  /**
   * AutomationWorkflow updateMany
   */
  export type AutomationWorkflowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AutomationWorkflows.
     */
    data: XOR<AutomationWorkflowUpdateManyMutationInput, AutomationWorkflowUncheckedUpdateManyInput>
    /**
     * Filter which AutomationWorkflows to update
     */
    where?: AutomationWorkflowWhereInput
    /**
     * Limit how many AutomationWorkflows to update.
     */
    limit?: number
  }

  /**
   * AutomationWorkflow updateManyAndReturn
   */
  export type AutomationWorkflowUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationWorkflow
     */
    select?: AutomationWorkflowSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationWorkflow
     */
    omit?: AutomationWorkflowOmit<ExtArgs> | null
    /**
     * The data used to update AutomationWorkflows.
     */
    data: XOR<AutomationWorkflowUpdateManyMutationInput, AutomationWorkflowUncheckedUpdateManyInput>
    /**
     * Filter which AutomationWorkflows to update
     */
    where?: AutomationWorkflowWhereInput
    /**
     * Limit how many AutomationWorkflows to update.
     */
    limit?: number
  }

  /**
   * AutomationWorkflow upsert
   */
  export type AutomationWorkflowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationWorkflow
     */
    select?: AutomationWorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationWorkflow
     */
    omit?: AutomationWorkflowOmit<ExtArgs> | null
    /**
     * The filter to search for the AutomationWorkflow to update in case it exists.
     */
    where: AutomationWorkflowWhereUniqueInput
    /**
     * In case the AutomationWorkflow found by the `where` argument doesn't exist, create a new AutomationWorkflow with this data.
     */
    create: XOR<AutomationWorkflowCreateInput, AutomationWorkflowUncheckedCreateInput>
    /**
     * In case the AutomationWorkflow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutomationWorkflowUpdateInput, AutomationWorkflowUncheckedUpdateInput>
  }

  /**
   * AutomationWorkflow delete
   */
  export type AutomationWorkflowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationWorkflow
     */
    select?: AutomationWorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationWorkflow
     */
    omit?: AutomationWorkflowOmit<ExtArgs> | null
    /**
     * Filter which AutomationWorkflow to delete.
     */
    where: AutomationWorkflowWhereUniqueInput
  }

  /**
   * AutomationWorkflow deleteMany
   */
  export type AutomationWorkflowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutomationWorkflows to delete
     */
    where?: AutomationWorkflowWhereInput
    /**
     * Limit how many AutomationWorkflows to delete.
     */
    limit?: number
  }

  /**
   * AutomationWorkflow without action
   */
  export type AutomationWorkflowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationWorkflow
     */
    select?: AutomationWorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationWorkflow
     */
    omit?: AutomationWorkflowOmit<ExtArgs> | null
  }


  /**
   * Model DataSyncJob
   */

  export type AggregateDataSyncJob = {
    _count: DataSyncJobCountAggregateOutputType | null
    _avg: DataSyncJobAvgAggregateOutputType | null
    _sum: DataSyncJobSumAggregateOutputType | null
    _min: DataSyncJobMinAggregateOutputType | null
    _max: DataSyncJobMaxAggregateOutputType | null
  }

  export type DataSyncJobAvgAggregateOutputType = {
    processedRecords: number | null
    failedRecords: number | null
    totalRecords: number | null
  }

  export type DataSyncJobSumAggregateOutputType = {
    processedRecords: number | null
    failedRecords: number | null
    totalRecords: number | null
  }

  export type DataSyncJobMinAggregateOutputType = {
    id: string | null
    name: string | null
    source: string | null
    destination: string | null
    status: string | null
    processedRecords: number | null
    failedRecords: number | null
    totalRecords: number | null
    startedAt: Date | null
    completedAt: Date | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DataSyncJobMaxAggregateOutputType = {
    id: string | null
    name: string | null
    source: string | null
    destination: string | null
    status: string | null
    processedRecords: number | null
    failedRecords: number | null
    totalRecords: number | null
    startedAt: Date | null
    completedAt: Date | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DataSyncJobCountAggregateOutputType = {
    id: number
    name: number
    source: number
    destination: number
    status: number
    processedRecords: number
    failedRecords: number
    totalRecords: number
    startedAt: number
    completedAt: number
    errorMessage: number
    config: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DataSyncJobAvgAggregateInputType = {
    processedRecords?: true
    failedRecords?: true
    totalRecords?: true
  }

  export type DataSyncJobSumAggregateInputType = {
    processedRecords?: true
    failedRecords?: true
    totalRecords?: true
  }

  export type DataSyncJobMinAggregateInputType = {
    id?: true
    name?: true
    source?: true
    destination?: true
    status?: true
    processedRecords?: true
    failedRecords?: true
    totalRecords?: true
    startedAt?: true
    completedAt?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DataSyncJobMaxAggregateInputType = {
    id?: true
    name?: true
    source?: true
    destination?: true
    status?: true
    processedRecords?: true
    failedRecords?: true
    totalRecords?: true
    startedAt?: true
    completedAt?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DataSyncJobCountAggregateInputType = {
    id?: true
    name?: true
    source?: true
    destination?: true
    status?: true
    processedRecords?: true
    failedRecords?: true
    totalRecords?: true
    startedAt?: true
    completedAt?: true
    errorMessage?: true
    config?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DataSyncJobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataSyncJob to aggregate.
     */
    where?: DataSyncJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataSyncJobs to fetch.
     */
    orderBy?: DataSyncJobOrderByWithRelationInput | DataSyncJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DataSyncJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataSyncJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataSyncJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DataSyncJobs
    **/
    _count?: true | DataSyncJobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DataSyncJobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DataSyncJobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DataSyncJobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DataSyncJobMaxAggregateInputType
  }

  export type GetDataSyncJobAggregateType<T extends DataSyncJobAggregateArgs> = {
        [P in keyof T & keyof AggregateDataSyncJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDataSyncJob[P]>
      : GetScalarType<T[P], AggregateDataSyncJob[P]>
  }




  export type DataSyncJobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataSyncJobWhereInput
    orderBy?: DataSyncJobOrderByWithAggregationInput | DataSyncJobOrderByWithAggregationInput[]
    by: DataSyncJobScalarFieldEnum[] | DataSyncJobScalarFieldEnum
    having?: DataSyncJobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DataSyncJobCountAggregateInputType | true
    _avg?: DataSyncJobAvgAggregateInputType
    _sum?: DataSyncJobSumAggregateInputType
    _min?: DataSyncJobMinAggregateInputType
    _max?: DataSyncJobMaxAggregateInputType
  }

  export type DataSyncJobGroupByOutputType = {
    id: string
    name: string
    source: string
    destination: string
    status: string
    processedRecords: number
    failedRecords: number
    totalRecords: number
    startedAt: Date | null
    completedAt: Date | null
    errorMessage: string | null
    config: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: DataSyncJobCountAggregateOutputType | null
    _avg: DataSyncJobAvgAggregateOutputType | null
    _sum: DataSyncJobSumAggregateOutputType | null
    _min: DataSyncJobMinAggregateOutputType | null
    _max: DataSyncJobMaxAggregateOutputType | null
  }

  type GetDataSyncJobGroupByPayload<T extends DataSyncJobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DataSyncJobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DataSyncJobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DataSyncJobGroupByOutputType[P]>
            : GetScalarType<T[P], DataSyncJobGroupByOutputType[P]>
        }
      >
    >


  export type DataSyncJobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    source?: boolean
    destination?: boolean
    status?: boolean
    processedRecords?: boolean
    failedRecords?: boolean
    totalRecords?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorMessage?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dataSyncJob"]>

  export type DataSyncJobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    source?: boolean
    destination?: boolean
    status?: boolean
    processedRecords?: boolean
    failedRecords?: boolean
    totalRecords?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorMessage?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dataSyncJob"]>

  export type DataSyncJobSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    source?: boolean
    destination?: boolean
    status?: boolean
    processedRecords?: boolean
    failedRecords?: boolean
    totalRecords?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorMessage?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dataSyncJob"]>

  export type DataSyncJobSelectScalar = {
    id?: boolean
    name?: boolean
    source?: boolean
    destination?: boolean
    status?: boolean
    processedRecords?: boolean
    failedRecords?: boolean
    totalRecords?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorMessage?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DataSyncJobOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "source" | "destination" | "status" | "processedRecords" | "failedRecords" | "totalRecords" | "startedAt" | "completedAt" | "errorMessage" | "config" | "createdAt" | "updatedAt", ExtArgs["result"]["dataSyncJob"]>

  export type $DataSyncJobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DataSyncJob"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      source: string
      destination: string
      status: string
      processedRecords: number
      failedRecords: number
      totalRecords: number
      startedAt: Date | null
      completedAt: Date | null
      errorMessage: string | null
      config: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dataSyncJob"]>
    composites: {}
  }

  type DataSyncJobGetPayload<S extends boolean | null | undefined | DataSyncJobDefaultArgs> = $Result.GetResult<Prisma.$DataSyncJobPayload, S>

  type DataSyncJobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DataSyncJobFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DataSyncJobCountAggregateInputType | true
    }

  export interface DataSyncJobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DataSyncJob'], meta: { name: 'DataSyncJob' } }
    /**
     * Find zero or one DataSyncJob that matches the filter.
     * @param {DataSyncJobFindUniqueArgs} args - Arguments to find a DataSyncJob
     * @example
     * // Get one DataSyncJob
     * const dataSyncJob = await prisma.dataSyncJob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DataSyncJobFindUniqueArgs>(args: SelectSubset<T, DataSyncJobFindUniqueArgs<ExtArgs>>): Prisma__DataSyncJobClient<$Result.GetResult<Prisma.$DataSyncJobPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DataSyncJob that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DataSyncJobFindUniqueOrThrowArgs} args - Arguments to find a DataSyncJob
     * @example
     * // Get one DataSyncJob
     * const dataSyncJob = await prisma.dataSyncJob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DataSyncJobFindUniqueOrThrowArgs>(args: SelectSubset<T, DataSyncJobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DataSyncJobClient<$Result.GetResult<Prisma.$DataSyncJobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DataSyncJob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataSyncJobFindFirstArgs} args - Arguments to find a DataSyncJob
     * @example
     * // Get one DataSyncJob
     * const dataSyncJob = await prisma.dataSyncJob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DataSyncJobFindFirstArgs>(args?: SelectSubset<T, DataSyncJobFindFirstArgs<ExtArgs>>): Prisma__DataSyncJobClient<$Result.GetResult<Prisma.$DataSyncJobPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DataSyncJob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataSyncJobFindFirstOrThrowArgs} args - Arguments to find a DataSyncJob
     * @example
     * // Get one DataSyncJob
     * const dataSyncJob = await prisma.dataSyncJob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DataSyncJobFindFirstOrThrowArgs>(args?: SelectSubset<T, DataSyncJobFindFirstOrThrowArgs<ExtArgs>>): Prisma__DataSyncJobClient<$Result.GetResult<Prisma.$DataSyncJobPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DataSyncJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataSyncJobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DataSyncJobs
     * const dataSyncJobs = await prisma.dataSyncJob.findMany()
     * 
     * // Get first 10 DataSyncJobs
     * const dataSyncJobs = await prisma.dataSyncJob.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dataSyncJobWithIdOnly = await prisma.dataSyncJob.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DataSyncJobFindManyArgs>(args?: SelectSubset<T, DataSyncJobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataSyncJobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DataSyncJob.
     * @param {DataSyncJobCreateArgs} args - Arguments to create a DataSyncJob.
     * @example
     * // Create one DataSyncJob
     * const DataSyncJob = await prisma.dataSyncJob.create({
     *   data: {
     *     // ... data to create a DataSyncJob
     *   }
     * })
     * 
     */
    create<T extends DataSyncJobCreateArgs>(args: SelectSubset<T, DataSyncJobCreateArgs<ExtArgs>>): Prisma__DataSyncJobClient<$Result.GetResult<Prisma.$DataSyncJobPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DataSyncJobs.
     * @param {DataSyncJobCreateManyArgs} args - Arguments to create many DataSyncJobs.
     * @example
     * // Create many DataSyncJobs
     * const dataSyncJob = await prisma.dataSyncJob.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DataSyncJobCreateManyArgs>(args?: SelectSubset<T, DataSyncJobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DataSyncJobs and returns the data saved in the database.
     * @param {DataSyncJobCreateManyAndReturnArgs} args - Arguments to create many DataSyncJobs.
     * @example
     * // Create many DataSyncJobs
     * const dataSyncJob = await prisma.dataSyncJob.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DataSyncJobs and only return the `id`
     * const dataSyncJobWithIdOnly = await prisma.dataSyncJob.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DataSyncJobCreateManyAndReturnArgs>(args?: SelectSubset<T, DataSyncJobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataSyncJobPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DataSyncJob.
     * @param {DataSyncJobDeleteArgs} args - Arguments to delete one DataSyncJob.
     * @example
     * // Delete one DataSyncJob
     * const DataSyncJob = await prisma.dataSyncJob.delete({
     *   where: {
     *     // ... filter to delete one DataSyncJob
     *   }
     * })
     * 
     */
    delete<T extends DataSyncJobDeleteArgs>(args: SelectSubset<T, DataSyncJobDeleteArgs<ExtArgs>>): Prisma__DataSyncJobClient<$Result.GetResult<Prisma.$DataSyncJobPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DataSyncJob.
     * @param {DataSyncJobUpdateArgs} args - Arguments to update one DataSyncJob.
     * @example
     * // Update one DataSyncJob
     * const dataSyncJob = await prisma.dataSyncJob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DataSyncJobUpdateArgs>(args: SelectSubset<T, DataSyncJobUpdateArgs<ExtArgs>>): Prisma__DataSyncJobClient<$Result.GetResult<Prisma.$DataSyncJobPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DataSyncJobs.
     * @param {DataSyncJobDeleteManyArgs} args - Arguments to filter DataSyncJobs to delete.
     * @example
     * // Delete a few DataSyncJobs
     * const { count } = await prisma.dataSyncJob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DataSyncJobDeleteManyArgs>(args?: SelectSubset<T, DataSyncJobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataSyncJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataSyncJobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DataSyncJobs
     * const dataSyncJob = await prisma.dataSyncJob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DataSyncJobUpdateManyArgs>(args: SelectSubset<T, DataSyncJobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataSyncJobs and returns the data updated in the database.
     * @param {DataSyncJobUpdateManyAndReturnArgs} args - Arguments to update many DataSyncJobs.
     * @example
     * // Update many DataSyncJobs
     * const dataSyncJob = await prisma.dataSyncJob.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DataSyncJobs and only return the `id`
     * const dataSyncJobWithIdOnly = await prisma.dataSyncJob.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DataSyncJobUpdateManyAndReturnArgs>(args: SelectSubset<T, DataSyncJobUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataSyncJobPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DataSyncJob.
     * @param {DataSyncJobUpsertArgs} args - Arguments to update or create a DataSyncJob.
     * @example
     * // Update or create a DataSyncJob
     * const dataSyncJob = await prisma.dataSyncJob.upsert({
     *   create: {
     *     // ... data to create a DataSyncJob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DataSyncJob we want to update
     *   }
     * })
     */
    upsert<T extends DataSyncJobUpsertArgs>(args: SelectSubset<T, DataSyncJobUpsertArgs<ExtArgs>>): Prisma__DataSyncJobClient<$Result.GetResult<Prisma.$DataSyncJobPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DataSyncJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataSyncJobCountArgs} args - Arguments to filter DataSyncJobs to count.
     * @example
     * // Count the number of DataSyncJobs
     * const count = await prisma.dataSyncJob.count({
     *   where: {
     *     // ... the filter for the DataSyncJobs we want to count
     *   }
     * })
    **/
    count<T extends DataSyncJobCountArgs>(
      args?: Subset<T, DataSyncJobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DataSyncJobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DataSyncJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataSyncJobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DataSyncJobAggregateArgs>(args: Subset<T, DataSyncJobAggregateArgs>): Prisma.PrismaPromise<GetDataSyncJobAggregateType<T>>

    /**
     * Group by DataSyncJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataSyncJobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DataSyncJobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DataSyncJobGroupByArgs['orderBy'] }
        : { orderBy?: DataSyncJobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DataSyncJobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDataSyncJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DataSyncJob model
   */
  readonly fields: DataSyncJobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DataSyncJob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DataSyncJobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DataSyncJob model
   */
  interface DataSyncJobFieldRefs {
    readonly id: FieldRef<"DataSyncJob", 'String'>
    readonly name: FieldRef<"DataSyncJob", 'String'>
    readonly source: FieldRef<"DataSyncJob", 'String'>
    readonly destination: FieldRef<"DataSyncJob", 'String'>
    readonly status: FieldRef<"DataSyncJob", 'String'>
    readonly processedRecords: FieldRef<"DataSyncJob", 'Int'>
    readonly failedRecords: FieldRef<"DataSyncJob", 'Int'>
    readonly totalRecords: FieldRef<"DataSyncJob", 'Int'>
    readonly startedAt: FieldRef<"DataSyncJob", 'DateTime'>
    readonly completedAt: FieldRef<"DataSyncJob", 'DateTime'>
    readonly errorMessage: FieldRef<"DataSyncJob", 'String'>
    readonly config: FieldRef<"DataSyncJob", 'Json'>
    readonly createdAt: FieldRef<"DataSyncJob", 'DateTime'>
    readonly updatedAt: FieldRef<"DataSyncJob", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DataSyncJob findUnique
   */
  export type DataSyncJobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSyncJob
     */
    select?: DataSyncJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSyncJob
     */
    omit?: DataSyncJobOmit<ExtArgs> | null
    /**
     * Filter, which DataSyncJob to fetch.
     */
    where: DataSyncJobWhereUniqueInput
  }

  /**
   * DataSyncJob findUniqueOrThrow
   */
  export type DataSyncJobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSyncJob
     */
    select?: DataSyncJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSyncJob
     */
    omit?: DataSyncJobOmit<ExtArgs> | null
    /**
     * Filter, which DataSyncJob to fetch.
     */
    where: DataSyncJobWhereUniqueInput
  }

  /**
   * DataSyncJob findFirst
   */
  export type DataSyncJobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSyncJob
     */
    select?: DataSyncJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSyncJob
     */
    omit?: DataSyncJobOmit<ExtArgs> | null
    /**
     * Filter, which DataSyncJob to fetch.
     */
    where?: DataSyncJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataSyncJobs to fetch.
     */
    orderBy?: DataSyncJobOrderByWithRelationInput | DataSyncJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataSyncJobs.
     */
    cursor?: DataSyncJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataSyncJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataSyncJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataSyncJobs.
     */
    distinct?: DataSyncJobScalarFieldEnum | DataSyncJobScalarFieldEnum[]
  }

  /**
   * DataSyncJob findFirstOrThrow
   */
  export type DataSyncJobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSyncJob
     */
    select?: DataSyncJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSyncJob
     */
    omit?: DataSyncJobOmit<ExtArgs> | null
    /**
     * Filter, which DataSyncJob to fetch.
     */
    where?: DataSyncJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataSyncJobs to fetch.
     */
    orderBy?: DataSyncJobOrderByWithRelationInput | DataSyncJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataSyncJobs.
     */
    cursor?: DataSyncJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataSyncJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataSyncJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataSyncJobs.
     */
    distinct?: DataSyncJobScalarFieldEnum | DataSyncJobScalarFieldEnum[]
  }

  /**
   * DataSyncJob findMany
   */
  export type DataSyncJobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSyncJob
     */
    select?: DataSyncJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSyncJob
     */
    omit?: DataSyncJobOmit<ExtArgs> | null
    /**
     * Filter, which DataSyncJobs to fetch.
     */
    where?: DataSyncJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataSyncJobs to fetch.
     */
    orderBy?: DataSyncJobOrderByWithRelationInput | DataSyncJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DataSyncJobs.
     */
    cursor?: DataSyncJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataSyncJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataSyncJobs.
     */
    skip?: number
    distinct?: DataSyncJobScalarFieldEnum | DataSyncJobScalarFieldEnum[]
  }

  /**
   * DataSyncJob create
   */
  export type DataSyncJobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSyncJob
     */
    select?: DataSyncJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSyncJob
     */
    omit?: DataSyncJobOmit<ExtArgs> | null
    /**
     * The data needed to create a DataSyncJob.
     */
    data: XOR<DataSyncJobCreateInput, DataSyncJobUncheckedCreateInput>
  }

  /**
   * DataSyncJob createMany
   */
  export type DataSyncJobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DataSyncJobs.
     */
    data: DataSyncJobCreateManyInput | DataSyncJobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DataSyncJob createManyAndReturn
   */
  export type DataSyncJobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSyncJob
     */
    select?: DataSyncJobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DataSyncJob
     */
    omit?: DataSyncJobOmit<ExtArgs> | null
    /**
     * The data used to create many DataSyncJobs.
     */
    data: DataSyncJobCreateManyInput | DataSyncJobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DataSyncJob update
   */
  export type DataSyncJobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSyncJob
     */
    select?: DataSyncJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSyncJob
     */
    omit?: DataSyncJobOmit<ExtArgs> | null
    /**
     * The data needed to update a DataSyncJob.
     */
    data: XOR<DataSyncJobUpdateInput, DataSyncJobUncheckedUpdateInput>
    /**
     * Choose, which DataSyncJob to update.
     */
    where: DataSyncJobWhereUniqueInput
  }

  /**
   * DataSyncJob updateMany
   */
  export type DataSyncJobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DataSyncJobs.
     */
    data: XOR<DataSyncJobUpdateManyMutationInput, DataSyncJobUncheckedUpdateManyInput>
    /**
     * Filter which DataSyncJobs to update
     */
    where?: DataSyncJobWhereInput
    /**
     * Limit how many DataSyncJobs to update.
     */
    limit?: number
  }

  /**
   * DataSyncJob updateManyAndReturn
   */
  export type DataSyncJobUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSyncJob
     */
    select?: DataSyncJobSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DataSyncJob
     */
    omit?: DataSyncJobOmit<ExtArgs> | null
    /**
     * The data used to update DataSyncJobs.
     */
    data: XOR<DataSyncJobUpdateManyMutationInput, DataSyncJobUncheckedUpdateManyInput>
    /**
     * Filter which DataSyncJobs to update
     */
    where?: DataSyncJobWhereInput
    /**
     * Limit how many DataSyncJobs to update.
     */
    limit?: number
  }

  /**
   * DataSyncJob upsert
   */
  export type DataSyncJobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSyncJob
     */
    select?: DataSyncJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSyncJob
     */
    omit?: DataSyncJobOmit<ExtArgs> | null
    /**
     * The filter to search for the DataSyncJob to update in case it exists.
     */
    where: DataSyncJobWhereUniqueInput
    /**
     * In case the DataSyncJob found by the `where` argument doesn't exist, create a new DataSyncJob with this data.
     */
    create: XOR<DataSyncJobCreateInput, DataSyncJobUncheckedCreateInput>
    /**
     * In case the DataSyncJob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DataSyncJobUpdateInput, DataSyncJobUncheckedUpdateInput>
  }

  /**
   * DataSyncJob delete
   */
  export type DataSyncJobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSyncJob
     */
    select?: DataSyncJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSyncJob
     */
    omit?: DataSyncJobOmit<ExtArgs> | null
    /**
     * Filter which DataSyncJob to delete.
     */
    where: DataSyncJobWhereUniqueInput
  }

  /**
   * DataSyncJob deleteMany
   */
  export type DataSyncJobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataSyncJobs to delete
     */
    where?: DataSyncJobWhereInput
    /**
     * Limit how many DataSyncJobs to delete.
     */
    limit?: number
  }

  /**
   * DataSyncJob without action
   */
  export type DataSyncJobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataSyncJob
     */
    select?: DataSyncJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataSyncJob
     */
    omit?: DataSyncJobOmit<ExtArgs> | null
  }


  /**
   * Model WebhookEndpoint
   */

  export type AggregateWebhookEndpoint = {
    _count: WebhookEndpointCountAggregateOutputType | null
    _avg: WebhookEndpointAvgAggregateOutputType | null
    _sum: WebhookEndpointSumAggregateOutputType | null
    _min: WebhookEndpointMinAggregateOutputType | null
    _max: WebhookEndpointMaxAggregateOutputType | null
  }

  export type WebhookEndpointAvgAggregateOutputType = {
    successCount: number | null
    failureCount: number | null
  }

  export type WebhookEndpointSumAggregateOutputType = {
    successCount: number | null
    failureCount: number | null
  }

  export type WebhookEndpointMinAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    method: string | null
    isActive: boolean | null
    secret: string | null
    lastTriggered: Date | null
    successCount: number | null
    failureCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebhookEndpointMaxAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    method: string | null
    isActive: boolean | null
    secret: string | null
    lastTriggered: Date | null
    successCount: number | null
    failureCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebhookEndpointCountAggregateOutputType = {
    id: number
    name: number
    url: number
    method: number
    headers: number
    events: number
    isActive: number
    secret: number
    lastTriggered: number
    successCount: number
    failureCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WebhookEndpointAvgAggregateInputType = {
    successCount?: true
    failureCount?: true
  }

  export type WebhookEndpointSumAggregateInputType = {
    successCount?: true
    failureCount?: true
  }

  export type WebhookEndpointMinAggregateInputType = {
    id?: true
    name?: true
    url?: true
    method?: true
    isActive?: true
    secret?: true
    lastTriggered?: true
    successCount?: true
    failureCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebhookEndpointMaxAggregateInputType = {
    id?: true
    name?: true
    url?: true
    method?: true
    isActive?: true
    secret?: true
    lastTriggered?: true
    successCount?: true
    failureCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebhookEndpointCountAggregateInputType = {
    id?: true
    name?: true
    url?: true
    method?: true
    headers?: true
    events?: true
    isActive?: true
    secret?: true
    lastTriggered?: true
    successCount?: true
    failureCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WebhookEndpointAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookEndpoint to aggregate.
     */
    where?: WebhookEndpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEndpoints to fetch.
     */
    orderBy?: WebhookEndpointOrderByWithRelationInput | WebhookEndpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebhookEndpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEndpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEndpoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WebhookEndpoints
    **/
    _count?: true | WebhookEndpointCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WebhookEndpointAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WebhookEndpointSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookEndpointMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookEndpointMaxAggregateInputType
  }

  export type GetWebhookEndpointAggregateType<T extends WebhookEndpointAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhookEndpoint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhookEndpoint[P]>
      : GetScalarType<T[P], AggregateWebhookEndpoint[P]>
  }




  export type WebhookEndpointGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookEndpointWhereInput
    orderBy?: WebhookEndpointOrderByWithAggregationInput | WebhookEndpointOrderByWithAggregationInput[]
    by: WebhookEndpointScalarFieldEnum[] | WebhookEndpointScalarFieldEnum
    having?: WebhookEndpointScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookEndpointCountAggregateInputType | true
    _avg?: WebhookEndpointAvgAggregateInputType
    _sum?: WebhookEndpointSumAggregateInputType
    _min?: WebhookEndpointMinAggregateInputType
    _max?: WebhookEndpointMaxAggregateInputType
  }

  export type WebhookEndpointGroupByOutputType = {
    id: string
    name: string
    url: string
    method: string
    headers: JsonValue | null
    events: string[]
    isActive: boolean
    secret: string | null
    lastTriggered: Date | null
    successCount: number
    failureCount: number
    createdAt: Date
    updatedAt: Date
    _count: WebhookEndpointCountAggregateOutputType | null
    _avg: WebhookEndpointAvgAggregateOutputType | null
    _sum: WebhookEndpointSumAggregateOutputType | null
    _min: WebhookEndpointMinAggregateOutputType | null
    _max: WebhookEndpointMaxAggregateOutputType | null
  }

  type GetWebhookEndpointGroupByPayload<T extends WebhookEndpointGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookEndpointGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookEndpointGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookEndpointGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookEndpointGroupByOutputType[P]>
        }
      >
    >


  export type WebhookEndpointSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    method?: boolean
    headers?: boolean
    events?: boolean
    isActive?: boolean
    secret?: boolean
    lastTriggered?: boolean
    successCount?: boolean
    failureCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["webhookEndpoint"]>

  export type WebhookEndpointSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    method?: boolean
    headers?: boolean
    events?: boolean
    isActive?: boolean
    secret?: boolean
    lastTriggered?: boolean
    successCount?: boolean
    failureCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["webhookEndpoint"]>

  export type WebhookEndpointSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    method?: boolean
    headers?: boolean
    events?: boolean
    isActive?: boolean
    secret?: boolean
    lastTriggered?: boolean
    successCount?: boolean
    failureCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["webhookEndpoint"]>

  export type WebhookEndpointSelectScalar = {
    id?: boolean
    name?: boolean
    url?: boolean
    method?: boolean
    headers?: boolean
    events?: boolean
    isActive?: boolean
    secret?: boolean
    lastTriggered?: boolean
    successCount?: boolean
    failureCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WebhookEndpointOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "url" | "method" | "headers" | "events" | "isActive" | "secret" | "lastTriggered" | "successCount" | "failureCount" | "createdAt" | "updatedAt", ExtArgs["result"]["webhookEndpoint"]>

  export type $WebhookEndpointPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WebhookEndpoint"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      url: string
      method: string
      headers: Prisma.JsonValue | null
      events: string[]
      isActive: boolean
      secret: string | null
      lastTriggered: Date | null
      successCount: number
      failureCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["webhookEndpoint"]>
    composites: {}
  }

  type WebhookEndpointGetPayload<S extends boolean | null | undefined | WebhookEndpointDefaultArgs> = $Result.GetResult<Prisma.$WebhookEndpointPayload, S>

  type WebhookEndpointCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WebhookEndpointFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WebhookEndpointCountAggregateInputType | true
    }

  export interface WebhookEndpointDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WebhookEndpoint'], meta: { name: 'WebhookEndpoint' } }
    /**
     * Find zero or one WebhookEndpoint that matches the filter.
     * @param {WebhookEndpointFindUniqueArgs} args - Arguments to find a WebhookEndpoint
     * @example
     * // Get one WebhookEndpoint
     * const webhookEndpoint = await prisma.webhookEndpoint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebhookEndpointFindUniqueArgs>(args: SelectSubset<T, WebhookEndpointFindUniqueArgs<ExtArgs>>): Prisma__WebhookEndpointClient<$Result.GetResult<Prisma.$WebhookEndpointPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WebhookEndpoint that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WebhookEndpointFindUniqueOrThrowArgs} args - Arguments to find a WebhookEndpoint
     * @example
     * // Get one WebhookEndpoint
     * const webhookEndpoint = await prisma.webhookEndpoint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebhookEndpointFindUniqueOrThrowArgs>(args: SelectSubset<T, WebhookEndpointFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebhookEndpointClient<$Result.GetResult<Prisma.$WebhookEndpointPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebhookEndpoint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEndpointFindFirstArgs} args - Arguments to find a WebhookEndpoint
     * @example
     * // Get one WebhookEndpoint
     * const webhookEndpoint = await prisma.webhookEndpoint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebhookEndpointFindFirstArgs>(args?: SelectSubset<T, WebhookEndpointFindFirstArgs<ExtArgs>>): Prisma__WebhookEndpointClient<$Result.GetResult<Prisma.$WebhookEndpointPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebhookEndpoint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEndpointFindFirstOrThrowArgs} args - Arguments to find a WebhookEndpoint
     * @example
     * // Get one WebhookEndpoint
     * const webhookEndpoint = await prisma.webhookEndpoint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebhookEndpointFindFirstOrThrowArgs>(args?: SelectSubset<T, WebhookEndpointFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebhookEndpointClient<$Result.GetResult<Prisma.$WebhookEndpointPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WebhookEndpoints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEndpointFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebhookEndpoints
     * const webhookEndpoints = await prisma.webhookEndpoint.findMany()
     * 
     * // Get first 10 WebhookEndpoints
     * const webhookEndpoints = await prisma.webhookEndpoint.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookEndpointWithIdOnly = await prisma.webhookEndpoint.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebhookEndpointFindManyArgs>(args?: SelectSubset<T, WebhookEndpointFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookEndpointPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WebhookEndpoint.
     * @param {WebhookEndpointCreateArgs} args - Arguments to create a WebhookEndpoint.
     * @example
     * // Create one WebhookEndpoint
     * const WebhookEndpoint = await prisma.webhookEndpoint.create({
     *   data: {
     *     // ... data to create a WebhookEndpoint
     *   }
     * })
     * 
     */
    create<T extends WebhookEndpointCreateArgs>(args: SelectSubset<T, WebhookEndpointCreateArgs<ExtArgs>>): Prisma__WebhookEndpointClient<$Result.GetResult<Prisma.$WebhookEndpointPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WebhookEndpoints.
     * @param {WebhookEndpointCreateManyArgs} args - Arguments to create many WebhookEndpoints.
     * @example
     * // Create many WebhookEndpoints
     * const webhookEndpoint = await prisma.webhookEndpoint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebhookEndpointCreateManyArgs>(args?: SelectSubset<T, WebhookEndpointCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WebhookEndpoints and returns the data saved in the database.
     * @param {WebhookEndpointCreateManyAndReturnArgs} args - Arguments to create many WebhookEndpoints.
     * @example
     * // Create many WebhookEndpoints
     * const webhookEndpoint = await prisma.webhookEndpoint.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WebhookEndpoints and only return the `id`
     * const webhookEndpointWithIdOnly = await prisma.webhookEndpoint.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebhookEndpointCreateManyAndReturnArgs>(args?: SelectSubset<T, WebhookEndpointCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookEndpointPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WebhookEndpoint.
     * @param {WebhookEndpointDeleteArgs} args - Arguments to delete one WebhookEndpoint.
     * @example
     * // Delete one WebhookEndpoint
     * const WebhookEndpoint = await prisma.webhookEndpoint.delete({
     *   where: {
     *     // ... filter to delete one WebhookEndpoint
     *   }
     * })
     * 
     */
    delete<T extends WebhookEndpointDeleteArgs>(args: SelectSubset<T, WebhookEndpointDeleteArgs<ExtArgs>>): Prisma__WebhookEndpointClient<$Result.GetResult<Prisma.$WebhookEndpointPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WebhookEndpoint.
     * @param {WebhookEndpointUpdateArgs} args - Arguments to update one WebhookEndpoint.
     * @example
     * // Update one WebhookEndpoint
     * const webhookEndpoint = await prisma.webhookEndpoint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebhookEndpointUpdateArgs>(args: SelectSubset<T, WebhookEndpointUpdateArgs<ExtArgs>>): Prisma__WebhookEndpointClient<$Result.GetResult<Prisma.$WebhookEndpointPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WebhookEndpoints.
     * @param {WebhookEndpointDeleteManyArgs} args - Arguments to filter WebhookEndpoints to delete.
     * @example
     * // Delete a few WebhookEndpoints
     * const { count } = await prisma.webhookEndpoint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebhookEndpointDeleteManyArgs>(args?: SelectSubset<T, WebhookEndpointDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookEndpoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEndpointUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebhookEndpoints
     * const webhookEndpoint = await prisma.webhookEndpoint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebhookEndpointUpdateManyArgs>(args: SelectSubset<T, WebhookEndpointUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookEndpoints and returns the data updated in the database.
     * @param {WebhookEndpointUpdateManyAndReturnArgs} args - Arguments to update many WebhookEndpoints.
     * @example
     * // Update many WebhookEndpoints
     * const webhookEndpoint = await prisma.webhookEndpoint.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WebhookEndpoints and only return the `id`
     * const webhookEndpointWithIdOnly = await prisma.webhookEndpoint.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WebhookEndpointUpdateManyAndReturnArgs>(args: SelectSubset<T, WebhookEndpointUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookEndpointPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WebhookEndpoint.
     * @param {WebhookEndpointUpsertArgs} args - Arguments to update or create a WebhookEndpoint.
     * @example
     * // Update or create a WebhookEndpoint
     * const webhookEndpoint = await prisma.webhookEndpoint.upsert({
     *   create: {
     *     // ... data to create a WebhookEndpoint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebhookEndpoint we want to update
     *   }
     * })
     */
    upsert<T extends WebhookEndpointUpsertArgs>(args: SelectSubset<T, WebhookEndpointUpsertArgs<ExtArgs>>): Prisma__WebhookEndpointClient<$Result.GetResult<Prisma.$WebhookEndpointPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WebhookEndpoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEndpointCountArgs} args - Arguments to filter WebhookEndpoints to count.
     * @example
     * // Count the number of WebhookEndpoints
     * const count = await prisma.webhookEndpoint.count({
     *   where: {
     *     // ... the filter for the WebhookEndpoints we want to count
     *   }
     * })
    **/
    count<T extends WebhookEndpointCountArgs>(
      args?: Subset<T, WebhookEndpointCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookEndpointCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebhookEndpoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEndpointAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookEndpointAggregateArgs>(args: Subset<T, WebhookEndpointAggregateArgs>): Prisma.PrismaPromise<GetWebhookEndpointAggregateType<T>>

    /**
     * Group by WebhookEndpoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEndpointGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookEndpointGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookEndpointGroupByArgs['orderBy'] }
        : { orderBy?: WebhookEndpointGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookEndpointGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookEndpointGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WebhookEndpoint model
   */
  readonly fields: WebhookEndpointFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WebhookEndpoint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebhookEndpointClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WebhookEndpoint model
   */
  interface WebhookEndpointFieldRefs {
    readonly id: FieldRef<"WebhookEndpoint", 'String'>
    readonly name: FieldRef<"WebhookEndpoint", 'String'>
    readonly url: FieldRef<"WebhookEndpoint", 'String'>
    readonly method: FieldRef<"WebhookEndpoint", 'String'>
    readonly headers: FieldRef<"WebhookEndpoint", 'Json'>
    readonly events: FieldRef<"WebhookEndpoint", 'String[]'>
    readonly isActive: FieldRef<"WebhookEndpoint", 'Boolean'>
    readonly secret: FieldRef<"WebhookEndpoint", 'String'>
    readonly lastTriggered: FieldRef<"WebhookEndpoint", 'DateTime'>
    readonly successCount: FieldRef<"WebhookEndpoint", 'Int'>
    readonly failureCount: FieldRef<"WebhookEndpoint", 'Int'>
    readonly createdAt: FieldRef<"WebhookEndpoint", 'DateTime'>
    readonly updatedAt: FieldRef<"WebhookEndpoint", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WebhookEndpoint findUnique
   */
  export type WebhookEndpointFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEndpoint
     */
    select?: WebhookEndpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEndpoint
     */
    omit?: WebhookEndpointOmit<ExtArgs> | null
    /**
     * Filter, which WebhookEndpoint to fetch.
     */
    where: WebhookEndpointWhereUniqueInput
  }

  /**
   * WebhookEndpoint findUniqueOrThrow
   */
  export type WebhookEndpointFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEndpoint
     */
    select?: WebhookEndpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEndpoint
     */
    omit?: WebhookEndpointOmit<ExtArgs> | null
    /**
     * Filter, which WebhookEndpoint to fetch.
     */
    where: WebhookEndpointWhereUniqueInput
  }

  /**
   * WebhookEndpoint findFirst
   */
  export type WebhookEndpointFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEndpoint
     */
    select?: WebhookEndpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEndpoint
     */
    omit?: WebhookEndpointOmit<ExtArgs> | null
    /**
     * Filter, which WebhookEndpoint to fetch.
     */
    where?: WebhookEndpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEndpoints to fetch.
     */
    orderBy?: WebhookEndpointOrderByWithRelationInput | WebhookEndpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookEndpoints.
     */
    cursor?: WebhookEndpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEndpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEndpoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookEndpoints.
     */
    distinct?: WebhookEndpointScalarFieldEnum | WebhookEndpointScalarFieldEnum[]
  }

  /**
   * WebhookEndpoint findFirstOrThrow
   */
  export type WebhookEndpointFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEndpoint
     */
    select?: WebhookEndpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEndpoint
     */
    omit?: WebhookEndpointOmit<ExtArgs> | null
    /**
     * Filter, which WebhookEndpoint to fetch.
     */
    where?: WebhookEndpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEndpoints to fetch.
     */
    orderBy?: WebhookEndpointOrderByWithRelationInput | WebhookEndpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookEndpoints.
     */
    cursor?: WebhookEndpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEndpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEndpoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookEndpoints.
     */
    distinct?: WebhookEndpointScalarFieldEnum | WebhookEndpointScalarFieldEnum[]
  }

  /**
   * WebhookEndpoint findMany
   */
  export type WebhookEndpointFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEndpoint
     */
    select?: WebhookEndpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEndpoint
     */
    omit?: WebhookEndpointOmit<ExtArgs> | null
    /**
     * Filter, which WebhookEndpoints to fetch.
     */
    where?: WebhookEndpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEndpoints to fetch.
     */
    orderBy?: WebhookEndpointOrderByWithRelationInput | WebhookEndpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WebhookEndpoints.
     */
    cursor?: WebhookEndpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEndpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEndpoints.
     */
    skip?: number
    distinct?: WebhookEndpointScalarFieldEnum | WebhookEndpointScalarFieldEnum[]
  }

  /**
   * WebhookEndpoint create
   */
  export type WebhookEndpointCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEndpoint
     */
    select?: WebhookEndpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEndpoint
     */
    omit?: WebhookEndpointOmit<ExtArgs> | null
    /**
     * The data needed to create a WebhookEndpoint.
     */
    data: XOR<WebhookEndpointCreateInput, WebhookEndpointUncheckedCreateInput>
  }

  /**
   * WebhookEndpoint createMany
   */
  export type WebhookEndpointCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WebhookEndpoints.
     */
    data: WebhookEndpointCreateManyInput | WebhookEndpointCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebhookEndpoint createManyAndReturn
   */
  export type WebhookEndpointCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEndpoint
     */
    select?: WebhookEndpointSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEndpoint
     */
    omit?: WebhookEndpointOmit<ExtArgs> | null
    /**
     * The data used to create many WebhookEndpoints.
     */
    data: WebhookEndpointCreateManyInput | WebhookEndpointCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebhookEndpoint update
   */
  export type WebhookEndpointUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEndpoint
     */
    select?: WebhookEndpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEndpoint
     */
    omit?: WebhookEndpointOmit<ExtArgs> | null
    /**
     * The data needed to update a WebhookEndpoint.
     */
    data: XOR<WebhookEndpointUpdateInput, WebhookEndpointUncheckedUpdateInput>
    /**
     * Choose, which WebhookEndpoint to update.
     */
    where: WebhookEndpointWhereUniqueInput
  }

  /**
   * WebhookEndpoint updateMany
   */
  export type WebhookEndpointUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WebhookEndpoints.
     */
    data: XOR<WebhookEndpointUpdateManyMutationInput, WebhookEndpointUncheckedUpdateManyInput>
    /**
     * Filter which WebhookEndpoints to update
     */
    where?: WebhookEndpointWhereInput
    /**
     * Limit how many WebhookEndpoints to update.
     */
    limit?: number
  }

  /**
   * WebhookEndpoint updateManyAndReturn
   */
  export type WebhookEndpointUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEndpoint
     */
    select?: WebhookEndpointSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEndpoint
     */
    omit?: WebhookEndpointOmit<ExtArgs> | null
    /**
     * The data used to update WebhookEndpoints.
     */
    data: XOR<WebhookEndpointUpdateManyMutationInput, WebhookEndpointUncheckedUpdateManyInput>
    /**
     * Filter which WebhookEndpoints to update
     */
    where?: WebhookEndpointWhereInput
    /**
     * Limit how many WebhookEndpoints to update.
     */
    limit?: number
  }

  /**
   * WebhookEndpoint upsert
   */
  export type WebhookEndpointUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEndpoint
     */
    select?: WebhookEndpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEndpoint
     */
    omit?: WebhookEndpointOmit<ExtArgs> | null
    /**
     * The filter to search for the WebhookEndpoint to update in case it exists.
     */
    where: WebhookEndpointWhereUniqueInput
    /**
     * In case the WebhookEndpoint found by the `where` argument doesn't exist, create a new WebhookEndpoint with this data.
     */
    create: XOR<WebhookEndpointCreateInput, WebhookEndpointUncheckedCreateInput>
    /**
     * In case the WebhookEndpoint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebhookEndpointUpdateInput, WebhookEndpointUncheckedUpdateInput>
  }

  /**
   * WebhookEndpoint delete
   */
  export type WebhookEndpointDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEndpoint
     */
    select?: WebhookEndpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEndpoint
     */
    omit?: WebhookEndpointOmit<ExtArgs> | null
    /**
     * Filter which WebhookEndpoint to delete.
     */
    where: WebhookEndpointWhereUniqueInput
  }

  /**
   * WebhookEndpoint deleteMany
   */
  export type WebhookEndpointDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookEndpoints to delete
     */
    where?: WebhookEndpointWhereInput
    /**
     * Limit how many WebhookEndpoints to delete.
     */
    limit?: number
  }

  /**
   * WebhookEndpoint without action
   */
  export type WebhookEndpointDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEndpoint
     */
    select?: WebhookEndpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEndpoint
     */
    omit?: WebhookEndpointOmit<ExtArgs> | null
  }


  /**
   * Model APIManagement
   */

  export type AggregateAPIManagement = {
    _count: APIManagementCountAggregateOutputType | null
    _avg: APIManagementAvgAggregateOutputType | null
    _sum: APIManagementSumAggregateOutputType | null
    _min: APIManagementMinAggregateOutputType | null
    _max: APIManagementMaxAggregateOutputType | null
  }

  export type APIManagementAvgAggregateOutputType = {
    rateLimit: number | null
    usageCount: number | null
  }

  export type APIManagementSumAggregateOutputType = {
    rateLimit: number | null
    usageCount: number | null
  }

  export type APIManagementMinAggregateOutputType = {
    id: string | null
    name: string | null
    apiKey: string | null
    rateLimit: number | null
    isActive: boolean | null
    lastUsed: Date | null
    usageCount: number | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type APIManagementMaxAggregateOutputType = {
    id: string | null
    name: string | null
    apiKey: string | null
    rateLimit: number | null
    isActive: boolean | null
    lastUsed: Date | null
    usageCount: number | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type APIManagementCountAggregateOutputType = {
    id: number
    name: number
    apiKey: number
    permissions: number
    rateLimit: number
    isActive: number
    lastUsed: number
    usageCount: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type APIManagementAvgAggregateInputType = {
    rateLimit?: true
    usageCount?: true
  }

  export type APIManagementSumAggregateInputType = {
    rateLimit?: true
    usageCount?: true
  }

  export type APIManagementMinAggregateInputType = {
    id?: true
    name?: true
    apiKey?: true
    rateLimit?: true
    isActive?: true
    lastUsed?: true
    usageCount?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type APIManagementMaxAggregateInputType = {
    id?: true
    name?: true
    apiKey?: true
    rateLimit?: true
    isActive?: true
    lastUsed?: true
    usageCount?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type APIManagementCountAggregateInputType = {
    id?: true
    name?: true
    apiKey?: true
    permissions?: true
    rateLimit?: true
    isActive?: true
    lastUsed?: true
    usageCount?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type APIManagementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which APIManagement to aggregate.
     */
    where?: APIManagementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of APIManagements to fetch.
     */
    orderBy?: APIManagementOrderByWithRelationInput | APIManagementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: APIManagementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` APIManagements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` APIManagements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned APIManagements
    **/
    _count?: true | APIManagementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: APIManagementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: APIManagementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: APIManagementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: APIManagementMaxAggregateInputType
  }

  export type GetAPIManagementAggregateType<T extends APIManagementAggregateArgs> = {
        [P in keyof T & keyof AggregateAPIManagement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAPIManagement[P]>
      : GetScalarType<T[P], AggregateAPIManagement[P]>
  }




  export type APIManagementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: APIManagementWhereInput
    orderBy?: APIManagementOrderByWithAggregationInput | APIManagementOrderByWithAggregationInput[]
    by: APIManagementScalarFieldEnum[] | APIManagementScalarFieldEnum
    having?: APIManagementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: APIManagementCountAggregateInputType | true
    _avg?: APIManagementAvgAggregateInputType
    _sum?: APIManagementSumAggregateInputType
    _min?: APIManagementMinAggregateInputType
    _max?: APIManagementMaxAggregateInputType
  }

  export type APIManagementGroupByOutputType = {
    id: string
    name: string
    apiKey: string
    permissions: string[]
    rateLimit: number | null
    isActive: boolean
    lastUsed: Date | null
    usageCount: number
    expiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: APIManagementCountAggregateOutputType | null
    _avg: APIManagementAvgAggregateOutputType | null
    _sum: APIManagementSumAggregateOutputType | null
    _min: APIManagementMinAggregateOutputType | null
    _max: APIManagementMaxAggregateOutputType | null
  }

  type GetAPIManagementGroupByPayload<T extends APIManagementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<APIManagementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof APIManagementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], APIManagementGroupByOutputType[P]>
            : GetScalarType<T[P], APIManagementGroupByOutputType[P]>
        }
      >
    >


  export type APIManagementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    apiKey?: boolean
    permissions?: boolean
    rateLimit?: boolean
    isActive?: boolean
    lastUsed?: boolean
    usageCount?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aPIManagement"]>

  export type APIManagementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    apiKey?: boolean
    permissions?: boolean
    rateLimit?: boolean
    isActive?: boolean
    lastUsed?: boolean
    usageCount?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aPIManagement"]>

  export type APIManagementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    apiKey?: boolean
    permissions?: boolean
    rateLimit?: boolean
    isActive?: boolean
    lastUsed?: boolean
    usageCount?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aPIManagement"]>

  export type APIManagementSelectScalar = {
    id?: boolean
    name?: boolean
    apiKey?: boolean
    permissions?: boolean
    rateLimit?: boolean
    isActive?: boolean
    lastUsed?: boolean
    usageCount?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type APIManagementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "apiKey" | "permissions" | "rateLimit" | "isActive" | "lastUsed" | "usageCount" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["aPIManagement"]>

  export type $APIManagementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "APIManagement"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      apiKey: string
      permissions: string[]
      rateLimit: number | null
      isActive: boolean
      lastUsed: Date | null
      usageCount: number
      expiresAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aPIManagement"]>
    composites: {}
  }

  type APIManagementGetPayload<S extends boolean | null | undefined | APIManagementDefaultArgs> = $Result.GetResult<Prisma.$APIManagementPayload, S>

  type APIManagementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<APIManagementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: APIManagementCountAggregateInputType | true
    }

  export interface APIManagementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['APIManagement'], meta: { name: 'APIManagement' } }
    /**
     * Find zero or one APIManagement that matches the filter.
     * @param {APIManagementFindUniqueArgs} args - Arguments to find a APIManagement
     * @example
     * // Get one APIManagement
     * const aPIManagement = await prisma.aPIManagement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends APIManagementFindUniqueArgs>(args: SelectSubset<T, APIManagementFindUniqueArgs<ExtArgs>>): Prisma__APIManagementClient<$Result.GetResult<Prisma.$APIManagementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one APIManagement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {APIManagementFindUniqueOrThrowArgs} args - Arguments to find a APIManagement
     * @example
     * // Get one APIManagement
     * const aPIManagement = await prisma.aPIManagement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends APIManagementFindUniqueOrThrowArgs>(args: SelectSubset<T, APIManagementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__APIManagementClient<$Result.GetResult<Prisma.$APIManagementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first APIManagement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {APIManagementFindFirstArgs} args - Arguments to find a APIManagement
     * @example
     * // Get one APIManagement
     * const aPIManagement = await prisma.aPIManagement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends APIManagementFindFirstArgs>(args?: SelectSubset<T, APIManagementFindFirstArgs<ExtArgs>>): Prisma__APIManagementClient<$Result.GetResult<Prisma.$APIManagementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first APIManagement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {APIManagementFindFirstOrThrowArgs} args - Arguments to find a APIManagement
     * @example
     * // Get one APIManagement
     * const aPIManagement = await prisma.aPIManagement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends APIManagementFindFirstOrThrowArgs>(args?: SelectSubset<T, APIManagementFindFirstOrThrowArgs<ExtArgs>>): Prisma__APIManagementClient<$Result.GetResult<Prisma.$APIManagementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more APIManagements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {APIManagementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all APIManagements
     * const aPIManagements = await prisma.aPIManagement.findMany()
     * 
     * // Get first 10 APIManagements
     * const aPIManagements = await prisma.aPIManagement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aPIManagementWithIdOnly = await prisma.aPIManagement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends APIManagementFindManyArgs>(args?: SelectSubset<T, APIManagementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$APIManagementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a APIManagement.
     * @param {APIManagementCreateArgs} args - Arguments to create a APIManagement.
     * @example
     * // Create one APIManagement
     * const APIManagement = await prisma.aPIManagement.create({
     *   data: {
     *     // ... data to create a APIManagement
     *   }
     * })
     * 
     */
    create<T extends APIManagementCreateArgs>(args: SelectSubset<T, APIManagementCreateArgs<ExtArgs>>): Prisma__APIManagementClient<$Result.GetResult<Prisma.$APIManagementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many APIManagements.
     * @param {APIManagementCreateManyArgs} args - Arguments to create many APIManagements.
     * @example
     * // Create many APIManagements
     * const aPIManagement = await prisma.aPIManagement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends APIManagementCreateManyArgs>(args?: SelectSubset<T, APIManagementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many APIManagements and returns the data saved in the database.
     * @param {APIManagementCreateManyAndReturnArgs} args - Arguments to create many APIManagements.
     * @example
     * // Create many APIManagements
     * const aPIManagement = await prisma.aPIManagement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many APIManagements and only return the `id`
     * const aPIManagementWithIdOnly = await prisma.aPIManagement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends APIManagementCreateManyAndReturnArgs>(args?: SelectSubset<T, APIManagementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$APIManagementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a APIManagement.
     * @param {APIManagementDeleteArgs} args - Arguments to delete one APIManagement.
     * @example
     * // Delete one APIManagement
     * const APIManagement = await prisma.aPIManagement.delete({
     *   where: {
     *     // ... filter to delete one APIManagement
     *   }
     * })
     * 
     */
    delete<T extends APIManagementDeleteArgs>(args: SelectSubset<T, APIManagementDeleteArgs<ExtArgs>>): Prisma__APIManagementClient<$Result.GetResult<Prisma.$APIManagementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one APIManagement.
     * @param {APIManagementUpdateArgs} args - Arguments to update one APIManagement.
     * @example
     * // Update one APIManagement
     * const aPIManagement = await prisma.aPIManagement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends APIManagementUpdateArgs>(args: SelectSubset<T, APIManagementUpdateArgs<ExtArgs>>): Prisma__APIManagementClient<$Result.GetResult<Prisma.$APIManagementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more APIManagements.
     * @param {APIManagementDeleteManyArgs} args - Arguments to filter APIManagements to delete.
     * @example
     * // Delete a few APIManagements
     * const { count } = await prisma.aPIManagement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends APIManagementDeleteManyArgs>(args?: SelectSubset<T, APIManagementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more APIManagements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {APIManagementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many APIManagements
     * const aPIManagement = await prisma.aPIManagement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends APIManagementUpdateManyArgs>(args: SelectSubset<T, APIManagementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more APIManagements and returns the data updated in the database.
     * @param {APIManagementUpdateManyAndReturnArgs} args - Arguments to update many APIManagements.
     * @example
     * // Update many APIManagements
     * const aPIManagement = await prisma.aPIManagement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more APIManagements and only return the `id`
     * const aPIManagementWithIdOnly = await prisma.aPIManagement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends APIManagementUpdateManyAndReturnArgs>(args: SelectSubset<T, APIManagementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$APIManagementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one APIManagement.
     * @param {APIManagementUpsertArgs} args - Arguments to update or create a APIManagement.
     * @example
     * // Update or create a APIManagement
     * const aPIManagement = await prisma.aPIManagement.upsert({
     *   create: {
     *     // ... data to create a APIManagement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the APIManagement we want to update
     *   }
     * })
     */
    upsert<T extends APIManagementUpsertArgs>(args: SelectSubset<T, APIManagementUpsertArgs<ExtArgs>>): Prisma__APIManagementClient<$Result.GetResult<Prisma.$APIManagementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of APIManagements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {APIManagementCountArgs} args - Arguments to filter APIManagements to count.
     * @example
     * // Count the number of APIManagements
     * const count = await prisma.aPIManagement.count({
     *   where: {
     *     // ... the filter for the APIManagements we want to count
     *   }
     * })
    **/
    count<T extends APIManagementCountArgs>(
      args?: Subset<T, APIManagementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], APIManagementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a APIManagement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {APIManagementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends APIManagementAggregateArgs>(args: Subset<T, APIManagementAggregateArgs>): Prisma.PrismaPromise<GetAPIManagementAggregateType<T>>

    /**
     * Group by APIManagement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {APIManagementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends APIManagementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: APIManagementGroupByArgs['orderBy'] }
        : { orderBy?: APIManagementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, APIManagementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAPIManagementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the APIManagement model
   */
  readonly fields: APIManagementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for APIManagement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__APIManagementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the APIManagement model
   */
  interface APIManagementFieldRefs {
    readonly id: FieldRef<"APIManagement", 'String'>
    readonly name: FieldRef<"APIManagement", 'String'>
    readonly apiKey: FieldRef<"APIManagement", 'String'>
    readonly permissions: FieldRef<"APIManagement", 'String[]'>
    readonly rateLimit: FieldRef<"APIManagement", 'Int'>
    readonly isActive: FieldRef<"APIManagement", 'Boolean'>
    readonly lastUsed: FieldRef<"APIManagement", 'DateTime'>
    readonly usageCount: FieldRef<"APIManagement", 'Int'>
    readonly expiresAt: FieldRef<"APIManagement", 'DateTime'>
    readonly createdAt: FieldRef<"APIManagement", 'DateTime'>
    readonly updatedAt: FieldRef<"APIManagement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * APIManagement findUnique
   */
  export type APIManagementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the APIManagement
     */
    select?: APIManagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the APIManagement
     */
    omit?: APIManagementOmit<ExtArgs> | null
    /**
     * Filter, which APIManagement to fetch.
     */
    where: APIManagementWhereUniqueInput
  }

  /**
   * APIManagement findUniqueOrThrow
   */
  export type APIManagementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the APIManagement
     */
    select?: APIManagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the APIManagement
     */
    omit?: APIManagementOmit<ExtArgs> | null
    /**
     * Filter, which APIManagement to fetch.
     */
    where: APIManagementWhereUniqueInput
  }

  /**
   * APIManagement findFirst
   */
  export type APIManagementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the APIManagement
     */
    select?: APIManagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the APIManagement
     */
    omit?: APIManagementOmit<ExtArgs> | null
    /**
     * Filter, which APIManagement to fetch.
     */
    where?: APIManagementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of APIManagements to fetch.
     */
    orderBy?: APIManagementOrderByWithRelationInput | APIManagementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for APIManagements.
     */
    cursor?: APIManagementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` APIManagements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` APIManagements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of APIManagements.
     */
    distinct?: APIManagementScalarFieldEnum | APIManagementScalarFieldEnum[]
  }

  /**
   * APIManagement findFirstOrThrow
   */
  export type APIManagementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the APIManagement
     */
    select?: APIManagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the APIManagement
     */
    omit?: APIManagementOmit<ExtArgs> | null
    /**
     * Filter, which APIManagement to fetch.
     */
    where?: APIManagementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of APIManagements to fetch.
     */
    orderBy?: APIManagementOrderByWithRelationInput | APIManagementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for APIManagements.
     */
    cursor?: APIManagementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` APIManagements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` APIManagements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of APIManagements.
     */
    distinct?: APIManagementScalarFieldEnum | APIManagementScalarFieldEnum[]
  }

  /**
   * APIManagement findMany
   */
  export type APIManagementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the APIManagement
     */
    select?: APIManagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the APIManagement
     */
    omit?: APIManagementOmit<ExtArgs> | null
    /**
     * Filter, which APIManagements to fetch.
     */
    where?: APIManagementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of APIManagements to fetch.
     */
    orderBy?: APIManagementOrderByWithRelationInput | APIManagementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing APIManagements.
     */
    cursor?: APIManagementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` APIManagements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` APIManagements.
     */
    skip?: number
    distinct?: APIManagementScalarFieldEnum | APIManagementScalarFieldEnum[]
  }

  /**
   * APIManagement create
   */
  export type APIManagementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the APIManagement
     */
    select?: APIManagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the APIManagement
     */
    omit?: APIManagementOmit<ExtArgs> | null
    /**
     * The data needed to create a APIManagement.
     */
    data: XOR<APIManagementCreateInput, APIManagementUncheckedCreateInput>
  }

  /**
   * APIManagement createMany
   */
  export type APIManagementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many APIManagements.
     */
    data: APIManagementCreateManyInput | APIManagementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * APIManagement createManyAndReturn
   */
  export type APIManagementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the APIManagement
     */
    select?: APIManagementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the APIManagement
     */
    omit?: APIManagementOmit<ExtArgs> | null
    /**
     * The data used to create many APIManagements.
     */
    data: APIManagementCreateManyInput | APIManagementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * APIManagement update
   */
  export type APIManagementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the APIManagement
     */
    select?: APIManagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the APIManagement
     */
    omit?: APIManagementOmit<ExtArgs> | null
    /**
     * The data needed to update a APIManagement.
     */
    data: XOR<APIManagementUpdateInput, APIManagementUncheckedUpdateInput>
    /**
     * Choose, which APIManagement to update.
     */
    where: APIManagementWhereUniqueInput
  }

  /**
   * APIManagement updateMany
   */
  export type APIManagementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update APIManagements.
     */
    data: XOR<APIManagementUpdateManyMutationInput, APIManagementUncheckedUpdateManyInput>
    /**
     * Filter which APIManagements to update
     */
    where?: APIManagementWhereInput
    /**
     * Limit how many APIManagements to update.
     */
    limit?: number
  }

  /**
   * APIManagement updateManyAndReturn
   */
  export type APIManagementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the APIManagement
     */
    select?: APIManagementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the APIManagement
     */
    omit?: APIManagementOmit<ExtArgs> | null
    /**
     * The data used to update APIManagements.
     */
    data: XOR<APIManagementUpdateManyMutationInput, APIManagementUncheckedUpdateManyInput>
    /**
     * Filter which APIManagements to update
     */
    where?: APIManagementWhereInput
    /**
     * Limit how many APIManagements to update.
     */
    limit?: number
  }

  /**
   * APIManagement upsert
   */
  export type APIManagementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the APIManagement
     */
    select?: APIManagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the APIManagement
     */
    omit?: APIManagementOmit<ExtArgs> | null
    /**
     * The filter to search for the APIManagement to update in case it exists.
     */
    where: APIManagementWhereUniqueInput
    /**
     * In case the APIManagement found by the `where` argument doesn't exist, create a new APIManagement with this data.
     */
    create: XOR<APIManagementCreateInput, APIManagementUncheckedCreateInput>
    /**
     * In case the APIManagement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<APIManagementUpdateInput, APIManagementUncheckedUpdateInput>
  }

  /**
   * APIManagement delete
   */
  export type APIManagementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the APIManagement
     */
    select?: APIManagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the APIManagement
     */
    omit?: APIManagementOmit<ExtArgs> | null
    /**
     * Filter which APIManagement to delete.
     */
    where: APIManagementWhereUniqueInput
  }

  /**
   * APIManagement deleteMany
   */
  export type APIManagementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which APIManagements to delete
     */
    where?: APIManagementWhereInput
    /**
     * Limit how many APIManagements to delete.
     */
    limit?: number
  }

  /**
   * APIManagement without action
   */
  export type APIManagementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the APIManagement
     */
    select?: APIManagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the APIManagement
     */
    omit?: APIManagementOmit<ExtArgs> | null
  }


  /**
   * Model ThreatDetection
   */

  export type AggregateThreatDetection = {
    _count: ThreatDetectionCountAggregateOutputType | null
    _min: ThreatDetectionMinAggregateOutputType | null
    _max: ThreatDetectionMaxAggregateOutputType | null
  }

  export type ThreatDetectionMinAggregateOutputType = {
    id: string | null
    threatType: string | null
    severity: string | null
    status: string | null
    description: string | null
    source: string | null
    assignedTo: string | null
    resolvedAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ThreatDetectionMaxAggregateOutputType = {
    id: string | null
    threatType: string | null
    severity: string | null
    status: string | null
    description: string | null
    source: string | null
    assignedTo: string | null
    resolvedAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ThreatDetectionCountAggregateOutputType = {
    id: number
    threatType: number
    severity: number
    status: number
    description: number
    source: number
    evidence: number
    assignedTo: number
    resolvedAt: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ThreatDetectionMinAggregateInputType = {
    id?: true
    threatType?: true
    severity?: true
    status?: true
    description?: true
    source?: true
    assignedTo?: true
    resolvedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ThreatDetectionMaxAggregateInputType = {
    id?: true
    threatType?: true
    severity?: true
    status?: true
    description?: true
    source?: true
    assignedTo?: true
    resolvedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ThreatDetectionCountAggregateInputType = {
    id?: true
    threatType?: true
    severity?: true
    status?: true
    description?: true
    source?: true
    evidence?: true
    assignedTo?: true
    resolvedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ThreatDetectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ThreatDetection to aggregate.
     */
    where?: ThreatDetectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThreatDetections to fetch.
     */
    orderBy?: ThreatDetectionOrderByWithRelationInput | ThreatDetectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ThreatDetectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThreatDetections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThreatDetections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ThreatDetections
    **/
    _count?: true | ThreatDetectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ThreatDetectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ThreatDetectionMaxAggregateInputType
  }

  export type GetThreatDetectionAggregateType<T extends ThreatDetectionAggregateArgs> = {
        [P in keyof T & keyof AggregateThreatDetection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateThreatDetection[P]>
      : GetScalarType<T[P], AggregateThreatDetection[P]>
  }




  export type ThreatDetectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ThreatDetectionWhereInput
    orderBy?: ThreatDetectionOrderByWithAggregationInput | ThreatDetectionOrderByWithAggregationInput[]
    by: ThreatDetectionScalarFieldEnum[] | ThreatDetectionScalarFieldEnum
    having?: ThreatDetectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ThreatDetectionCountAggregateInputType | true
    _min?: ThreatDetectionMinAggregateInputType
    _max?: ThreatDetectionMaxAggregateInputType
  }

  export type ThreatDetectionGroupByOutputType = {
    id: string
    threatType: string
    severity: string
    status: string
    description: string
    source: string | null
    evidence: JsonValue | null
    assignedTo: string | null
    resolvedAt: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: ThreatDetectionCountAggregateOutputType | null
    _min: ThreatDetectionMinAggregateOutputType | null
    _max: ThreatDetectionMaxAggregateOutputType | null
  }

  type GetThreatDetectionGroupByPayload<T extends ThreatDetectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ThreatDetectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ThreatDetectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ThreatDetectionGroupByOutputType[P]>
            : GetScalarType<T[P], ThreatDetectionGroupByOutputType[P]>
        }
      >
    >


  export type ThreatDetectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    threatType?: boolean
    severity?: boolean
    status?: boolean
    description?: boolean
    source?: boolean
    evidence?: boolean
    assignedTo?: boolean
    resolvedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["threatDetection"]>

  export type ThreatDetectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    threatType?: boolean
    severity?: boolean
    status?: boolean
    description?: boolean
    source?: boolean
    evidence?: boolean
    assignedTo?: boolean
    resolvedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["threatDetection"]>

  export type ThreatDetectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    threatType?: boolean
    severity?: boolean
    status?: boolean
    description?: boolean
    source?: boolean
    evidence?: boolean
    assignedTo?: boolean
    resolvedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["threatDetection"]>

  export type ThreatDetectionSelectScalar = {
    id?: boolean
    threatType?: boolean
    severity?: boolean
    status?: boolean
    description?: boolean
    source?: boolean
    evidence?: boolean
    assignedTo?: boolean
    resolvedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ThreatDetectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "threatType" | "severity" | "status" | "description" | "source" | "evidence" | "assignedTo" | "resolvedAt" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["threatDetection"]>

  export type $ThreatDetectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ThreatDetection"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      threatType: string
      severity: string
      status: string
      description: string
      source: string | null
      evidence: Prisma.JsonValue | null
      assignedTo: string | null
      resolvedAt: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["threatDetection"]>
    composites: {}
  }

  type ThreatDetectionGetPayload<S extends boolean | null | undefined | ThreatDetectionDefaultArgs> = $Result.GetResult<Prisma.$ThreatDetectionPayload, S>

  type ThreatDetectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ThreatDetectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ThreatDetectionCountAggregateInputType | true
    }

  export interface ThreatDetectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ThreatDetection'], meta: { name: 'ThreatDetection' } }
    /**
     * Find zero or one ThreatDetection that matches the filter.
     * @param {ThreatDetectionFindUniqueArgs} args - Arguments to find a ThreatDetection
     * @example
     * // Get one ThreatDetection
     * const threatDetection = await prisma.threatDetection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ThreatDetectionFindUniqueArgs>(args: SelectSubset<T, ThreatDetectionFindUniqueArgs<ExtArgs>>): Prisma__ThreatDetectionClient<$Result.GetResult<Prisma.$ThreatDetectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ThreatDetection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ThreatDetectionFindUniqueOrThrowArgs} args - Arguments to find a ThreatDetection
     * @example
     * // Get one ThreatDetection
     * const threatDetection = await prisma.threatDetection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ThreatDetectionFindUniqueOrThrowArgs>(args: SelectSubset<T, ThreatDetectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ThreatDetectionClient<$Result.GetResult<Prisma.$ThreatDetectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ThreatDetection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreatDetectionFindFirstArgs} args - Arguments to find a ThreatDetection
     * @example
     * // Get one ThreatDetection
     * const threatDetection = await prisma.threatDetection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ThreatDetectionFindFirstArgs>(args?: SelectSubset<T, ThreatDetectionFindFirstArgs<ExtArgs>>): Prisma__ThreatDetectionClient<$Result.GetResult<Prisma.$ThreatDetectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ThreatDetection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreatDetectionFindFirstOrThrowArgs} args - Arguments to find a ThreatDetection
     * @example
     * // Get one ThreatDetection
     * const threatDetection = await prisma.threatDetection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ThreatDetectionFindFirstOrThrowArgs>(args?: SelectSubset<T, ThreatDetectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ThreatDetectionClient<$Result.GetResult<Prisma.$ThreatDetectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ThreatDetections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreatDetectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ThreatDetections
     * const threatDetections = await prisma.threatDetection.findMany()
     * 
     * // Get first 10 ThreatDetections
     * const threatDetections = await prisma.threatDetection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const threatDetectionWithIdOnly = await prisma.threatDetection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ThreatDetectionFindManyArgs>(args?: SelectSubset<T, ThreatDetectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThreatDetectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ThreatDetection.
     * @param {ThreatDetectionCreateArgs} args - Arguments to create a ThreatDetection.
     * @example
     * // Create one ThreatDetection
     * const ThreatDetection = await prisma.threatDetection.create({
     *   data: {
     *     // ... data to create a ThreatDetection
     *   }
     * })
     * 
     */
    create<T extends ThreatDetectionCreateArgs>(args: SelectSubset<T, ThreatDetectionCreateArgs<ExtArgs>>): Prisma__ThreatDetectionClient<$Result.GetResult<Prisma.$ThreatDetectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ThreatDetections.
     * @param {ThreatDetectionCreateManyArgs} args - Arguments to create many ThreatDetections.
     * @example
     * // Create many ThreatDetections
     * const threatDetection = await prisma.threatDetection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ThreatDetectionCreateManyArgs>(args?: SelectSubset<T, ThreatDetectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ThreatDetections and returns the data saved in the database.
     * @param {ThreatDetectionCreateManyAndReturnArgs} args - Arguments to create many ThreatDetections.
     * @example
     * // Create many ThreatDetections
     * const threatDetection = await prisma.threatDetection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ThreatDetections and only return the `id`
     * const threatDetectionWithIdOnly = await prisma.threatDetection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ThreatDetectionCreateManyAndReturnArgs>(args?: SelectSubset<T, ThreatDetectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThreatDetectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ThreatDetection.
     * @param {ThreatDetectionDeleteArgs} args - Arguments to delete one ThreatDetection.
     * @example
     * // Delete one ThreatDetection
     * const ThreatDetection = await prisma.threatDetection.delete({
     *   where: {
     *     // ... filter to delete one ThreatDetection
     *   }
     * })
     * 
     */
    delete<T extends ThreatDetectionDeleteArgs>(args: SelectSubset<T, ThreatDetectionDeleteArgs<ExtArgs>>): Prisma__ThreatDetectionClient<$Result.GetResult<Prisma.$ThreatDetectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ThreatDetection.
     * @param {ThreatDetectionUpdateArgs} args - Arguments to update one ThreatDetection.
     * @example
     * // Update one ThreatDetection
     * const threatDetection = await prisma.threatDetection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ThreatDetectionUpdateArgs>(args: SelectSubset<T, ThreatDetectionUpdateArgs<ExtArgs>>): Prisma__ThreatDetectionClient<$Result.GetResult<Prisma.$ThreatDetectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ThreatDetections.
     * @param {ThreatDetectionDeleteManyArgs} args - Arguments to filter ThreatDetections to delete.
     * @example
     * // Delete a few ThreatDetections
     * const { count } = await prisma.threatDetection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ThreatDetectionDeleteManyArgs>(args?: SelectSubset<T, ThreatDetectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ThreatDetections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreatDetectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ThreatDetections
     * const threatDetection = await prisma.threatDetection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ThreatDetectionUpdateManyArgs>(args: SelectSubset<T, ThreatDetectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ThreatDetections and returns the data updated in the database.
     * @param {ThreatDetectionUpdateManyAndReturnArgs} args - Arguments to update many ThreatDetections.
     * @example
     * // Update many ThreatDetections
     * const threatDetection = await prisma.threatDetection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ThreatDetections and only return the `id`
     * const threatDetectionWithIdOnly = await prisma.threatDetection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ThreatDetectionUpdateManyAndReturnArgs>(args: SelectSubset<T, ThreatDetectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThreatDetectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ThreatDetection.
     * @param {ThreatDetectionUpsertArgs} args - Arguments to update or create a ThreatDetection.
     * @example
     * // Update or create a ThreatDetection
     * const threatDetection = await prisma.threatDetection.upsert({
     *   create: {
     *     // ... data to create a ThreatDetection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ThreatDetection we want to update
     *   }
     * })
     */
    upsert<T extends ThreatDetectionUpsertArgs>(args: SelectSubset<T, ThreatDetectionUpsertArgs<ExtArgs>>): Prisma__ThreatDetectionClient<$Result.GetResult<Prisma.$ThreatDetectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ThreatDetections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreatDetectionCountArgs} args - Arguments to filter ThreatDetections to count.
     * @example
     * // Count the number of ThreatDetections
     * const count = await prisma.threatDetection.count({
     *   where: {
     *     // ... the filter for the ThreatDetections we want to count
     *   }
     * })
    **/
    count<T extends ThreatDetectionCountArgs>(
      args?: Subset<T, ThreatDetectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ThreatDetectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ThreatDetection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreatDetectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ThreatDetectionAggregateArgs>(args: Subset<T, ThreatDetectionAggregateArgs>): Prisma.PrismaPromise<GetThreatDetectionAggregateType<T>>

    /**
     * Group by ThreatDetection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreatDetectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ThreatDetectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ThreatDetectionGroupByArgs['orderBy'] }
        : { orderBy?: ThreatDetectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ThreatDetectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetThreatDetectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ThreatDetection model
   */
  readonly fields: ThreatDetectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ThreatDetection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ThreatDetectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ThreatDetection model
   */
  interface ThreatDetectionFieldRefs {
    readonly id: FieldRef<"ThreatDetection", 'String'>
    readonly threatType: FieldRef<"ThreatDetection", 'String'>
    readonly severity: FieldRef<"ThreatDetection", 'String'>
    readonly status: FieldRef<"ThreatDetection", 'String'>
    readonly description: FieldRef<"ThreatDetection", 'String'>
    readonly source: FieldRef<"ThreatDetection", 'String'>
    readonly evidence: FieldRef<"ThreatDetection", 'Json'>
    readonly assignedTo: FieldRef<"ThreatDetection", 'String'>
    readonly resolvedAt: FieldRef<"ThreatDetection", 'DateTime'>
    readonly notes: FieldRef<"ThreatDetection", 'String'>
    readonly createdAt: FieldRef<"ThreatDetection", 'DateTime'>
    readonly updatedAt: FieldRef<"ThreatDetection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ThreatDetection findUnique
   */
  export type ThreatDetectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreatDetection
     */
    select?: ThreatDetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreatDetection
     */
    omit?: ThreatDetectionOmit<ExtArgs> | null
    /**
     * Filter, which ThreatDetection to fetch.
     */
    where: ThreatDetectionWhereUniqueInput
  }

  /**
   * ThreatDetection findUniqueOrThrow
   */
  export type ThreatDetectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreatDetection
     */
    select?: ThreatDetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreatDetection
     */
    omit?: ThreatDetectionOmit<ExtArgs> | null
    /**
     * Filter, which ThreatDetection to fetch.
     */
    where: ThreatDetectionWhereUniqueInput
  }

  /**
   * ThreatDetection findFirst
   */
  export type ThreatDetectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreatDetection
     */
    select?: ThreatDetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreatDetection
     */
    omit?: ThreatDetectionOmit<ExtArgs> | null
    /**
     * Filter, which ThreatDetection to fetch.
     */
    where?: ThreatDetectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThreatDetections to fetch.
     */
    orderBy?: ThreatDetectionOrderByWithRelationInput | ThreatDetectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ThreatDetections.
     */
    cursor?: ThreatDetectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThreatDetections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThreatDetections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ThreatDetections.
     */
    distinct?: ThreatDetectionScalarFieldEnum | ThreatDetectionScalarFieldEnum[]
  }

  /**
   * ThreatDetection findFirstOrThrow
   */
  export type ThreatDetectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreatDetection
     */
    select?: ThreatDetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreatDetection
     */
    omit?: ThreatDetectionOmit<ExtArgs> | null
    /**
     * Filter, which ThreatDetection to fetch.
     */
    where?: ThreatDetectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThreatDetections to fetch.
     */
    orderBy?: ThreatDetectionOrderByWithRelationInput | ThreatDetectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ThreatDetections.
     */
    cursor?: ThreatDetectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThreatDetections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThreatDetections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ThreatDetections.
     */
    distinct?: ThreatDetectionScalarFieldEnum | ThreatDetectionScalarFieldEnum[]
  }

  /**
   * ThreatDetection findMany
   */
  export type ThreatDetectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreatDetection
     */
    select?: ThreatDetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreatDetection
     */
    omit?: ThreatDetectionOmit<ExtArgs> | null
    /**
     * Filter, which ThreatDetections to fetch.
     */
    where?: ThreatDetectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThreatDetections to fetch.
     */
    orderBy?: ThreatDetectionOrderByWithRelationInput | ThreatDetectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ThreatDetections.
     */
    cursor?: ThreatDetectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThreatDetections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThreatDetections.
     */
    skip?: number
    distinct?: ThreatDetectionScalarFieldEnum | ThreatDetectionScalarFieldEnum[]
  }

  /**
   * ThreatDetection create
   */
  export type ThreatDetectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreatDetection
     */
    select?: ThreatDetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreatDetection
     */
    omit?: ThreatDetectionOmit<ExtArgs> | null
    /**
     * The data needed to create a ThreatDetection.
     */
    data: XOR<ThreatDetectionCreateInput, ThreatDetectionUncheckedCreateInput>
  }

  /**
   * ThreatDetection createMany
   */
  export type ThreatDetectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ThreatDetections.
     */
    data: ThreatDetectionCreateManyInput | ThreatDetectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ThreatDetection createManyAndReturn
   */
  export type ThreatDetectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreatDetection
     */
    select?: ThreatDetectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ThreatDetection
     */
    omit?: ThreatDetectionOmit<ExtArgs> | null
    /**
     * The data used to create many ThreatDetections.
     */
    data: ThreatDetectionCreateManyInput | ThreatDetectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ThreatDetection update
   */
  export type ThreatDetectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreatDetection
     */
    select?: ThreatDetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreatDetection
     */
    omit?: ThreatDetectionOmit<ExtArgs> | null
    /**
     * The data needed to update a ThreatDetection.
     */
    data: XOR<ThreatDetectionUpdateInput, ThreatDetectionUncheckedUpdateInput>
    /**
     * Choose, which ThreatDetection to update.
     */
    where: ThreatDetectionWhereUniqueInput
  }

  /**
   * ThreatDetection updateMany
   */
  export type ThreatDetectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ThreatDetections.
     */
    data: XOR<ThreatDetectionUpdateManyMutationInput, ThreatDetectionUncheckedUpdateManyInput>
    /**
     * Filter which ThreatDetections to update
     */
    where?: ThreatDetectionWhereInput
    /**
     * Limit how many ThreatDetections to update.
     */
    limit?: number
  }

  /**
   * ThreatDetection updateManyAndReturn
   */
  export type ThreatDetectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreatDetection
     */
    select?: ThreatDetectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ThreatDetection
     */
    omit?: ThreatDetectionOmit<ExtArgs> | null
    /**
     * The data used to update ThreatDetections.
     */
    data: XOR<ThreatDetectionUpdateManyMutationInput, ThreatDetectionUncheckedUpdateManyInput>
    /**
     * Filter which ThreatDetections to update
     */
    where?: ThreatDetectionWhereInput
    /**
     * Limit how many ThreatDetections to update.
     */
    limit?: number
  }

  /**
   * ThreatDetection upsert
   */
  export type ThreatDetectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreatDetection
     */
    select?: ThreatDetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreatDetection
     */
    omit?: ThreatDetectionOmit<ExtArgs> | null
    /**
     * The filter to search for the ThreatDetection to update in case it exists.
     */
    where: ThreatDetectionWhereUniqueInput
    /**
     * In case the ThreatDetection found by the `where` argument doesn't exist, create a new ThreatDetection with this data.
     */
    create: XOR<ThreatDetectionCreateInput, ThreatDetectionUncheckedCreateInput>
    /**
     * In case the ThreatDetection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ThreatDetectionUpdateInput, ThreatDetectionUncheckedUpdateInput>
  }

  /**
   * ThreatDetection delete
   */
  export type ThreatDetectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreatDetection
     */
    select?: ThreatDetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreatDetection
     */
    omit?: ThreatDetectionOmit<ExtArgs> | null
    /**
     * Filter which ThreatDetection to delete.
     */
    where: ThreatDetectionWhereUniqueInput
  }

  /**
   * ThreatDetection deleteMany
   */
  export type ThreatDetectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ThreatDetections to delete
     */
    where?: ThreatDetectionWhereInput
    /**
     * Limit how many ThreatDetections to delete.
     */
    limit?: number
  }

  /**
   * ThreatDetection without action
   */
  export type ThreatDetectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreatDetection
     */
    select?: ThreatDetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreatDetection
     */
    omit?: ThreatDetectionOmit<ExtArgs> | null
  }


  /**
   * Model AnomalyDetection
   */

  export type AggregateAnomalyDetection = {
    _count: AnomalyDetectionCountAggregateOutputType | null
    _avg: AnomalyDetectionAvgAggregateOutputType | null
    _sum: AnomalyDetectionSumAggregateOutputType | null
    _min: AnomalyDetectionMinAggregateOutputType | null
    _max: AnomalyDetectionMaxAggregateOutputType | null
  }

  export type AnomalyDetectionAvgAggregateOutputType = {
    confidence: number | null
  }

  export type AnomalyDetectionSumAggregateOutputType = {
    confidence: number | null
  }

  export type AnomalyDetectionMinAggregateOutputType = {
    id: string | null
    anomalyType: string | null
    confidence: number | null
    status: string | null
    description: string | null
    severity: string | null
    resolvedAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnomalyDetectionMaxAggregateOutputType = {
    id: string | null
    anomalyType: string | null
    confidence: number | null
    status: string | null
    description: string | null
    severity: string | null
    resolvedAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnomalyDetectionCountAggregateOutputType = {
    id: number
    anomalyType: number
    confidence: number
    status: number
    description: number
    data: number
    severity: number
    resolvedAt: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AnomalyDetectionAvgAggregateInputType = {
    confidence?: true
  }

  export type AnomalyDetectionSumAggregateInputType = {
    confidence?: true
  }

  export type AnomalyDetectionMinAggregateInputType = {
    id?: true
    anomalyType?: true
    confidence?: true
    status?: true
    description?: true
    severity?: true
    resolvedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnomalyDetectionMaxAggregateInputType = {
    id?: true
    anomalyType?: true
    confidence?: true
    status?: true
    description?: true
    severity?: true
    resolvedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnomalyDetectionCountAggregateInputType = {
    id?: true
    anomalyType?: true
    confidence?: true
    status?: true
    description?: true
    data?: true
    severity?: true
    resolvedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AnomalyDetectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnomalyDetection to aggregate.
     */
    where?: AnomalyDetectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnomalyDetections to fetch.
     */
    orderBy?: AnomalyDetectionOrderByWithRelationInput | AnomalyDetectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnomalyDetectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnomalyDetections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnomalyDetections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnomalyDetections
    **/
    _count?: true | AnomalyDetectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnomalyDetectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnomalyDetectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnomalyDetectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnomalyDetectionMaxAggregateInputType
  }

  export type GetAnomalyDetectionAggregateType<T extends AnomalyDetectionAggregateArgs> = {
        [P in keyof T & keyof AggregateAnomalyDetection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnomalyDetection[P]>
      : GetScalarType<T[P], AggregateAnomalyDetection[P]>
  }




  export type AnomalyDetectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnomalyDetectionWhereInput
    orderBy?: AnomalyDetectionOrderByWithAggregationInput | AnomalyDetectionOrderByWithAggregationInput[]
    by: AnomalyDetectionScalarFieldEnum[] | AnomalyDetectionScalarFieldEnum
    having?: AnomalyDetectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnomalyDetectionCountAggregateInputType | true
    _avg?: AnomalyDetectionAvgAggregateInputType
    _sum?: AnomalyDetectionSumAggregateInputType
    _min?: AnomalyDetectionMinAggregateInputType
    _max?: AnomalyDetectionMaxAggregateInputType
  }

  export type AnomalyDetectionGroupByOutputType = {
    id: string
    anomalyType: string
    confidence: number
    status: string
    description: string
    data: JsonValue | null
    severity: string
    resolvedAt: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: AnomalyDetectionCountAggregateOutputType | null
    _avg: AnomalyDetectionAvgAggregateOutputType | null
    _sum: AnomalyDetectionSumAggregateOutputType | null
    _min: AnomalyDetectionMinAggregateOutputType | null
    _max: AnomalyDetectionMaxAggregateOutputType | null
  }

  type GetAnomalyDetectionGroupByPayload<T extends AnomalyDetectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnomalyDetectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnomalyDetectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnomalyDetectionGroupByOutputType[P]>
            : GetScalarType<T[P], AnomalyDetectionGroupByOutputType[P]>
        }
      >
    >


  export type AnomalyDetectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    anomalyType?: boolean
    confidence?: boolean
    status?: boolean
    description?: boolean
    data?: boolean
    severity?: boolean
    resolvedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["anomalyDetection"]>

  export type AnomalyDetectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    anomalyType?: boolean
    confidence?: boolean
    status?: boolean
    description?: boolean
    data?: boolean
    severity?: boolean
    resolvedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["anomalyDetection"]>

  export type AnomalyDetectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    anomalyType?: boolean
    confidence?: boolean
    status?: boolean
    description?: boolean
    data?: boolean
    severity?: boolean
    resolvedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["anomalyDetection"]>

  export type AnomalyDetectionSelectScalar = {
    id?: boolean
    anomalyType?: boolean
    confidence?: boolean
    status?: boolean
    description?: boolean
    data?: boolean
    severity?: boolean
    resolvedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AnomalyDetectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "anomalyType" | "confidence" | "status" | "description" | "data" | "severity" | "resolvedAt" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["anomalyDetection"]>

  export type $AnomalyDetectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnomalyDetection"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      anomalyType: string
      confidence: number
      status: string
      description: string
      data: Prisma.JsonValue | null
      severity: string
      resolvedAt: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["anomalyDetection"]>
    composites: {}
  }

  type AnomalyDetectionGetPayload<S extends boolean | null | undefined | AnomalyDetectionDefaultArgs> = $Result.GetResult<Prisma.$AnomalyDetectionPayload, S>

  type AnomalyDetectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnomalyDetectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnomalyDetectionCountAggregateInputType | true
    }

  export interface AnomalyDetectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnomalyDetection'], meta: { name: 'AnomalyDetection' } }
    /**
     * Find zero or one AnomalyDetection that matches the filter.
     * @param {AnomalyDetectionFindUniqueArgs} args - Arguments to find a AnomalyDetection
     * @example
     * // Get one AnomalyDetection
     * const anomalyDetection = await prisma.anomalyDetection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnomalyDetectionFindUniqueArgs>(args: SelectSubset<T, AnomalyDetectionFindUniqueArgs<ExtArgs>>): Prisma__AnomalyDetectionClient<$Result.GetResult<Prisma.$AnomalyDetectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AnomalyDetection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnomalyDetectionFindUniqueOrThrowArgs} args - Arguments to find a AnomalyDetection
     * @example
     * // Get one AnomalyDetection
     * const anomalyDetection = await prisma.anomalyDetection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnomalyDetectionFindUniqueOrThrowArgs>(args: SelectSubset<T, AnomalyDetectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnomalyDetectionClient<$Result.GetResult<Prisma.$AnomalyDetectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnomalyDetection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnomalyDetectionFindFirstArgs} args - Arguments to find a AnomalyDetection
     * @example
     * // Get one AnomalyDetection
     * const anomalyDetection = await prisma.anomalyDetection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnomalyDetectionFindFirstArgs>(args?: SelectSubset<T, AnomalyDetectionFindFirstArgs<ExtArgs>>): Prisma__AnomalyDetectionClient<$Result.GetResult<Prisma.$AnomalyDetectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnomalyDetection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnomalyDetectionFindFirstOrThrowArgs} args - Arguments to find a AnomalyDetection
     * @example
     * // Get one AnomalyDetection
     * const anomalyDetection = await prisma.anomalyDetection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnomalyDetectionFindFirstOrThrowArgs>(args?: SelectSubset<T, AnomalyDetectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnomalyDetectionClient<$Result.GetResult<Prisma.$AnomalyDetectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AnomalyDetections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnomalyDetectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnomalyDetections
     * const anomalyDetections = await prisma.anomalyDetection.findMany()
     * 
     * // Get first 10 AnomalyDetections
     * const anomalyDetections = await prisma.anomalyDetection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const anomalyDetectionWithIdOnly = await prisma.anomalyDetection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnomalyDetectionFindManyArgs>(args?: SelectSubset<T, AnomalyDetectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnomalyDetectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AnomalyDetection.
     * @param {AnomalyDetectionCreateArgs} args - Arguments to create a AnomalyDetection.
     * @example
     * // Create one AnomalyDetection
     * const AnomalyDetection = await prisma.anomalyDetection.create({
     *   data: {
     *     // ... data to create a AnomalyDetection
     *   }
     * })
     * 
     */
    create<T extends AnomalyDetectionCreateArgs>(args: SelectSubset<T, AnomalyDetectionCreateArgs<ExtArgs>>): Prisma__AnomalyDetectionClient<$Result.GetResult<Prisma.$AnomalyDetectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AnomalyDetections.
     * @param {AnomalyDetectionCreateManyArgs} args - Arguments to create many AnomalyDetections.
     * @example
     * // Create many AnomalyDetections
     * const anomalyDetection = await prisma.anomalyDetection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnomalyDetectionCreateManyArgs>(args?: SelectSubset<T, AnomalyDetectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnomalyDetections and returns the data saved in the database.
     * @param {AnomalyDetectionCreateManyAndReturnArgs} args - Arguments to create many AnomalyDetections.
     * @example
     * // Create many AnomalyDetections
     * const anomalyDetection = await prisma.anomalyDetection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnomalyDetections and only return the `id`
     * const anomalyDetectionWithIdOnly = await prisma.anomalyDetection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnomalyDetectionCreateManyAndReturnArgs>(args?: SelectSubset<T, AnomalyDetectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnomalyDetectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AnomalyDetection.
     * @param {AnomalyDetectionDeleteArgs} args - Arguments to delete one AnomalyDetection.
     * @example
     * // Delete one AnomalyDetection
     * const AnomalyDetection = await prisma.anomalyDetection.delete({
     *   where: {
     *     // ... filter to delete one AnomalyDetection
     *   }
     * })
     * 
     */
    delete<T extends AnomalyDetectionDeleteArgs>(args: SelectSubset<T, AnomalyDetectionDeleteArgs<ExtArgs>>): Prisma__AnomalyDetectionClient<$Result.GetResult<Prisma.$AnomalyDetectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AnomalyDetection.
     * @param {AnomalyDetectionUpdateArgs} args - Arguments to update one AnomalyDetection.
     * @example
     * // Update one AnomalyDetection
     * const anomalyDetection = await prisma.anomalyDetection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnomalyDetectionUpdateArgs>(args: SelectSubset<T, AnomalyDetectionUpdateArgs<ExtArgs>>): Prisma__AnomalyDetectionClient<$Result.GetResult<Prisma.$AnomalyDetectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AnomalyDetections.
     * @param {AnomalyDetectionDeleteManyArgs} args - Arguments to filter AnomalyDetections to delete.
     * @example
     * // Delete a few AnomalyDetections
     * const { count } = await prisma.anomalyDetection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnomalyDetectionDeleteManyArgs>(args?: SelectSubset<T, AnomalyDetectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnomalyDetections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnomalyDetectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnomalyDetections
     * const anomalyDetection = await prisma.anomalyDetection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnomalyDetectionUpdateManyArgs>(args: SelectSubset<T, AnomalyDetectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnomalyDetections and returns the data updated in the database.
     * @param {AnomalyDetectionUpdateManyAndReturnArgs} args - Arguments to update many AnomalyDetections.
     * @example
     * // Update many AnomalyDetections
     * const anomalyDetection = await prisma.anomalyDetection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AnomalyDetections and only return the `id`
     * const anomalyDetectionWithIdOnly = await prisma.anomalyDetection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnomalyDetectionUpdateManyAndReturnArgs>(args: SelectSubset<T, AnomalyDetectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnomalyDetectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AnomalyDetection.
     * @param {AnomalyDetectionUpsertArgs} args - Arguments to update or create a AnomalyDetection.
     * @example
     * // Update or create a AnomalyDetection
     * const anomalyDetection = await prisma.anomalyDetection.upsert({
     *   create: {
     *     // ... data to create a AnomalyDetection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnomalyDetection we want to update
     *   }
     * })
     */
    upsert<T extends AnomalyDetectionUpsertArgs>(args: SelectSubset<T, AnomalyDetectionUpsertArgs<ExtArgs>>): Prisma__AnomalyDetectionClient<$Result.GetResult<Prisma.$AnomalyDetectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AnomalyDetections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnomalyDetectionCountArgs} args - Arguments to filter AnomalyDetections to count.
     * @example
     * // Count the number of AnomalyDetections
     * const count = await prisma.anomalyDetection.count({
     *   where: {
     *     // ... the filter for the AnomalyDetections we want to count
     *   }
     * })
    **/
    count<T extends AnomalyDetectionCountArgs>(
      args?: Subset<T, AnomalyDetectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnomalyDetectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnomalyDetection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnomalyDetectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnomalyDetectionAggregateArgs>(args: Subset<T, AnomalyDetectionAggregateArgs>): Prisma.PrismaPromise<GetAnomalyDetectionAggregateType<T>>

    /**
     * Group by AnomalyDetection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnomalyDetectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnomalyDetectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnomalyDetectionGroupByArgs['orderBy'] }
        : { orderBy?: AnomalyDetectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnomalyDetectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnomalyDetectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnomalyDetection model
   */
  readonly fields: AnomalyDetectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnomalyDetection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnomalyDetectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnomalyDetection model
   */
  interface AnomalyDetectionFieldRefs {
    readonly id: FieldRef<"AnomalyDetection", 'String'>
    readonly anomalyType: FieldRef<"AnomalyDetection", 'String'>
    readonly confidence: FieldRef<"AnomalyDetection", 'Float'>
    readonly status: FieldRef<"AnomalyDetection", 'String'>
    readonly description: FieldRef<"AnomalyDetection", 'String'>
    readonly data: FieldRef<"AnomalyDetection", 'Json'>
    readonly severity: FieldRef<"AnomalyDetection", 'String'>
    readonly resolvedAt: FieldRef<"AnomalyDetection", 'DateTime'>
    readonly notes: FieldRef<"AnomalyDetection", 'String'>
    readonly createdAt: FieldRef<"AnomalyDetection", 'DateTime'>
    readonly updatedAt: FieldRef<"AnomalyDetection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AnomalyDetection findUnique
   */
  export type AnomalyDetectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnomalyDetection
     */
    select?: AnomalyDetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnomalyDetection
     */
    omit?: AnomalyDetectionOmit<ExtArgs> | null
    /**
     * Filter, which AnomalyDetection to fetch.
     */
    where: AnomalyDetectionWhereUniqueInput
  }

  /**
   * AnomalyDetection findUniqueOrThrow
   */
  export type AnomalyDetectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnomalyDetection
     */
    select?: AnomalyDetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnomalyDetection
     */
    omit?: AnomalyDetectionOmit<ExtArgs> | null
    /**
     * Filter, which AnomalyDetection to fetch.
     */
    where: AnomalyDetectionWhereUniqueInput
  }

  /**
   * AnomalyDetection findFirst
   */
  export type AnomalyDetectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnomalyDetection
     */
    select?: AnomalyDetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnomalyDetection
     */
    omit?: AnomalyDetectionOmit<ExtArgs> | null
    /**
     * Filter, which AnomalyDetection to fetch.
     */
    where?: AnomalyDetectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnomalyDetections to fetch.
     */
    orderBy?: AnomalyDetectionOrderByWithRelationInput | AnomalyDetectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnomalyDetections.
     */
    cursor?: AnomalyDetectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnomalyDetections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnomalyDetections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnomalyDetections.
     */
    distinct?: AnomalyDetectionScalarFieldEnum | AnomalyDetectionScalarFieldEnum[]
  }

  /**
   * AnomalyDetection findFirstOrThrow
   */
  export type AnomalyDetectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnomalyDetection
     */
    select?: AnomalyDetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnomalyDetection
     */
    omit?: AnomalyDetectionOmit<ExtArgs> | null
    /**
     * Filter, which AnomalyDetection to fetch.
     */
    where?: AnomalyDetectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnomalyDetections to fetch.
     */
    orderBy?: AnomalyDetectionOrderByWithRelationInput | AnomalyDetectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnomalyDetections.
     */
    cursor?: AnomalyDetectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnomalyDetections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnomalyDetections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnomalyDetections.
     */
    distinct?: AnomalyDetectionScalarFieldEnum | AnomalyDetectionScalarFieldEnum[]
  }

  /**
   * AnomalyDetection findMany
   */
  export type AnomalyDetectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnomalyDetection
     */
    select?: AnomalyDetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnomalyDetection
     */
    omit?: AnomalyDetectionOmit<ExtArgs> | null
    /**
     * Filter, which AnomalyDetections to fetch.
     */
    where?: AnomalyDetectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnomalyDetections to fetch.
     */
    orderBy?: AnomalyDetectionOrderByWithRelationInput | AnomalyDetectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnomalyDetections.
     */
    cursor?: AnomalyDetectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnomalyDetections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnomalyDetections.
     */
    skip?: number
    distinct?: AnomalyDetectionScalarFieldEnum | AnomalyDetectionScalarFieldEnum[]
  }

  /**
   * AnomalyDetection create
   */
  export type AnomalyDetectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnomalyDetection
     */
    select?: AnomalyDetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnomalyDetection
     */
    omit?: AnomalyDetectionOmit<ExtArgs> | null
    /**
     * The data needed to create a AnomalyDetection.
     */
    data: XOR<AnomalyDetectionCreateInput, AnomalyDetectionUncheckedCreateInput>
  }

  /**
   * AnomalyDetection createMany
   */
  export type AnomalyDetectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnomalyDetections.
     */
    data: AnomalyDetectionCreateManyInput | AnomalyDetectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnomalyDetection createManyAndReturn
   */
  export type AnomalyDetectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnomalyDetection
     */
    select?: AnomalyDetectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnomalyDetection
     */
    omit?: AnomalyDetectionOmit<ExtArgs> | null
    /**
     * The data used to create many AnomalyDetections.
     */
    data: AnomalyDetectionCreateManyInput | AnomalyDetectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnomalyDetection update
   */
  export type AnomalyDetectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnomalyDetection
     */
    select?: AnomalyDetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnomalyDetection
     */
    omit?: AnomalyDetectionOmit<ExtArgs> | null
    /**
     * The data needed to update a AnomalyDetection.
     */
    data: XOR<AnomalyDetectionUpdateInput, AnomalyDetectionUncheckedUpdateInput>
    /**
     * Choose, which AnomalyDetection to update.
     */
    where: AnomalyDetectionWhereUniqueInput
  }

  /**
   * AnomalyDetection updateMany
   */
  export type AnomalyDetectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnomalyDetections.
     */
    data: XOR<AnomalyDetectionUpdateManyMutationInput, AnomalyDetectionUncheckedUpdateManyInput>
    /**
     * Filter which AnomalyDetections to update
     */
    where?: AnomalyDetectionWhereInput
    /**
     * Limit how many AnomalyDetections to update.
     */
    limit?: number
  }

  /**
   * AnomalyDetection updateManyAndReturn
   */
  export type AnomalyDetectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnomalyDetection
     */
    select?: AnomalyDetectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnomalyDetection
     */
    omit?: AnomalyDetectionOmit<ExtArgs> | null
    /**
     * The data used to update AnomalyDetections.
     */
    data: XOR<AnomalyDetectionUpdateManyMutationInput, AnomalyDetectionUncheckedUpdateManyInput>
    /**
     * Filter which AnomalyDetections to update
     */
    where?: AnomalyDetectionWhereInput
    /**
     * Limit how many AnomalyDetections to update.
     */
    limit?: number
  }

  /**
   * AnomalyDetection upsert
   */
  export type AnomalyDetectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnomalyDetection
     */
    select?: AnomalyDetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnomalyDetection
     */
    omit?: AnomalyDetectionOmit<ExtArgs> | null
    /**
     * The filter to search for the AnomalyDetection to update in case it exists.
     */
    where: AnomalyDetectionWhereUniqueInput
    /**
     * In case the AnomalyDetection found by the `where` argument doesn't exist, create a new AnomalyDetection with this data.
     */
    create: XOR<AnomalyDetectionCreateInput, AnomalyDetectionUncheckedCreateInput>
    /**
     * In case the AnomalyDetection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnomalyDetectionUpdateInput, AnomalyDetectionUncheckedUpdateInput>
  }

  /**
   * AnomalyDetection delete
   */
  export type AnomalyDetectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnomalyDetection
     */
    select?: AnomalyDetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnomalyDetection
     */
    omit?: AnomalyDetectionOmit<ExtArgs> | null
    /**
     * Filter which AnomalyDetection to delete.
     */
    where: AnomalyDetectionWhereUniqueInput
  }

  /**
   * AnomalyDetection deleteMany
   */
  export type AnomalyDetectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnomalyDetections to delete
     */
    where?: AnomalyDetectionWhereInput
    /**
     * Limit how many AnomalyDetections to delete.
     */
    limit?: number
  }

  /**
   * AnomalyDetection without action
   */
  export type AnomalyDetectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnomalyDetection
     */
    select?: AnomalyDetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnomalyDetection
     */
    omit?: AnomalyDetectionOmit<ExtArgs> | null
  }


  /**
   * Model ComplianceReport
   */

  export type AggregateComplianceReport = {
    _count: ComplianceReportCountAggregateOutputType | null
    _min: ComplianceReportMinAggregateOutputType | null
    _max: ComplianceReportMaxAggregateOutputType | null
  }

  export type ComplianceReportMinAggregateOutputType = {
    id: string | null
    reportType: string | null
    status: string | null
    period: string | null
    recommendations: string | null
    submittedBy: string | null
    submittedAt: Date | null
    approvedBy: string | null
    approvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComplianceReportMaxAggregateOutputType = {
    id: string | null
    reportType: string | null
    status: string | null
    period: string | null
    recommendations: string | null
    submittedBy: string | null
    submittedAt: Date | null
    approvedBy: string | null
    approvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComplianceReportCountAggregateOutputType = {
    id: number
    reportType: number
    status: number
    period: number
    findings: number
    recommendations: number
    submittedBy: number
    submittedAt: number
    approvedBy: number
    approvedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ComplianceReportMinAggregateInputType = {
    id?: true
    reportType?: true
    status?: true
    period?: true
    recommendations?: true
    submittedBy?: true
    submittedAt?: true
    approvedBy?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComplianceReportMaxAggregateInputType = {
    id?: true
    reportType?: true
    status?: true
    period?: true
    recommendations?: true
    submittedBy?: true
    submittedAt?: true
    approvedBy?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComplianceReportCountAggregateInputType = {
    id?: true
    reportType?: true
    status?: true
    period?: true
    findings?: true
    recommendations?: true
    submittedBy?: true
    submittedAt?: true
    approvedBy?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ComplianceReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComplianceReport to aggregate.
     */
    where?: ComplianceReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplianceReports to fetch.
     */
    orderBy?: ComplianceReportOrderByWithRelationInput | ComplianceReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComplianceReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplianceReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplianceReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ComplianceReports
    **/
    _count?: true | ComplianceReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComplianceReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComplianceReportMaxAggregateInputType
  }

  export type GetComplianceReportAggregateType<T extends ComplianceReportAggregateArgs> = {
        [P in keyof T & keyof AggregateComplianceReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComplianceReport[P]>
      : GetScalarType<T[P], AggregateComplianceReport[P]>
  }




  export type ComplianceReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplianceReportWhereInput
    orderBy?: ComplianceReportOrderByWithAggregationInput | ComplianceReportOrderByWithAggregationInput[]
    by: ComplianceReportScalarFieldEnum[] | ComplianceReportScalarFieldEnum
    having?: ComplianceReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComplianceReportCountAggregateInputType | true
    _min?: ComplianceReportMinAggregateInputType
    _max?: ComplianceReportMaxAggregateInputType
  }

  export type ComplianceReportGroupByOutputType = {
    id: string
    reportType: string
    status: string
    period: string
    findings: JsonValue | null
    recommendations: string | null
    submittedBy: string | null
    submittedAt: Date | null
    approvedBy: string | null
    approvedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ComplianceReportCountAggregateOutputType | null
    _min: ComplianceReportMinAggregateOutputType | null
    _max: ComplianceReportMaxAggregateOutputType | null
  }

  type GetComplianceReportGroupByPayload<T extends ComplianceReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComplianceReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComplianceReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComplianceReportGroupByOutputType[P]>
            : GetScalarType<T[P], ComplianceReportGroupByOutputType[P]>
        }
      >
    >


  export type ComplianceReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportType?: boolean
    status?: boolean
    period?: boolean
    findings?: boolean
    recommendations?: boolean
    submittedBy?: boolean
    submittedAt?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["complianceReport"]>

  export type ComplianceReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportType?: boolean
    status?: boolean
    period?: boolean
    findings?: boolean
    recommendations?: boolean
    submittedBy?: boolean
    submittedAt?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["complianceReport"]>

  export type ComplianceReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportType?: boolean
    status?: boolean
    period?: boolean
    findings?: boolean
    recommendations?: boolean
    submittedBy?: boolean
    submittedAt?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["complianceReport"]>

  export type ComplianceReportSelectScalar = {
    id?: boolean
    reportType?: boolean
    status?: boolean
    period?: boolean
    findings?: boolean
    recommendations?: boolean
    submittedBy?: boolean
    submittedAt?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ComplianceReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reportType" | "status" | "period" | "findings" | "recommendations" | "submittedBy" | "submittedAt" | "approvedBy" | "approvedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["complianceReport"]>

  export type $ComplianceReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ComplianceReport"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reportType: string
      status: string
      period: string
      findings: Prisma.JsonValue | null
      recommendations: string | null
      submittedBy: string | null
      submittedAt: Date | null
      approvedBy: string | null
      approvedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["complianceReport"]>
    composites: {}
  }

  type ComplianceReportGetPayload<S extends boolean | null | undefined | ComplianceReportDefaultArgs> = $Result.GetResult<Prisma.$ComplianceReportPayload, S>

  type ComplianceReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ComplianceReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComplianceReportCountAggregateInputType | true
    }

  export interface ComplianceReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ComplianceReport'], meta: { name: 'ComplianceReport' } }
    /**
     * Find zero or one ComplianceReport that matches the filter.
     * @param {ComplianceReportFindUniqueArgs} args - Arguments to find a ComplianceReport
     * @example
     * // Get one ComplianceReport
     * const complianceReport = await prisma.complianceReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComplianceReportFindUniqueArgs>(args: SelectSubset<T, ComplianceReportFindUniqueArgs<ExtArgs>>): Prisma__ComplianceReportClient<$Result.GetResult<Prisma.$ComplianceReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ComplianceReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ComplianceReportFindUniqueOrThrowArgs} args - Arguments to find a ComplianceReport
     * @example
     * // Get one ComplianceReport
     * const complianceReport = await prisma.complianceReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComplianceReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ComplianceReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComplianceReportClient<$Result.GetResult<Prisma.$ComplianceReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ComplianceReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceReportFindFirstArgs} args - Arguments to find a ComplianceReport
     * @example
     * // Get one ComplianceReport
     * const complianceReport = await prisma.complianceReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComplianceReportFindFirstArgs>(args?: SelectSubset<T, ComplianceReportFindFirstArgs<ExtArgs>>): Prisma__ComplianceReportClient<$Result.GetResult<Prisma.$ComplianceReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ComplianceReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceReportFindFirstOrThrowArgs} args - Arguments to find a ComplianceReport
     * @example
     * // Get one ComplianceReport
     * const complianceReport = await prisma.complianceReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComplianceReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ComplianceReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComplianceReportClient<$Result.GetResult<Prisma.$ComplianceReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ComplianceReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ComplianceReports
     * const complianceReports = await prisma.complianceReport.findMany()
     * 
     * // Get first 10 ComplianceReports
     * const complianceReports = await prisma.complianceReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const complianceReportWithIdOnly = await prisma.complianceReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComplianceReportFindManyArgs>(args?: SelectSubset<T, ComplianceReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplianceReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ComplianceReport.
     * @param {ComplianceReportCreateArgs} args - Arguments to create a ComplianceReport.
     * @example
     * // Create one ComplianceReport
     * const ComplianceReport = await prisma.complianceReport.create({
     *   data: {
     *     // ... data to create a ComplianceReport
     *   }
     * })
     * 
     */
    create<T extends ComplianceReportCreateArgs>(args: SelectSubset<T, ComplianceReportCreateArgs<ExtArgs>>): Prisma__ComplianceReportClient<$Result.GetResult<Prisma.$ComplianceReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ComplianceReports.
     * @param {ComplianceReportCreateManyArgs} args - Arguments to create many ComplianceReports.
     * @example
     * // Create many ComplianceReports
     * const complianceReport = await prisma.complianceReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComplianceReportCreateManyArgs>(args?: SelectSubset<T, ComplianceReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ComplianceReports and returns the data saved in the database.
     * @param {ComplianceReportCreateManyAndReturnArgs} args - Arguments to create many ComplianceReports.
     * @example
     * // Create many ComplianceReports
     * const complianceReport = await prisma.complianceReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ComplianceReports and only return the `id`
     * const complianceReportWithIdOnly = await prisma.complianceReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComplianceReportCreateManyAndReturnArgs>(args?: SelectSubset<T, ComplianceReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplianceReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ComplianceReport.
     * @param {ComplianceReportDeleteArgs} args - Arguments to delete one ComplianceReport.
     * @example
     * // Delete one ComplianceReport
     * const ComplianceReport = await prisma.complianceReport.delete({
     *   where: {
     *     // ... filter to delete one ComplianceReport
     *   }
     * })
     * 
     */
    delete<T extends ComplianceReportDeleteArgs>(args: SelectSubset<T, ComplianceReportDeleteArgs<ExtArgs>>): Prisma__ComplianceReportClient<$Result.GetResult<Prisma.$ComplianceReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ComplianceReport.
     * @param {ComplianceReportUpdateArgs} args - Arguments to update one ComplianceReport.
     * @example
     * // Update one ComplianceReport
     * const complianceReport = await prisma.complianceReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComplianceReportUpdateArgs>(args: SelectSubset<T, ComplianceReportUpdateArgs<ExtArgs>>): Prisma__ComplianceReportClient<$Result.GetResult<Prisma.$ComplianceReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ComplianceReports.
     * @param {ComplianceReportDeleteManyArgs} args - Arguments to filter ComplianceReports to delete.
     * @example
     * // Delete a few ComplianceReports
     * const { count } = await prisma.complianceReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComplianceReportDeleteManyArgs>(args?: SelectSubset<T, ComplianceReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComplianceReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ComplianceReports
     * const complianceReport = await prisma.complianceReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComplianceReportUpdateManyArgs>(args: SelectSubset<T, ComplianceReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComplianceReports and returns the data updated in the database.
     * @param {ComplianceReportUpdateManyAndReturnArgs} args - Arguments to update many ComplianceReports.
     * @example
     * // Update many ComplianceReports
     * const complianceReport = await prisma.complianceReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ComplianceReports and only return the `id`
     * const complianceReportWithIdOnly = await prisma.complianceReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ComplianceReportUpdateManyAndReturnArgs>(args: SelectSubset<T, ComplianceReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplianceReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ComplianceReport.
     * @param {ComplianceReportUpsertArgs} args - Arguments to update or create a ComplianceReport.
     * @example
     * // Update or create a ComplianceReport
     * const complianceReport = await prisma.complianceReport.upsert({
     *   create: {
     *     // ... data to create a ComplianceReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ComplianceReport we want to update
     *   }
     * })
     */
    upsert<T extends ComplianceReportUpsertArgs>(args: SelectSubset<T, ComplianceReportUpsertArgs<ExtArgs>>): Prisma__ComplianceReportClient<$Result.GetResult<Prisma.$ComplianceReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ComplianceReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceReportCountArgs} args - Arguments to filter ComplianceReports to count.
     * @example
     * // Count the number of ComplianceReports
     * const count = await prisma.complianceReport.count({
     *   where: {
     *     // ... the filter for the ComplianceReports we want to count
     *   }
     * })
    **/
    count<T extends ComplianceReportCountArgs>(
      args?: Subset<T, ComplianceReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComplianceReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ComplianceReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComplianceReportAggregateArgs>(args: Subset<T, ComplianceReportAggregateArgs>): Prisma.PrismaPromise<GetComplianceReportAggregateType<T>>

    /**
     * Group by ComplianceReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComplianceReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComplianceReportGroupByArgs['orderBy'] }
        : { orderBy?: ComplianceReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComplianceReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComplianceReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ComplianceReport model
   */
  readonly fields: ComplianceReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ComplianceReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComplianceReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ComplianceReport model
   */
  interface ComplianceReportFieldRefs {
    readonly id: FieldRef<"ComplianceReport", 'String'>
    readonly reportType: FieldRef<"ComplianceReport", 'String'>
    readonly status: FieldRef<"ComplianceReport", 'String'>
    readonly period: FieldRef<"ComplianceReport", 'String'>
    readonly findings: FieldRef<"ComplianceReport", 'Json'>
    readonly recommendations: FieldRef<"ComplianceReport", 'String'>
    readonly submittedBy: FieldRef<"ComplianceReport", 'String'>
    readonly submittedAt: FieldRef<"ComplianceReport", 'DateTime'>
    readonly approvedBy: FieldRef<"ComplianceReport", 'String'>
    readonly approvedAt: FieldRef<"ComplianceReport", 'DateTime'>
    readonly createdAt: FieldRef<"ComplianceReport", 'DateTime'>
    readonly updatedAt: FieldRef<"ComplianceReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ComplianceReport findUnique
   */
  export type ComplianceReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceReport
     */
    select?: ComplianceReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceReport
     */
    omit?: ComplianceReportOmit<ExtArgs> | null
    /**
     * Filter, which ComplianceReport to fetch.
     */
    where: ComplianceReportWhereUniqueInput
  }

  /**
   * ComplianceReport findUniqueOrThrow
   */
  export type ComplianceReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceReport
     */
    select?: ComplianceReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceReport
     */
    omit?: ComplianceReportOmit<ExtArgs> | null
    /**
     * Filter, which ComplianceReport to fetch.
     */
    where: ComplianceReportWhereUniqueInput
  }

  /**
   * ComplianceReport findFirst
   */
  export type ComplianceReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceReport
     */
    select?: ComplianceReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceReport
     */
    omit?: ComplianceReportOmit<ExtArgs> | null
    /**
     * Filter, which ComplianceReport to fetch.
     */
    where?: ComplianceReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplianceReports to fetch.
     */
    orderBy?: ComplianceReportOrderByWithRelationInput | ComplianceReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComplianceReports.
     */
    cursor?: ComplianceReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplianceReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplianceReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComplianceReports.
     */
    distinct?: ComplianceReportScalarFieldEnum | ComplianceReportScalarFieldEnum[]
  }

  /**
   * ComplianceReport findFirstOrThrow
   */
  export type ComplianceReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceReport
     */
    select?: ComplianceReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceReport
     */
    omit?: ComplianceReportOmit<ExtArgs> | null
    /**
     * Filter, which ComplianceReport to fetch.
     */
    where?: ComplianceReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplianceReports to fetch.
     */
    orderBy?: ComplianceReportOrderByWithRelationInput | ComplianceReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComplianceReports.
     */
    cursor?: ComplianceReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplianceReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplianceReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComplianceReports.
     */
    distinct?: ComplianceReportScalarFieldEnum | ComplianceReportScalarFieldEnum[]
  }

  /**
   * ComplianceReport findMany
   */
  export type ComplianceReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceReport
     */
    select?: ComplianceReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceReport
     */
    omit?: ComplianceReportOmit<ExtArgs> | null
    /**
     * Filter, which ComplianceReports to fetch.
     */
    where?: ComplianceReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplianceReports to fetch.
     */
    orderBy?: ComplianceReportOrderByWithRelationInput | ComplianceReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ComplianceReports.
     */
    cursor?: ComplianceReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplianceReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplianceReports.
     */
    skip?: number
    distinct?: ComplianceReportScalarFieldEnum | ComplianceReportScalarFieldEnum[]
  }

  /**
   * ComplianceReport create
   */
  export type ComplianceReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceReport
     */
    select?: ComplianceReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceReport
     */
    omit?: ComplianceReportOmit<ExtArgs> | null
    /**
     * The data needed to create a ComplianceReport.
     */
    data: XOR<ComplianceReportCreateInput, ComplianceReportUncheckedCreateInput>
  }

  /**
   * ComplianceReport createMany
   */
  export type ComplianceReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ComplianceReports.
     */
    data: ComplianceReportCreateManyInput | ComplianceReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ComplianceReport createManyAndReturn
   */
  export type ComplianceReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceReport
     */
    select?: ComplianceReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceReport
     */
    omit?: ComplianceReportOmit<ExtArgs> | null
    /**
     * The data used to create many ComplianceReports.
     */
    data: ComplianceReportCreateManyInput | ComplianceReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ComplianceReport update
   */
  export type ComplianceReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceReport
     */
    select?: ComplianceReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceReport
     */
    omit?: ComplianceReportOmit<ExtArgs> | null
    /**
     * The data needed to update a ComplianceReport.
     */
    data: XOR<ComplianceReportUpdateInput, ComplianceReportUncheckedUpdateInput>
    /**
     * Choose, which ComplianceReport to update.
     */
    where: ComplianceReportWhereUniqueInput
  }

  /**
   * ComplianceReport updateMany
   */
  export type ComplianceReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ComplianceReports.
     */
    data: XOR<ComplianceReportUpdateManyMutationInput, ComplianceReportUncheckedUpdateManyInput>
    /**
     * Filter which ComplianceReports to update
     */
    where?: ComplianceReportWhereInput
    /**
     * Limit how many ComplianceReports to update.
     */
    limit?: number
  }

  /**
   * ComplianceReport updateManyAndReturn
   */
  export type ComplianceReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceReport
     */
    select?: ComplianceReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceReport
     */
    omit?: ComplianceReportOmit<ExtArgs> | null
    /**
     * The data used to update ComplianceReports.
     */
    data: XOR<ComplianceReportUpdateManyMutationInput, ComplianceReportUncheckedUpdateManyInput>
    /**
     * Filter which ComplianceReports to update
     */
    where?: ComplianceReportWhereInput
    /**
     * Limit how many ComplianceReports to update.
     */
    limit?: number
  }

  /**
   * ComplianceReport upsert
   */
  export type ComplianceReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceReport
     */
    select?: ComplianceReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceReport
     */
    omit?: ComplianceReportOmit<ExtArgs> | null
    /**
     * The filter to search for the ComplianceReport to update in case it exists.
     */
    where: ComplianceReportWhereUniqueInput
    /**
     * In case the ComplianceReport found by the `where` argument doesn't exist, create a new ComplianceReport with this data.
     */
    create: XOR<ComplianceReportCreateInput, ComplianceReportUncheckedCreateInput>
    /**
     * In case the ComplianceReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComplianceReportUpdateInput, ComplianceReportUncheckedUpdateInput>
  }

  /**
   * ComplianceReport delete
   */
  export type ComplianceReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceReport
     */
    select?: ComplianceReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceReport
     */
    omit?: ComplianceReportOmit<ExtArgs> | null
    /**
     * Filter which ComplianceReport to delete.
     */
    where: ComplianceReportWhereUniqueInput
  }

  /**
   * ComplianceReport deleteMany
   */
  export type ComplianceReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComplianceReports to delete
     */
    where?: ComplianceReportWhereInput
    /**
     * Limit how many ComplianceReports to delete.
     */
    limit?: number
  }

  /**
   * ComplianceReport without action
   */
  export type ComplianceReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceReport
     */
    select?: ComplianceReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceReport
     */
    omit?: ComplianceReportOmit<ExtArgs> | null
  }


  /**
   * Model SecurityWorkflow
   */

  export type AggregateSecurityWorkflow = {
    _count: SecurityWorkflowCountAggregateOutputType | null
    _min: SecurityWorkflowMinAggregateOutputType | null
    _max: SecurityWorkflowMaxAggregateOutputType | null
  }

  export type SecurityWorkflowMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    status: string | null
    priority: string | null
    assignedTo: string | null
    dueDate: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SecurityWorkflowMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    status: string | null
    priority: string | null
    assignedTo: string | null
    dueDate: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SecurityWorkflowCountAggregateOutputType = {
    id: number
    name: number
    type: number
    status: number
    priority: number
    assignedTo: number
    dueDate: number
    steps: number
    completedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SecurityWorkflowMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    status?: true
    priority?: true
    assignedTo?: true
    dueDate?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SecurityWorkflowMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    status?: true
    priority?: true
    assignedTo?: true
    dueDate?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SecurityWorkflowCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    status?: true
    priority?: true
    assignedTo?: true
    dueDate?: true
    steps?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SecurityWorkflowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecurityWorkflow to aggregate.
     */
    where?: SecurityWorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityWorkflows to fetch.
     */
    orderBy?: SecurityWorkflowOrderByWithRelationInput | SecurityWorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SecurityWorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityWorkflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityWorkflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SecurityWorkflows
    **/
    _count?: true | SecurityWorkflowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SecurityWorkflowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SecurityWorkflowMaxAggregateInputType
  }

  export type GetSecurityWorkflowAggregateType<T extends SecurityWorkflowAggregateArgs> = {
        [P in keyof T & keyof AggregateSecurityWorkflow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSecurityWorkflow[P]>
      : GetScalarType<T[P], AggregateSecurityWorkflow[P]>
  }




  export type SecurityWorkflowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecurityWorkflowWhereInput
    orderBy?: SecurityWorkflowOrderByWithAggregationInput | SecurityWorkflowOrderByWithAggregationInput[]
    by: SecurityWorkflowScalarFieldEnum[] | SecurityWorkflowScalarFieldEnum
    having?: SecurityWorkflowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SecurityWorkflowCountAggregateInputType | true
    _min?: SecurityWorkflowMinAggregateInputType
    _max?: SecurityWorkflowMaxAggregateInputType
  }

  export type SecurityWorkflowGroupByOutputType = {
    id: string
    name: string
    type: string
    status: string
    priority: string
    assignedTo: string | null
    dueDate: Date | null
    steps: JsonValue | null
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: SecurityWorkflowCountAggregateOutputType | null
    _min: SecurityWorkflowMinAggregateOutputType | null
    _max: SecurityWorkflowMaxAggregateOutputType | null
  }

  type GetSecurityWorkflowGroupByPayload<T extends SecurityWorkflowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SecurityWorkflowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SecurityWorkflowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SecurityWorkflowGroupByOutputType[P]>
            : GetScalarType<T[P], SecurityWorkflowGroupByOutputType[P]>
        }
      >
    >


  export type SecurityWorkflowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    priority?: boolean
    assignedTo?: boolean
    dueDate?: boolean
    steps?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["securityWorkflow"]>

  export type SecurityWorkflowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    priority?: boolean
    assignedTo?: boolean
    dueDate?: boolean
    steps?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["securityWorkflow"]>

  export type SecurityWorkflowSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    priority?: boolean
    assignedTo?: boolean
    dueDate?: boolean
    steps?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["securityWorkflow"]>

  export type SecurityWorkflowSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    priority?: boolean
    assignedTo?: boolean
    dueDate?: boolean
    steps?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SecurityWorkflowOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "status" | "priority" | "assignedTo" | "dueDate" | "steps" | "completedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["securityWorkflow"]>

  export type $SecurityWorkflowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SecurityWorkflow"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      status: string
      priority: string
      assignedTo: string | null
      dueDate: Date | null
      steps: Prisma.JsonValue | null
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["securityWorkflow"]>
    composites: {}
  }

  type SecurityWorkflowGetPayload<S extends boolean | null | undefined | SecurityWorkflowDefaultArgs> = $Result.GetResult<Prisma.$SecurityWorkflowPayload, S>

  type SecurityWorkflowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SecurityWorkflowFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SecurityWorkflowCountAggregateInputType | true
    }

  export interface SecurityWorkflowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SecurityWorkflow'], meta: { name: 'SecurityWorkflow' } }
    /**
     * Find zero or one SecurityWorkflow that matches the filter.
     * @param {SecurityWorkflowFindUniqueArgs} args - Arguments to find a SecurityWorkflow
     * @example
     * // Get one SecurityWorkflow
     * const securityWorkflow = await prisma.securityWorkflow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SecurityWorkflowFindUniqueArgs>(args: SelectSubset<T, SecurityWorkflowFindUniqueArgs<ExtArgs>>): Prisma__SecurityWorkflowClient<$Result.GetResult<Prisma.$SecurityWorkflowPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SecurityWorkflow that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SecurityWorkflowFindUniqueOrThrowArgs} args - Arguments to find a SecurityWorkflow
     * @example
     * // Get one SecurityWorkflow
     * const securityWorkflow = await prisma.securityWorkflow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SecurityWorkflowFindUniqueOrThrowArgs>(args: SelectSubset<T, SecurityWorkflowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SecurityWorkflowClient<$Result.GetResult<Prisma.$SecurityWorkflowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SecurityWorkflow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityWorkflowFindFirstArgs} args - Arguments to find a SecurityWorkflow
     * @example
     * // Get one SecurityWorkflow
     * const securityWorkflow = await prisma.securityWorkflow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SecurityWorkflowFindFirstArgs>(args?: SelectSubset<T, SecurityWorkflowFindFirstArgs<ExtArgs>>): Prisma__SecurityWorkflowClient<$Result.GetResult<Prisma.$SecurityWorkflowPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SecurityWorkflow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityWorkflowFindFirstOrThrowArgs} args - Arguments to find a SecurityWorkflow
     * @example
     * // Get one SecurityWorkflow
     * const securityWorkflow = await prisma.securityWorkflow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SecurityWorkflowFindFirstOrThrowArgs>(args?: SelectSubset<T, SecurityWorkflowFindFirstOrThrowArgs<ExtArgs>>): Prisma__SecurityWorkflowClient<$Result.GetResult<Prisma.$SecurityWorkflowPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SecurityWorkflows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityWorkflowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SecurityWorkflows
     * const securityWorkflows = await prisma.securityWorkflow.findMany()
     * 
     * // Get first 10 SecurityWorkflows
     * const securityWorkflows = await prisma.securityWorkflow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const securityWorkflowWithIdOnly = await prisma.securityWorkflow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SecurityWorkflowFindManyArgs>(args?: SelectSubset<T, SecurityWorkflowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityWorkflowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SecurityWorkflow.
     * @param {SecurityWorkflowCreateArgs} args - Arguments to create a SecurityWorkflow.
     * @example
     * // Create one SecurityWorkflow
     * const SecurityWorkflow = await prisma.securityWorkflow.create({
     *   data: {
     *     // ... data to create a SecurityWorkflow
     *   }
     * })
     * 
     */
    create<T extends SecurityWorkflowCreateArgs>(args: SelectSubset<T, SecurityWorkflowCreateArgs<ExtArgs>>): Prisma__SecurityWorkflowClient<$Result.GetResult<Prisma.$SecurityWorkflowPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SecurityWorkflows.
     * @param {SecurityWorkflowCreateManyArgs} args - Arguments to create many SecurityWorkflows.
     * @example
     * // Create many SecurityWorkflows
     * const securityWorkflow = await prisma.securityWorkflow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SecurityWorkflowCreateManyArgs>(args?: SelectSubset<T, SecurityWorkflowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SecurityWorkflows and returns the data saved in the database.
     * @param {SecurityWorkflowCreateManyAndReturnArgs} args - Arguments to create many SecurityWorkflows.
     * @example
     * // Create many SecurityWorkflows
     * const securityWorkflow = await prisma.securityWorkflow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SecurityWorkflows and only return the `id`
     * const securityWorkflowWithIdOnly = await prisma.securityWorkflow.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SecurityWorkflowCreateManyAndReturnArgs>(args?: SelectSubset<T, SecurityWorkflowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityWorkflowPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SecurityWorkflow.
     * @param {SecurityWorkflowDeleteArgs} args - Arguments to delete one SecurityWorkflow.
     * @example
     * // Delete one SecurityWorkflow
     * const SecurityWorkflow = await prisma.securityWorkflow.delete({
     *   where: {
     *     // ... filter to delete one SecurityWorkflow
     *   }
     * })
     * 
     */
    delete<T extends SecurityWorkflowDeleteArgs>(args: SelectSubset<T, SecurityWorkflowDeleteArgs<ExtArgs>>): Prisma__SecurityWorkflowClient<$Result.GetResult<Prisma.$SecurityWorkflowPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SecurityWorkflow.
     * @param {SecurityWorkflowUpdateArgs} args - Arguments to update one SecurityWorkflow.
     * @example
     * // Update one SecurityWorkflow
     * const securityWorkflow = await prisma.securityWorkflow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SecurityWorkflowUpdateArgs>(args: SelectSubset<T, SecurityWorkflowUpdateArgs<ExtArgs>>): Prisma__SecurityWorkflowClient<$Result.GetResult<Prisma.$SecurityWorkflowPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SecurityWorkflows.
     * @param {SecurityWorkflowDeleteManyArgs} args - Arguments to filter SecurityWorkflows to delete.
     * @example
     * // Delete a few SecurityWorkflows
     * const { count } = await prisma.securityWorkflow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SecurityWorkflowDeleteManyArgs>(args?: SelectSubset<T, SecurityWorkflowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecurityWorkflows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityWorkflowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SecurityWorkflows
     * const securityWorkflow = await prisma.securityWorkflow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SecurityWorkflowUpdateManyArgs>(args: SelectSubset<T, SecurityWorkflowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecurityWorkflows and returns the data updated in the database.
     * @param {SecurityWorkflowUpdateManyAndReturnArgs} args - Arguments to update many SecurityWorkflows.
     * @example
     * // Update many SecurityWorkflows
     * const securityWorkflow = await prisma.securityWorkflow.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SecurityWorkflows and only return the `id`
     * const securityWorkflowWithIdOnly = await prisma.securityWorkflow.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SecurityWorkflowUpdateManyAndReturnArgs>(args: SelectSubset<T, SecurityWorkflowUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityWorkflowPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SecurityWorkflow.
     * @param {SecurityWorkflowUpsertArgs} args - Arguments to update or create a SecurityWorkflow.
     * @example
     * // Update or create a SecurityWorkflow
     * const securityWorkflow = await prisma.securityWorkflow.upsert({
     *   create: {
     *     // ... data to create a SecurityWorkflow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SecurityWorkflow we want to update
     *   }
     * })
     */
    upsert<T extends SecurityWorkflowUpsertArgs>(args: SelectSubset<T, SecurityWorkflowUpsertArgs<ExtArgs>>): Prisma__SecurityWorkflowClient<$Result.GetResult<Prisma.$SecurityWorkflowPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SecurityWorkflows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityWorkflowCountArgs} args - Arguments to filter SecurityWorkflows to count.
     * @example
     * // Count the number of SecurityWorkflows
     * const count = await prisma.securityWorkflow.count({
     *   where: {
     *     // ... the filter for the SecurityWorkflows we want to count
     *   }
     * })
    **/
    count<T extends SecurityWorkflowCountArgs>(
      args?: Subset<T, SecurityWorkflowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SecurityWorkflowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SecurityWorkflow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityWorkflowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SecurityWorkflowAggregateArgs>(args: Subset<T, SecurityWorkflowAggregateArgs>): Prisma.PrismaPromise<GetSecurityWorkflowAggregateType<T>>

    /**
     * Group by SecurityWorkflow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityWorkflowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SecurityWorkflowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SecurityWorkflowGroupByArgs['orderBy'] }
        : { orderBy?: SecurityWorkflowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SecurityWorkflowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSecurityWorkflowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SecurityWorkflow model
   */
  readonly fields: SecurityWorkflowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SecurityWorkflow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SecurityWorkflowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SecurityWorkflow model
   */
  interface SecurityWorkflowFieldRefs {
    readonly id: FieldRef<"SecurityWorkflow", 'String'>
    readonly name: FieldRef<"SecurityWorkflow", 'String'>
    readonly type: FieldRef<"SecurityWorkflow", 'String'>
    readonly status: FieldRef<"SecurityWorkflow", 'String'>
    readonly priority: FieldRef<"SecurityWorkflow", 'String'>
    readonly assignedTo: FieldRef<"SecurityWorkflow", 'String'>
    readonly dueDate: FieldRef<"SecurityWorkflow", 'DateTime'>
    readonly steps: FieldRef<"SecurityWorkflow", 'Json'>
    readonly completedAt: FieldRef<"SecurityWorkflow", 'DateTime'>
    readonly createdAt: FieldRef<"SecurityWorkflow", 'DateTime'>
    readonly updatedAt: FieldRef<"SecurityWorkflow", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SecurityWorkflow findUnique
   */
  export type SecurityWorkflowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityWorkflow
     */
    select?: SecurityWorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityWorkflow
     */
    omit?: SecurityWorkflowOmit<ExtArgs> | null
    /**
     * Filter, which SecurityWorkflow to fetch.
     */
    where: SecurityWorkflowWhereUniqueInput
  }

  /**
   * SecurityWorkflow findUniqueOrThrow
   */
  export type SecurityWorkflowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityWorkflow
     */
    select?: SecurityWorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityWorkflow
     */
    omit?: SecurityWorkflowOmit<ExtArgs> | null
    /**
     * Filter, which SecurityWorkflow to fetch.
     */
    where: SecurityWorkflowWhereUniqueInput
  }

  /**
   * SecurityWorkflow findFirst
   */
  export type SecurityWorkflowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityWorkflow
     */
    select?: SecurityWorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityWorkflow
     */
    omit?: SecurityWorkflowOmit<ExtArgs> | null
    /**
     * Filter, which SecurityWorkflow to fetch.
     */
    where?: SecurityWorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityWorkflows to fetch.
     */
    orderBy?: SecurityWorkflowOrderByWithRelationInput | SecurityWorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecurityWorkflows.
     */
    cursor?: SecurityWorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityWorkflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityWorkflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecurityWorkflows.
     */
    distinct?: SecurityWorkflowScalarFieldEnum | SecurityWorkflowScalarFieldEnum[]
  }

  /**
   * SecurityWorkflow findFirstOrThrow
   */
  export type SecurityWorkflowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityWorkflow
     */
    select?: SecurityWorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityWorkflow
     */
    omit?: SecurityWorkflowOmit<ExtArgs> | null
    /**
     * Filter, which SecurityWorkflow to fetch.
     */
    where?: SecurityWorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityWorkflows to fetch.
     */
    orderBy?: SecurityWorkflowOrderByWithRelationInput | SecurityWorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecurityWorkflows.
     */
    cursor?: SecurityWorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityWorkflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityWorkflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecurityWorkflows.
     */
    distinct?: SecurityWorkflowScalarFieldEnum | SecurityWorkflowScalarFieldEnum[]
  }

  /**
   * SecurityWorkflow findMany
   */
  export type SecurityWorkflowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityWorkflow
     */
    select?: SecurityWorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityWorkflow
     */
    omit?: SecurityWorkflowOmit<ExtArgs> | null
    /**
     * Filter, which SecurityWorkflows to fetch.
     */
    where?: SecurityWorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityWorkflows to fetch.
     */
    orderBy?: SecurityWorkflowOrderByWithRelationInput | SecurityWorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SecurityWorkflows.
     */
    cursor?: SecurityWorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityWorkflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityWorkflows.
     */
    skip?: number
    distinct?: SecurityWorkflowScalarFieldEnum | SecurityWorkflowScalarFieldEnum[]
  }

  /**
   * SecurityWorkflow create
   */
  export type SecurityWorkflowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityWorkflow
     */
    select?: SecurityWorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityWorkflow
     */
    omit?: SecurityWorkflowOmit<ExtArgs> | null
    /**
     * The data needed to create a SecurityWorkflow.
     */
    data: XOR<SecurityWorkflowCreateInput, SecurityWorkflowUncheckedCreateInput>
  }

  /**
   * SecurityWorkflow createMany
   */
  export type SecurityWorkflowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SecurityWorkflows.
     */
    data: SecurityWorkflowCreateManyInput | SecurityWorkflowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SecurityWorkflow createManyAndReturn
   */
  export type SecurityWorkflowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityWorkflow
     */
    select?: SecurityWorkflowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityWorkflow
     */
    omit?: SecurityWorkflowOmit<ExtArgs> | null
    /**
     * The data used to create many SecurityWorkflows.
     */
    data: SecurityWorkflowCreateManyInput | SecurityWorkflowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SecurityWorkflow update
   */
  export type SecurityWorkflowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityWorkflow
     */
    select?: SecurityWorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityWorkflow
     */
    omit?: SecurityWorkflowOmit<ExtArgs> | null
    /**
     * The data needed to update a SecurityWorkflow.
     */
    data: XOR<SecurityWorkflowUpdateInput, SecurityWorkflowUncheckedUpdateInput>
    /**
     * Choose, which SecurityWorkflow to update.
     */
    where: SecurityWorkflowWhereUniqueInput
  }

  /**
   * SecurityWorkflow updateMany
   */
  export type SecurityWorkflowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SecurityWorkflows.
     */
    data: XOR<SecurityWorkflowUpdateManyMutationInput, SecurityWorkflowUncheckedUpdateManyInput>
    /**
     * Filter which SecurityWorkflows to update
     */
    where?: SecurityWorkflowWhereInput
    /**
     * Limit how many SecurityWorkflows to update.
     */
    limit?: number
  }

  /**
   * SecurityWorkflow updateManyAndReturn
   */
  export type SecurityWorkflowUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityWorkflow
     */
    select?: SecurityWorkflowSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityWorkflow
     */
    omit?: SecurityWorkflowOmit<ExtArgs> | null
    /**
     * The data used to update SecurityWorkflows.
     */
    data: XOR<SecurityWorkflowUpdateManyMutationInput, SecurityWorkflowUncheckedUpdateManyInput>
    /**
     * Filter which SecurityWorkflows to update
     */
    where?: SecurityWorkflowWhereInput
    /**
     * Limit how many SecurityWorkflows to update.
     */
    limit?: number
  }

  /**
   * SecurityWorkflow upsert
   */
  export type SecurityWorkflowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityWorkflow
     */
    select?: SecurityWorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityWorkflow
     */
    omit?: SecurityWorkflowOmit<ExtArgs> | null
    /**
     * The filter to search for the SecurityWorkflow to update in case it exists.
     */
    where: SecurityWorkflowWhereUniqueInput
    /**
     * In case the SecurityWorkflow found by the `where` argument doesn't exist, create a new SecurityWorkflow with this data.
     */
    create: XOR<SecurityWorkflowCreateInput, SecurityWorkflowUncheckedCreateInput>
    /**
     * In case the SecurityWorkflow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SecurityWorkflowUpdateInput, SecurityWorkflowUncheckedUpdateInput>
  }

  /**
   * SecurityWorkflow delete
   */
  export type SecurityWorkflowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityWorkflow
     */
    select?: SecurityWorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityWorkflow
     */
    omit?: SecurityWorkflowOmit<ExtArgs> | null
    /**
     * Filter which SecurityWorkflow to delete.
     */
    where: SecurityWorkflowWhereUniqueInput
  }

  /**
   * SecurityWorkflow deleteMany
   */
  export type SecurityWorkflowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecurityWorkflows to delete
     */
    where?: SecurityWorkflowWhereInput
    /**
     * Limit how many SecurityWorkflows to delete.
     */
    limit?: number
  }

  /**
   * SecurityWorkflow without action
   */
  export type SecurityWorkflowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityWorkflow
     */
    select?: SecurityWorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityWorkflow
     */
    omit?: SecurityWorkflowOmit<ExtArgs> | null
  }


  /**
   * Model SecurityIntegration
   */

  export type AggregateSecurityIntegration = {
    _count: SecurityIntegrationCountAggregateOutputType | null
    _avg: SecurityIntegrationAvgAggregateOutputType | null
    _sum: SecurityIntegrationSumAggregateOutputType | null
    _min: SecurityIntegrationMinAggregateOutputType | null
    _max: SecurityIntegrationMaxAggregateOutputType | null
  }

  export type SecurityIntegrationAvgAggregateOutputType = {
    healthScore: number | null
  }

  export type SecurityIntegrationSumAggregateOutputType = {
    healthScore: number | null
  }

  export type SecurityIntegrationMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    status: string | null
    endpoint: string | null
    apiKey: string | null
    lastSync: Date | null
    healthScore: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SecurityIntegrationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    status: string | null
    endpoint: string | null
    apiKey: string | null
    lastSync: Date | null
    healthScore: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SecurityIntegrationCountAggregateOutputType = {
    id: number
    name: number
    type: number
    status: number
    endpoint: number
    apiKey: number
    config: number
    lastSync: number
    healthScore: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SecurityIntegrationAvgAggregateInputType = {
    healthScore?: true
  }

  export type SecurityIntegrationSumAggregateInputType = {
    healthScore?: true
  }

  export type SecurityIntegrationMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    status?: true
    endpoint?: true
    apiKey?: true
    lastSync?: true
    healthScore?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SecurityIntegrationMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    status?: true
    endpoint?: true
    apiKey?: true
    lastSync?: true
    healthScore?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SecurityIntegrationCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    status?: true
    endpoint?: true
    apiKey?: true
    config?: true
    lastSync?: true
    healthScore?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SecurityIntegrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecurityIntegration to aggregate.
     */
    where?: SecurityIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityIntegrations to fetch.
     */
    orderBy?: SecurityIntegrationOrderByWithRelationInput | SecurityIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SecurityIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SecurityIntegrations
    **/
    _count?: true | SecurityIntegrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SecurityIntegrationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SecurityIntegrationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SecurityIntegrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SecurityIntegrationMaxAggregateInputType
  }

  export type GetSecurityIntegrationAggregateType<T extends SecurityIntegrationAggregateArgs> = {
        [P in keyof T & keyof AggregateSecurityIntegration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSecurityIntegration[P]>
      : GetScalarType<T[P], AggregateSecurityIntegration[P]>
  }




  export type SecurityIntegrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecurityIntegrationWhereInput
    orderBy?: SecurityIntegrationOrderByWithAggregationInput | SecurityIntegrationOrderByWithAggregationInput[]
    by: SecurityIntegrationScalarFieldEnum[] | SecurityIntegrationScalarFieldEnum
    having?: SecurityIntegrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SecurityIntegrationCountAggregateInputType | true
    _avg?: SecurityIntegrationAvgAggregateInputType
    _sum?: SecurityIntegrationSumAggregateInputType
    _min?: SecurityIntegrationMinAggregateInputType
    _max?: SecurityIntegrationMaxAggregateInputType
  }

  export type SecurityIntegrationGroupByOutputType = {
    id: string
    name: string
    type: string
    status: string
    endpoint: string | null
    apiKey: string | null
    config: JsonValue | null
    lastSync: Date | null
    healthScore: number
    createdAt: Date
    updatedAt: Date
    _count: SecurityIntegrationCountAggregateOutputType | null
    _avg: SecurityIntegrationAvgAggregateOutputType | null
    _sum: SecurityIntegrationSumAggregateOutputType | null
    _min: SecurityIntegrationMinAggregateOutputType | null
    _max: SecurityIntegrationMaxAggregateOutputType | null
  }

  type GetSecurityIntegrationGroupByPayload<T extends SecurityIntegrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SecurityIntegrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SecurityIntegrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SecurityIntegrationGroupByOutputType[P]>
            : GetScalarType<T[P], SecurityIntegrationGroupByOutputType[P]>
        }
      >
    >


  export type SecurityIntegrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    endpoint?: boolean
    apiKey?: boolean
    config?: boolean
    lastSync?: boolean
    healthScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["securityIntegration"]>

  export type SecurityIntegrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    endpoint?: boolean
    apiKey?: boolean
    config?: boolean
    lastSync?: boolean
    healthScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["securityIntegration"]>

  export type SecurityIntegrationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    endpoint?: boolean
    apiKey?: boolean
    config?: boolean
    lastSync?: boolean
    healthScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["securityIntegration"]>

  export type SecurityIntegrationSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    endpoint?: boolean
    apiKey?: boolean
    config?: boolean
    lastSync?: boolean
    healthScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SecurityIntegrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "status" | "endpoint" | "apiKey" | "config" | "lastSync" | "healthScore" | "createdAt" | "updatedAt", ExtArgs["result"]["securityIntegration"]>

  export type $SecurityIntegrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SecurityIntegration"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      status: string
      endpoint: string | null
      apiKey: string | null
      config: Prisma.JsonValue | null
      lastSync: Date | null
      healthScore: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["securityIntegration"]>
    composites: {}
  }

  type SecurityIntegrationGetPayload<S extends boolean | null | undefined | SecurityIntegrationDefaultArgs> = $Result.GetResult<Prisma.$SecurityIntegrationPayload, S>

  type SecurityIntegrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SecurityIntegrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SecurityIntegrationCountAggregateInputType | true
    }

  export interface SecurityIntegrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SecurityIntegration'], meta: { name: 'SecurityIntegration' } }
    /**
     * Find zero or one SecurityIntegration that matches the filter.
     * @param {SecurityIntegrationFindUniqueArgs} args - Arguments to find a SecurityIntegration
     * @example
     * // Get one SecurityIntegration
     * const securityIntegration = await prisma.securityIntegration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SecurityIntegrationFindUniqueArgs>(args: SelectSubset<T, SecurityIntegrationFindUniqueArgs<ExtArgs>>): Prisma__SecurityIntegrationClient<$Result.GetResult<Prisma.$SecurityIntegrationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SecurityIntegration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SecurityIntegrationFindUniqueOrThrowArgs} args - Arguments to find a SecurityIntegration
     * @example
     * // Get one SecurityIntegration
     * const securityIntegration = await prisma.securityIntegration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SecurityIntegrationFindUniqueOrThrowArgs>(args: SelectSubset<T, SecurityIntegrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SecurityIntegrationClient<$Result.GetResult<Prisma.$SecurityIntegrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SecurityIntegration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityIntegrationFindFirstArgs} args - Arguments to find a SecurityIntegration
     * @example
     * // Get one SecurityIntegration
     * const securityIntegration = await prisma.securityIntegration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SecurityIntegrationFindFirstArgs>(args?: SelectSubset<T, SecurityIntegrationFindFirstArgs<ExtArgs>>): Prisma__SecurityIntegrationClient<$Result.GetResult<Prisma.$SecurityIntegrationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SecurityIntegration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityIntegrationFindFirstOrThrowArgs} args - Arguments to find a SecurityIntegration
     * @example
     * // Get one SecurityIntegration
     * const securityIntegration = await prisma.securityIntegration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SecurityIntegrationFindFirstOrThrowArgs>(args?: SelectSubset<T, SecurityIntegrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__SecurityIntegrationClient<$Result.GetResult<Prisma.$SecurityIntegrationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SecurityIntegrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityIntegrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SecurityIntegrations
     * const securityIntegrations = await prisma.securityIntegration.findMany()
     * 
     * // Get first 10 SecurityIntegrations
     * const securityIntegrations = await prisma.securityIntegration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const securityIntegrationWithIdOnly = await prisma.securityIntegration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SecurityIntegrationFindManyArgs>(args?: SelectSubset<T, SecurityIntegrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityIntegrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SecurityIntegration.
     * @param {SecurityIntegrationCreateArgs} args - Arguments to create a SecurityIntegration.
     * @example
     * // Create one SecurityIntegration
     * const SecurityIntegration = await prisma.securityIntegration.create({
     *   data: {
     *     // ... data to create a SecurityIntegration
     *   }
     * })
     * 
     */
    create<T extends SecurityIntegrationCreateArgs>(args: SelectSubset<T, SecurityIntegrationCreateArgs<ExtArgs>>): Prisma__SecurityIntegrationClient<$Result.GetResult<Prisma.$SecurityIntegrationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SecurityIntegrations.
     * @param {SecurityIntegrationCreateManyArgs} args - Arguments to create many SecurityIntegrations.
     * @example
     * // Create many SecurityIntegrations
     * const securityIntegration = await prisma.securityIntegration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SecurityIntegrationCreateManyArgs>(args?: SelectSubset<T, SecurityIntegrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SecurityIntegrations and returns the data saved in the database.
     * @param {SecurityIntegrationCreateManyAndReturnArgs} args - Arguments to create many SecurityIntegrations.
     * @example
     * // Create many SecurityIntegrations
     * const securityIntegration = await prisma.securityIntegration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SecurityIntegrations and only return the `id`
     * const securityIntegrationWithIdOnly = await prisma.securityIntegration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SecurityIntegrationCreateManyAndReturnArgs>(args?: SelectSubset<T, SecurityIntegrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityIntegrationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SecurityIntegration.
     * @param {SecurityIntegrationDeleteArgs} args - Arguments to delete one SecurityIntegration.
     * @example
     * // Delete one SecurityIntegration
     * const SecurityIntegration = await prisma.securityIntegration.delete({
     *   where: {
     *     // ... filter to delete one SecurityIntegration
     *   }
     * })
     * 
     */
    delete<T extends SecurityIntegrationDeleteArgs>(args: SelectSubset<T, SecurityIntegrationDeleteArgs<ExtArgs>>): Prisma__SecurityIntegrationClient<$Result.GetResult<Prisma.$SecurityIntegrationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SecurityIntegration.
     * @param {SecurityIntegrationUpdateArgs} args - Arguments to update one SecurityIntegration.
     * @example
     * // Update one SecurityIntegration
     * const securityIntegration = await prisma.securityIntegration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SecurityIntegrationUpdateArgs>(args: SelectSubset<T, SecurityIntegrationUpdateArgs<ExtArgs>>): Prisma__SecurityIntegrationClient<$Result.GetResult<Prisma.$SecurityIntegrationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SecurityIntegrations.
     * @param {SecurityIntegrationDeleteManyArgs} args - Arguments to filter SecurityIntegrations to delete.
     * @example
     * // Delete a few SecurityIntegrations
     * const { count } = await prisma.securityIntegration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SecurityIntegrationDeleteManyArgs>(args?: SelectSubset<T, SecurityIntegrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecurityIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityIntegrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SecurityIntegrations
     * const securityIntegration = await prisma.securityIntegration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SecurityIntegrationUpdateManyArgs>(args: SelectSubset<T, SecurityIntegrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecurityIntegrations and returns the data updated in the database.
     * @param {SecurityIntegrationUpdateManyAndReturnArgs} args - Arguments to update many SecurityIntegrations.
     * @example
     * // Update many SecurityIntegrations
     * const securityIntegration = await prisma.securityIntegration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SecurityIntegrations and only return the `id`
     * const securityIntegrationWithIdOnly = await prisma.securityIntegration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SecurityIntegrationUpdateManyAndReturnArgs>(args: SelectSubset<T, SecurityIntegrationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityIntegrationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SecurityIntegration.
     * @param {SecurityIntegrationUpsertArgs} args - Arguments to update or create a SecurityIntegration.
     * @example
     * // Update or create a SecurityIntegration
     * const securityIntegration = await prisma.securityIntegration.upsert({
     *   create: {
     *     // ... data to create a SecurityIntegration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SecurityIntegration we want to update
     *   }
     * })
     */
    upsert<T extends SecurityIntegrationUpsertArgs>(args: SelectSubset<T, SecurityIntegrationUpsertArgs<ExtArgs>>): Prisma__SecurityIntegrationClient<$Result.GetResult<Prisma.$SecurityIntegrationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SecurityIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityIntegrationCountArgs} args - Arguments to filter SecurityIntegrations to count.
     * @example
     * // Count the number of SecurityIntegrations
     * const count = await prisma.securityIntegration.count({
     *   where: {
     *     // ... the filter for the SecurityIntegrations we want to count
     *   }
     * })
    **/
    count<T extends SecurityIntegrationCountArgs>(
      args?: Subset<T, SecurityIntegrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SecurityIntegrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SecurityIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityIntegrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SecurityIntegrationAggregateArgs>(args: Subset<T, SecurityIntegrationAggregateArgs>): Prisma.PrismaPromise<GetSecurityIntegrationAggregateType<T>>

    /**
     * Group by SecurityIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityIntegrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SecurityIntegrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SecurityIntegrationGroupByArgs['orderBy'] }
        : { orderBy?: SecurityIntegrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SecurityIntegrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSecurityIntegrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SecurityIntegration model
   */
  readonly fields: SecurityIntegrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SecurityIntegration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SecurityIntegrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SecurityIntegration model
   */
  interface SecurityIntegrationFieldRefs {
    readonly id: FieldRef<"SecurityIntegration", 'String'>
    readonly name: FieldRef<"SecurityIntegration", 'String'>
    readonly type: FieldRef<"SecurityIntegration", 'String'>
    readonly status: FieldRef<"SecurityIntegration", 'String'>
    readonly endpoint: FieldRef<"SecurityIntegration", 'String'>
    readonly apiKey: FieldRef<"SecurityIntegration", 'String'>
    readonly config: FieldRef<"SecurityIntegration", 'Json'>
    readonly lastSync: FieldRef<"SecurityIntegration", 'DateTime'>
    readonly healthScore: FieldRef<"SecurityIntegration", 'Int'>
    readonly createdAt: FieldRef<"SecurityIntegration", 'DateTime'>
    readonly updatedAt: FieldRef<"SecurityIntegration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SecurityIntegration findUnique
   */
  export type SecurityIntegrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityIntegration
     */
    select?: SecurityIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityIntegration
     */
    omit?: SecurityIntegrationOmit<ExtArgs> | null
    /**
     * Filter, which SecurityIntegration to fetch.
     */
    where: SecurityIntegrationWhereUniqueInput
  }

  /**
   * SecurityIntegration findUniqueOrThrow
   */
  export type SecurityIntegrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityIntegration
     */
    select?: SecurityIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityIntegration
     */
    omit?: SecurityIntegrationOmit<ExtArgs> | null
    /**
     * Filter, which SecurityIntegration to fetch.
     */
    where: SecurityIntegrationWhereUniqueInput
  }

  /**
   * SecurityIntegration findFirst
   */
  export type SecurityIntegrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityIntegration
     */
    select?: SecurityIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityIntegration
     */
    omit?: SecurityIntegrationOmit<ExtArgs> | null
    /**
     * Filter, which SecurityIntegration to fetch.
     */
    where?: SecurityIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityIntegrations to fetch.
     */
    orderBy?: SecurityIntegrationOrderByWithRelationInput | SecurityIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecurityIntegrations.
     */
    cursor?: SecurityIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecurityIntegrations.
     */
    distinct?: SecurityIntegrationScalarFieldEnum | SecurityIntegrationScalarFieldEnum[]
  }

  /**
   * SecurityIntegration findFirstOrThrow
   */
  export type SecurityIntegrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityIntegration
     */
    select?: SecurityIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityIntegration
     */
    omit?: SecurityIntegrationOmit<ExtArgs> | null
    /**
     * Filter, which SecurityIntegration to fetch.
     */
    where?: SecurityIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityIntegrations to fetch.
     */
    orderBy?: SecurityIntegrationOrderByWithRelationInput | SecurityIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecurityIntegrations.
     */
    cursor?: SecurityIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecurityIntegrations.
     */
    distinct?: SecurityIntegrationScalarFieldEnum | SecurityIntegrationScalarFieldEnum[]
  }

  /**
   * SecurityIntegration findMany
   */
  export type SecurityIntegrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityIntegration
     */
    select?: SecurityIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityIntegration
     */
    omit?: SecurityIntegrationOmit<ExtArgs> | null
    /**
     * Filter, which SecurityIntegrations to fetch.
     */
    where?: SecurityIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityIntegrations to fetch.
     */
    orderBy?: SecurityIntegrationOrderByWithRelationInput | SecurityIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SecurityIntegrations.
     */
    cursor?: SecurityIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityIntegrations.
     */
    skip?: number
    distinct?: SecurityIntegrationScalarFieldEnum | SecurityIntegrationScalarFieldEnum[]
  }

  /**
   * SecurityIntegration create
   */
  export type SecurityIntegrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityIntegration
     */
    select?: SecurityIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityIntegration
     */
    omit?: SecurityIntegrationOmit<ExtArgs> | null
    /**
     * The data needed to create a SecurityIntegration.
     */
    data: XOR<SecurityIntegrationCreateInput, SecurityIntegrationUncheckedCreateInput>
  }

  /**
   * SecurityIntegration createMany
   */
  export type SecurityIntegrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SecurityIntegrations.
     */
    data: SecurityIntegrationCreateManyInput | SecurityIntegrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SecurityIntegration createManyAndReturn
   */
  export type SecurityIntegrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityIntegration
     */
    select?: SecurityIntegrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityIntegration
     */
    omit?: SecurityIntegrationOmit<ExtArgs> | null
    /**
     * The data used to create many SecurityIntegrations.
     */
    data: SecurityIntegrationCreateManyInput | SecurityIntegrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SecurityIntegration update
   */
  export type SecurityIntegrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityIntegration
     */
    select?: SecurityIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityIntegration
     */
    omit?: SecurityIntegrationOmit<ExtArgs> | null
    /**
     * The data needed to update a SecurityIntegration.
     */
    data: XOR<SecurityIntegrationUpdateInput, SecurityIntegrationUncheckedUpdateInput>
    /**
     * Choose, which SecurityIntegration to update.
     */
    where: SecurityIntegrationWhereUniqueInput
  }

  /**
   * SecurityIntegration updateMany
   */
  export type SecurityIntegrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SecurityIntegrations.
     */
    data: XOR<SecurityIntegrationUpdateManyMutationInput, SecurityIntegrationUncheckedUpdateManyInput>
    /**
     * Filter which SecurityIntegrations to update
     */
    where?: SecurityIntegrationWhereInput
    /**
     * Limit how many SecurityIntegrations to update.
     */
    limit?: number
  }

  /**
   * SecurityIntegration updateManyAndReturn
   */
  export type SecurityIntegrationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityIntegration
     */
    select?: SecurityIntegrationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityIntegration
     */
    omit?: SecurityIntegrationOmit<ExtArgs> | null
    /**
     * The data used to update SecurityIntegrations.
     */
    data: XOR<SecurityIntegrationUpdateManyMutationInput, SecurityIntegrationUncheckedUpdateManyInput>
    /**
     * Filter which SecurityIntegrations to update
     */
    where?: SecurityIntegrationWhereInput
    /**
     * Limit how many SecurityIntegrations to update.
     */
    limit?: number
  }

  /**
   * SecurityIntegration upsert
   */
  export type SecurityIntegrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityIntegration
     */
    select?: SecurityIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityIntegration
     */
    omit?: SecurityIntegrationOmit<ExtArgs> | null
    /**
     * The filter to search for the SecurityIntegration to update in case it exists.
     */
    where: SecurityIntegrationWhereUniqueInput
    /**
     * In case the SecurityIntegration found by the `where` argument doesn't exist, create a new SecurityIntegration with this data.
     */
    create: XOR<SecurityIntegrationCreateInput, SecurityIntegrationUncheckedCreateInput>
    /**
     * In case the SecurityIntegration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SecurityIntegrationUpdateInput, SecurityIntegrationUncheckedUpdateInput>
  }

  /**
   * SecurityIntegration delete
   */
  export type SecurityIntegrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityIntegration
     */
    select?: SecurityIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityIntegration
     */
    omit?: SecurityIntegrationOmit<ExtArgs> | null
    /**
     * Filter which SecurityIntegration to delete.
     */
    where: SecurityIntegrationWhereUniqueInput
  }

  /**
   * SecurityIntegration deleteMany
   */
  export type SecurityIntegrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecurityIntegrations to delete
     */
    where?: SecurityIntegrationWhereInput
    /**
     * Limit how many SecurityIntegrations to delete.
     */
    limit?: number
  }

  /**
   * SecurityIntegration without action
   */
  export type SecurityIntegrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityIntegration
     */
    select?: SecurityIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityIntegration
     */
    omit?: SecurityIntegrationOmit<ExtArgs> | null
  }


  /**
   * Model AdministrativeProfile
   */

  export type AggregateAdministrativeProfile = {
    _count: AdministrativeProfileCountAggregateOutputType | null
    _avg: AdministrativeProfileAvgAggregateOutputType | null
    _sum: AdministrativeProfileSumAggregateOutputType | null
    _min: AdministrativeProfileMinAggregateOutputType | null
    _max: AdministrativeProfileMaxAggregateOutputType | null
  }

  export type AdministrativeProfileAvgAggregateOutputType = {
    userId: number | null
  }

  export type AdministrativeProfileSumAggregateOutputType = {
    userId: number | null
  }

  export type AdministrativeProfileMinAggregateOutputType = {
    id: string | null
    userId: number | null
    adminLevel: string | null
    emergencyContact: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdministrativeProfileMaxAggregateOutputType = {
    id: string | null
    userId: number | null
    adminLevel: string | null
    emergencyContact: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdministrativeProfileCountAggregateOutputType = {
    id: number
    userId: number
    adminLevel: number
    departments: number
    responsibilities: number
    criticalPermissions: number
    emergencyContact: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdministrativeProfileAvgAggregateInputType = {
    userId?: true
  }

  export type AdministrativeProfileSumAggregateInputType = {
    userId?: true
  }

  export type AdministrativeProfileMinAggregateInputType = {
    id?: true
    userId?: true
    adminLevel?: true
    emergencyContact?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdministrativeProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    adminLevel?: true
    emergencyContact?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdministrativeProfileCountAggregateInputType = {
    id?: true
    userId?: true
    adminLevel?: true
    departments?: true
    responsibilities?: true
    criticalPermissions?: true
    emergencyContact?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdministrativeProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdministrativeProfile to aggregate.
     */
    where?: AdministrativeProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdministrativeProfiles to fetch.
     */
    orderBy?: AdministrativeProfileOrderByWithRelationInput | AdministrativeProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdministrativeProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdministrativeProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdministrativeProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdministrativeProfiles
    **/
    _count?: true | AdministrativeProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdministrativeProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdministrativeProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdministrativeProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdministrativeProfileMaxAggregateInputType
  }

  export type GetAdministrativeProfileAggregateType<T extends AdministrativeProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateAdministrativeProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdministrativeProfile[P]>
      : GetScalarType<T[P], AggregateAdministrativeProfile[P]>
  }




  export type AdministrativeProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdministrativeProfileWhereInput
    orderBy?: AdministrativeProfileOrderByWithAggregationInput | AdministrativeProfileOrderByWithAggregationInput[]
    by: AdministrativeProfileScalarFieldEnum[] | AdministrativeProfileScalarFieldEnum
    having?: AdministrativeProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdministrativeProfileCountAggregateInputType | true
    _avg?: AdministrativeProfileAvgAggregateInputType
    _sum?: AdministrativeProfileSumAggregateInputType
    _min?: AdministrativeProfileMinAggregateInputType
    _max?: AdministrativeProfileMaxAggregateInputType
  }

  export type AdministrativeProfileGroupByOutputType = {
    id: string
    userId: number
    adminLevel: string
    departments: string[]
    responsibilities: string[]
    criticalPermissions: string[]
    emergencyContact: string | null
    createdAt: Date
    updatedAt: Date
    _count: AdministrativeProfileCountAggregateOutputType | null
    _avg: AdministrativeProfileAvgAggregateOutputType | null
    _sum: AdministrativeProfileSumAggregateOutputType | null
    _min: AdministrativeProfileMinAggregateOutputType | null
    _max: AdministrativeProfileMaxAggregateOutputType | null
  }

  type GetAdministrativeProfileGroupByPayload<T extends AdministrativeProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdministrativeProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdministrativeProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdministrativeProfileGroupByOutputType[P]>
            : GetScalarType<T[P], AdministrativeProfileGroupByOutputType[P]>
        }
      >
    >


  export type AdministrativeProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    adminLevel?: boolean
    departments?: boolean
    responsibilities?: boolean
    criticalPermissions?: boolean
    emergencyContact?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["administrativeProfile"]>

  export type AdministrativeProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    adminLevel?: boolean
    departments?: boolean
    responsibilities?: boolean
    criticalPermissions?: boolean
    emergencyContact?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["administrativeProfile"]>

  export type AdministrativeProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    adminLevel?: boolean
    departments?: boolean
    responsibilities?: boolean
    criticalPermissions?: boolean
    emergencyContact?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["administrativeProfile"]>

  export type AdministrativeProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    adminLevel?: boolean
    departments?: boolean
    responsibilities?: boolean
    criticalPermissions?: boolean
    emergencyContact?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdministrativeProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "adminLevel" | "departments" | "responsibilities" | "criticalPermissions" | "emergencyContact" | "createdAt" | "updatedAt", ExtArgs["result"]["administrativeProfile"]>
  export type AdministrativeProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdministrativeProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdministrativeProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AdministrativeProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdministrativeProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: number
      adminLevel: string
      departments: string[]
      responsibilities: string[]
      criticalPermissions: string[]
      emergencyContact: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["administrativeProfile"]>
    composites: {}
  }

  type AdministrativeProfileGetPayload<S extends boolean | null | undefined | AdministrativeProfileDefaultArgs> = $Result.GetResult<Prisma.$AdministrativeProfilePayload, S>

  type AdministrativeProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdministrativeProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdministrativeProfileCountAggregateInputType | true
    }

  export interface AdministrativeProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdministrativeProfile'], meta: { name: 'AdministrativeProfile' } }
    /**
     * Find zero or one AdministrativeProfile that matches the filter.
     * @param {AdministrativeProfileFindUniqueArgs} args - Arguments to find a AdministrativeProfile
     * @example
     * // Get one AdministrativeProfile
     * const administrativeProfile = await prisma.administrativeProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdministrativeProfileFindUniqueArgs>(args: SelectSubset<T, AdministrativeProfileFindUniqueArgs<ExtArgs>>): Prisma__AdministrativeProfileClient<$Result.GetResult<Prisma.$AdministrativeProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdministrativeProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdministrativeProfileFindUniqueOrThrowArgs} args - Arguments to find a AdministrativeProfile
     * @example
     * // Get one AdministrativeProfile
     * const administrativeProfile = await prisma.administrativeProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdministrativeProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, AdministrativeProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdministrativeProfileClient<$Result.GetResult<Prisma.$AdministrativeProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdministrativeProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministrativeProfileFindFirstArgs} args - Arguments to find a AdministrativeProfile
     * @example
     * // Get one AdministrativeProfile
     * const administrativeProfile = await prisma.administrativeProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdministrativeProfileFindFirstArgs>(args?: SelectSubset<T, AdministrativeProfileFindFirstArgs<ExtArgs>>): Prisma__AdministrativeProfileClient<$Result.GetResult<Prisma.$AdministrativeProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdministrativeProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministrativeProfileFindFirstOrThrowArgs} args - Arguments to find a AdministrativeProfile
     * @example
     * // Get one AdministrativeProfile
     * const administrativeProfile = await prisma.administrativeProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdministrativeProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, AdministrativeProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdministrativeProfileClient<$Result.GetResult<Prisma.$AdministrativeProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdministrativeProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministrativeProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdministrativeProfiles
     * const administrativeProfiles = await prisma.administrativeProfile.findMany()
     * 
     * // Get first 10 AdministrativeProfiles
     * const administrativeProfiles = await prisma.administrativeProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const administrativeProfileWithIdOnly = await prisma.administrativeProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdministrativeProfileFindManyArgs>(args?: SelectSubset<T, AdministrativeProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdministrativeProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdministrativeProfile.
     * @param {AdministrativeProfileCreateArgs} args - Arguments to create a AdministrativeProfile.
     * @example
     * // Create one AdministrativeProfile
     * const AdministrativeProfile = await prisma.administrativeProfile.create({
     *   data: {
     *     // ... data to create a AdministrativeProfile
     *   }
     * })
     * 
     */
    create<T extends AdministrativeProfileCreateArgs>(args: SelectSubset<T, AdministrativeProfileCreateArgs<ExtArgs>>): Prisma__AdministrativeProfileClient<$Result.GetResult<Prisma.$AdministrativeProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdministrativeProfiles.
     * @param {AdministrativeProfileCreateManyArgs} args - Arguments to create many AdministrativeProfiles.
     * @example
     * // Create many AdministrativeProfiles
     * const administrativeProfile = await prisma.administrativeProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdministrativeProfileCreateManyArgs>(args?: SelectSubset<T, AdministrativeProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdministrativeProfiles and returns the data saved in the database.
     * @param {AdministrativeProfileCreateManyAndReturnArgs} args - Arguments to create many AdministrativeProfiles.
     * @example
     * // Create many AdministrativeProfiles
     * const administrativeProfile = await prisma.administrativeProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdministrativeProfiles and only return the `id`
     * const administrativeProfileWithIdOnly = await prisma.administrativeProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdministrativeProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, AdministrativeProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdministrativeProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdministrativeProfile.
     * @param {AdministrativeProfileDeleteArgs} args - Arguments to delete one AdministrativeProfile.
     * @example
     * // Delete one AdministrativeProfile
     * const AdministrativeProfile = await prisma.administrativeProfile.delete({
     *   where: {
     *     // ... filter to delete one AdministrativeProfile
     *   }
     * })
     * 
     */
    delete<T extends AdministrativeProfileDeleteArgs>(args: SelectSubset<T, AdministrativeProfileDeleteArgs<ExtArgs>>): Prisma__AdministrativeProfileClient<$Result.GetResult<Prisma.$AdministrativeProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdministrativeProfile.
     * @param {AdministrativeProfileUpdateArgs} args - Arguments to update one AdministrativeProfile.
     * @example
     * // Update one AdministrativeProfile
     * const administrativeProfile = await prisma.administrativeProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdministrativeProfileUpdateArgs>(args: SelectSubset<T, AdministrativeProfileUpdateArgs<ExtArgs>>): Prisma__AdministrativeProfileClient<$Result.GetResult<Prisma.$AdministrativeProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdministrativeProfiles.
     * @param {AdministrativeProfileDeleteManyArgs} args - Arguments to filter AdministrativeProfiles to delete.
     * @example
     * // Delete a few AdministrativeProfiles
     * const { count } = await prisma.administrativeProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdministrativeProfileDeleteManyArgs>(args?: SelectSubset<T, AdministrativeProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdministrativeProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministrativeProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdministrativeProfiles
     * const administrativeProfile = await prisma.administrativeProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdministrativeProfileUpdateManyArgs>(args: SelectSubset<T, AdministrativeProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdministrativeProfiles and returns the data updated in the database.
     * @param {AdministrativeProfileUpdateManyAndReturnArgs} args - Arguments to update many AdministrativeProfiles.
     * @example
     * // Update many AdministrativeProfiles
     * const administrativeProfile = await prisma.administrativeProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdministrativeProfiles and only return the `id`
     * const administrativeProfileWithIdOnly = await prisma.administrativeProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdministrativeProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, AdministrativeProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdministrativeProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdministrativeProfile.
     * @param {AdministrativeProfileUpsertArgs} args - Arguments to update or create a AdministrativeProfile.
     * @example
     * // Update or create a AdministrativeProfile
     * const administrativeProfile = await prisma.administrativeProfile.upsert({
     *   create: {
     *     // ... data to create a AdministrativeProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdministrativeProfile we want to update
     *   }
     * })
     */
    upsert<T extends AdministrativeProfileUpsertArgs>(args: SelectSubset<T, AdministrativeProfileUpsertArgs<ExtArgs>>): Prisma__AdministrativeProfileClient<$Result.GetResult<Prisma.$AdministrativeProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdministrativeProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministrativeProfileCountArgs} args - Arguments to filter AdministrativeProfiles to count.
     * @example
     * // Count the number of AdministrativeProfiles
     * const count = await prisma.administrativeProfile.count({
     *   where: {
     *     // ... the filter for the AdministrativeProfiles we want to count
     *   }
     * })
    **/
    count<T extends AdministrativeProfileCountArgs>(
      args?: Subset<T, AdministrativeProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdministrativeProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdministrativeProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministrativeProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdministrativeProfileAggregateArgs>(args: Subset<T, AdministrativeProfileAggregateArgs>): Prisma.PrismaPromise<GetAdministrativeProfileAggregateType<T>>

    /**
     * Group by AdministrativeProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministrativeProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdministrativeProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdministrativeProfileGroupByArgs['orderBy'] }
        : { orderBy?: AdministrativeProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdministrativeProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdministrativeProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdministrativeProfile model
   */
  readonly fields: AdministrativeProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdministrativeProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdministrativeProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdministrativeProfile model
   */
  interface AdministrativeProfileFieldRefs {
    readonly id: FieldRef<"AdministrativeProfile", 'String'>
    readonly userId: FieldRef<"AdministrativeProfile", 'Int'>
    readonly adminLevel: FieldRef<"AdministrativeProfile", 'String'>
    readonly departments: FieldRef<"AdministrativeProfile", 'String[]'>
    readonly responsibilities: FieldRef<"AdministrativeProfile", 'String[]'>
    readonly criticalPermissions: FieldRef<"AdministrativeProfile", 'String[]'>
    readonly emergencyContact: FieldRef<"AdministrativeProfile", 'String'>
    readonly createdAt: FieldRef<"AdministrativeProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"AdministrativeProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdministrativeProfile findUnique
   */
  export type AdministrativeProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdministrativeProfile
     */
    select?: AdministrativeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdministrativeProfile
     */
    omit?: AdministrativeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministrativeProfileInclude<ExtArgs> | null
    /**
     * Filter, which AdministrativeProfile to fetch.
     */
    where: AdministrativeProfileWhereUniqueInput
  }

  /**
   * AdministrativeProfile findUniqueOrThrow
   */
  export type AdministrativeProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdministrativeProfile
     */
    select?: AdministrativeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdministrativeProfile
     */
    omit?: AdministrativeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministrativeProfileInclude<ExtArgs> | null
    /**
     * Filter, which AdministrativeProfile to fetch.
     */
    where: AdministrativeProfileWhereUniqueInput
  }

  /**
   * AdministrativeProfile findFirst
   */
  export type AdministrativeProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdministrativeProfile
     */
    select?: AdministrativeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdministrativeProfile
     */
    omit?: AdministrativeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministrativeProfileInclude<ExtArgs> | null
    /**
     * Filter, which AdministrativeProfile to fetch.
     */
    where?: AdministrativeProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdministrativeProfiles to fetch.
     */
    orderBy?: AdministrativeProfileOrderByWithRelationInput | AdministrativeProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdministrativeProfiles.
     */
    cursor?: AdministrativeProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdministrativeProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdministrativeProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdministrativeProfiles.
     */
    distinct?: AdministrativeProfileScalarFieldEnum | AdministrativeProfileScalarFieldEnum[]
  }

  /**
   * AdministrativeProfile findFirstOrThrow
   */
  export type AdministrativeProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdministrativeProfile
     */
    select?: AdministrativeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdministrativeProfile
     */
    omit?: AdministrativeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministrativeProfileInclude<ExtArgs> | null
    /**
     * Filter, which AdministrativeProfile to fetch.
     */
    where?: AdministrativeProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdministrativeProfiles to fetch.
     */
    orderBy?: AdministrativeProfileOrderByWithRelationInput | AdministrativeProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdministrativeProfiles.
     */
    cursor?: AdministrativeProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdministrativeProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdministrativeProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdministrativeProfiles.
     */
    distinct?: AdministrativeProfileScalarFieldEnum | AdministrativeProfileScalarFieldEnum[]
  }

  /**
   * AdministrativeProfile findMany
   */
  export type AdministrativeProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdministrativeProfile
     */
    select?: AdministrativeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdministrativeProfile
     */
    omit?: AdministrativeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministrativeProfileInclude<ExtArgs> | null
    /**
     * Filter, which AdministrativeProfiles to fetch.
     */
    where?: AdministrativeProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdministrativeProfiles to fetch.
     */
    orderBy?: AdministrativeProfileOrderByWithRelationInput | AdministrativeProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdministrativeProfiles.
     */
    cursor?: AdministrativeProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdministrativeProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdministrativeProfiles.
     */
    skip?: number
    distinct?: AdministrativeProfileScalarFieldEnum | AdministrativeProfileScalarFieldEnum[]
  }

  /**
   * AdministrativeProfile create
   */
  export type AdministrativeProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdministrativeProfile
     */
    select?: AdministrativeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdministrativeProfile
     */
    omit?: AdministrativeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministrativeProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a AdministrativeProfile.
     */
    data: XOR<AdministrativeProfileCreateInput, AdministrativeProfileUncheckedCreateInput>
  }

  /**
   * AdministrativeProfile createMany
   */
  export type AdministrativeProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdministrativeProfiles.
     */
    data: AdministrativeProfileCreateManyInput | AdministrativeProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdministrativeProfile createManyAndReturn
   */
  export type AdministrativeProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdministrativeProfile
     */
    select?: AdministrativeProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdministrativeProfile
     */
    omit?: AdministrativeProfileOmit<ExtArgs> | null
    /**
     * The data used to create many AdministrativeProfiles.
     */
    data: AdministrativeProfileCreateManyInput | AdministrativeProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministrativeProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdministrativeProfile update
   */
  export type AdministrativeProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdministrativeProfile
     */
    select?: AdministrativeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdministrativeProfile
     */
    omit?: AdministrativeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministrativeProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a AdministrativeProfile.
     */
    data: XOR<AdministrativeProfileUpdateInput, AdministrativeProfileUncheckedUpdateInput>
    /**
     * Choose, which AdministrativeProfile to update.
     */
    where: AdministrativeProfileWhereUniqueInput
  }

  /**
   * AdministrativeProfile updateMany
   */
  export type AdministrativeProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdministrativeProfiles.
     */
    data: XOR<AdministrativeProfileUpdateManyMutationInput, AdministrativeProfileUncheckedUpdateManyInput>
    /**
     * Filter which AdministrativeProfiles to update
     */
    where?: AdministrativeProfileWhereInput
    /**
     * Limit how many AdministrativeProfiles to update.
     */
    limit?: number
  }

  /**
   * AdministrativeProfile updateManyAndReturn
   */
  export type AdministrativeProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdministrativeProfile
     */
    select?: AdministrativeProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdministrativeProfile
     */
    omit?: AdministrativeProfileOmit<ExtArgs> | null
    /**
     * The data used to update AdministrativeProfiles.
     */
    data: XOR<AdministrativeProfileUpdateManyMutationInput, AdministrativeProfileUncheckedUpdateManyInput>
    /**
     * Filter which AdministrativeProfiles to update
     */
    where?: AdministrativeProfileWhereInput
    /**
     * Limit how many AdministrativeProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministrativeProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdministrativeProfile upsert
   */
  export type AdministrativeProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdministrativeProfile
     */
    select?: AdministrativeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdministrativeProfile
     */
    omit?: AdministrativeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministrativeProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the AdministrativeProfile to update in case it exists.
     */
    where: AdministrativeProfileWhereUniqueInput
    /**
     * In case the AdministrativeProfile found by the `where` argument doesn't exist, create a new AdministrativeProfile with this data.
     */
    create: XOR<AdministrativeProfileCreateInput, AdministrativeProfileUncheckedCreateInput>
    /**
     * In case the AdministrativeProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdministrativeProfileUpdateInput, AdministrativeProfileUncheckedUpdateInput>
  }

  /**
   * AdministrativeProfile delete
   */
  export type AdministrativeProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdministrativeProfile
     */
    select?: AdministrativeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdministrativeProfile
     */
    omit?: AdministrativeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministrativeProfileInclude<ExtArgs> | null
    /**
     * Filter which AdministrativeProfile to delete.
     */
    where: AdministrativeProfileWhereUniqueInput
  }

  /**
   * AdministrativeProfile deleteMany
   */
  export type AdministrativeProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdministrativeProfiles to delete
     */
    where?: AdministrativeProfileWhereInput
    /**
     * Limit how many AdministrativeProfiles to delete.
     */
    limit?: number
  }

  /**
   * AdministrativeProfile without action
   */
  export type AdministrativeProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdministrativeProfile
     */
    select?: AdministrativeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdministrativeProfile
     */
    omit?: AdministrativeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministrativeProfileInclude<ExtArgs> | null
  }


  /**
   * Model CustomRole
   */

  export type AggregateCustomRole = {
    _count: CustomRoleCountAggregateOutputType | null
    _min: CustomRoleMinAggregateOutputType | null
    _max: CustomRoleMaxAggregateOutputType | null
  }

  export type CustomRoleMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    parentRole: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomRoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    parentRole: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomRoleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    permissions: number
    parentRole: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomRoleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    parentRole?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomRoleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    parentRole?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomRoleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    permissions?: true
    parentRole?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomRole to aggregate.
     */
    where?: CustomRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomRoles to fetch.
     */
    orderBy?: CustomRoleOrderByWithRelationInput | CustomRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomRoles
    **/
    _count?: true | CustomRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomRoleMaxAggregateInputType
  }

  export type GetCustomRoleAggregateType<T extends CustomRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomRole[P]>
      : GetScalarType<T[P], AggregateCustomRole[P]>
  }




  export type CustomRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomRoleWhereInput
    orderBy?: CustomRoleOrderByWithAggregationInput | CustomRoleOrderByWithAggregationInput[]
    by: CustomRoleScalarFieldEnum[] | CustomRoleScalarFieldEnum
    having?: CustomRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomRoleCountAggregateInputType | true
    _min?: CustomRoleMinAggregateInputType
    _max?: CustomRoleMaxAggregateInputType
  }

  export type CustomRoleGroupByOutputType = {
    id: string
    name: string
    description: string | null
    permissions: string[]
    parentRole: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CustomRoleCountAggregateOutputType | null
    _min: CustomRoleMinAggregateOutputType | null
    _max: CustomRoleMaxAggregateOutputType | null
  }

  type GetCustomRoleGroupByPayload<T extends CustomRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomRoleGroupByOutputType[P]>
            : GetScalarType<T[P], CustomRoleGroupByOutputType[P]>
        }
      >
    >


  export type CustomRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    permissions?: boolean
    parentRole?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hierarchy?: boolean | CustomRole$hierarchyArgs<ExtArgs>
  }, ExtArgs["result"]["customRole"]>

  export type CustomRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    permissions?: boolean
    parentRole?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customRole"]>

  export type CustomRoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    permissions?: boolean
    parentRole?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customRole"]>

  export type CustomRoleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    permissions?: boolean
    parentRole?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomRoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "permissions" | "parentRole" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["customRole"]>
  export type CustomRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hierarchy?: boolean | CustomRole$hierarchyArgs<ExtArgs>
  }
  export type CustomRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CustomRoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CustomRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomRole"
    objects: {
      hierarchy: Prisma.$RoleHierarchyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      permissions: string[]
      parentRole: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customRole"]>
    composites: {}
  }

  type CustomRoleGetPayload<S extends boolean | null | undefined | CustomRoleDefaultArgs> = $Result.GetResult<Prisma.$CustomRolePayload, S>

  type CustomRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomRoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomRoleCountAggregateInputType | true
    }

  export interface CustomRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomRole'], meta: { name: 'CustomRole' } }
    /**
     * Find zero or one CustomRole that matches the filter.
     * @param {CustomRoleFindUniqueArgs} args - Arguments to find a CustomRole
     * @example
     * // Get one CustomRole
     * const customRole = await prisma.customRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomRoleFindUniqueArgs>(args: SelectSubset<T, CustomRoleFindUniqueArgs<ExtArgs>>): Prisma__CustomRoleClient<$Result.GetResult<Prisma.$CustomRolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomRoleFindUniqueOrThrowArgs} args - Arguments to find a CustomRole
     * @example
     * // Get one CustomRole
     * const customRole = await prisma.customRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomRoleClient<$Result.GetResult<Prisma.$CustomRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomRoleFindFirstArgs} args - Arguments to find a CustomRole
     * @example
     * // Get one CustomRole
     * const customRole = await prisma.customRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomRoleFindFirstArgs>(args?: SelectSubset<T, CustomRoleFindFirstArgs<ExtArgs>>): Prisma__CustomRoleClient<$Result.GetResult<Prisma.$CustomRolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomRoleFindFirstOrThrowArgs} args - Arguments to find a CustomRole
     * @example
     * // Get one CustomRole
     * const customRole = await prisma.customRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomRoleClient<$Result.GetResult<Prisma.$CustomRolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomRoles
     * const customRoles = await prisma.customRole.findMany()
     * 
     * // Get first 10 CustomRoles
     * const customRoles = await prisma.customRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customRoleWithIdOnly = await prisma.customRole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomRoleFindManyArgs>(args?: SelectSubset<T, CustomRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomRole.
     * @param {CustomRoleCreateArgs} args - Arguments to create a CustomRole.
     * @example
     * // Create one CustomRole
     * const CustomRole = await prisma.customRole.create({
     *   data: {
     *     // ... data to create a CustomRole
     *   }
     * })
     * 
     */
    create<T extends CustomRoleCreateArgs>(args: SelectSubset<T, CustomRoleCreateArgs<ExtArgs>>): Prisma__CustomRoleClient<$Result.GetResult<Prisma.$CustomRolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomRoles.
     * @param {CustomRoleCreateManyArgs} args - Arguments to create many CustomRoles.
     * @example
     * // Create many CustomRoles
     * const customRole = await prisma.customRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomRoleCreateManyArgs>(args?: SelectSubset<T, CustomRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomRoles and returns the data saved in the database.
     * @param {CustomRoleCreateManyAndReturnArgs} args - Arguments to create many CustomRoles.
     * @example
     * // Create many CustomRoles
     * const customRole = await prisma.customRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomRoles and only return the `id`
     * const customRoleWithIdOnly = await prisma.customRole.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomRolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomRole.
     * @param {CustomRoleDeleteArgs} args - Arguments to delete one CustomRole.
     * @example
     * // Delete one CustomRole
     * const CustomRole = await prisma.customRole.delete({
     *   where: {
     *     // ... filter to delete one CustomRole
     *   }
     * })
     * 
     */
    delete<T extends CustomRoleDeleteArgs>(args: SelectSubset<T, CustomRoleDeleteArgs<ExtArgs>>): Prisma__CustomRoleClient<$Result.GetResult<Prisma.$CustomRolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomRole.
     * @param {CustomRoleUpdateArgs} args - Arguments to update one CustomRole.
     * @example
     * // Update one CustomRole
     * const customRole = await prisma.customRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomRoleUpdateArgs>(args: SelectSubset<T, CustomRoleUpdateArgs<ExtArgs>>): Prisma__CustomRoleClient<$Result.GetResult<Prisma.$CustomRolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomRoles.
     * @param {CustomRoleDeleteManyArgs} args - Arguments to filter CustomRoles to delete.
     * @example
     * // Delete a few CustomRoles
     * const { count } = await prisma.customRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomRoleDeleteManyArgs>(args?: SelectSubset<T, CustomRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomRoles
     * const customRole = await prisma.customRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomRoleUpdateManyArgs>(args: SelectSubset<T, CustomRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomRoles and returns the data updated in the database.
     * @param {CustomRoleUpdateManyAndReturnArgs} args - Arguments to update many CustomRoles.
     * @example
     * // Update many CustomRoles
     * const customRole = await prisma.customRole.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomRoles and only return the `id`
     * const customRoleWithIdOnly = await prisma.customRole.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomRoleUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomRoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomRolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomRole.
     * @param {CustomRoleUpsertArgs} args - Arguments to update or create a CustomRole.
     * @example
     * // Update or create a CustomRole
     * const customRole = await prisma.customRole.upsert({
     *   create: {
     *     // ... data to create a CustomRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomRole we want to update
     *   }
     * })
     */
    upsert<T extends CustomRoleUpsertArgs>(args: SelectSubset<T, CustomRoleUpsertArgs<ExtArgs>>): Prisma__CustomRoleClient<$Result.GetResult<Prisma.$CustomRolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomRoleCountArgs} args - Arguments to filter CustomRoles to count.
     * @example
     * // Count the number of CustomRoles
     * const count = await prisma.customRole.count({
     *   where: {
     *     // ... the filter for the CustomRoles we want to count
     *   }
     * })
    **/
    count<T extends CustomRoleCountArgs>(
      args?: Subset<T, CustomRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomRoleAggregateArgs>(args: Subset<T, CustomRoleAggregateArgs>): Prisma.PrismaPromise<GetCustomRoleAggregateType<T>>

    /**
     * Group by CustomRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomRoleGroupByArgs['orderBy'] }
        : { orderBy?: CustomRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomRole model
   */
  readonly fields: CustomRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hierarchy<T extends CustomRole$hierarchyArgs<ExtArgs> = {}>(args?: Subset<T, CustomRole$hierarchyArgs<ExtArgs>>): Prisma__RoleHierarchyClient<$Result.GetResult<Prisma.$RoleHierarchyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomRole model
   */
  interface CustomRoleFieldRefs {
    readonly id: FieldRef<"CustomRole", 'String'>
    readonly name: FieldRef<"CustomRole", 'String'>
    readonly description: FieldRef<"CustomRole", 'String'>
    readonly permissions: FieldRef<"CustomRole", 'String[]'>
    readonly parentRole: FieldRef<"CustomRole", 'String'>
    readonly isActive: FieldRef<"CustomRole", 'Boolean'>
    readonly createdAt: FieldRef<"CustomRole", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomRole", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomRole findUnique
   */
  export type CustomRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomRole
     */
    select?: CustomRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomRole
     */
    omit?: CustomRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomRoleInclude<ExtArgs> | null
    /**
     * Filter, which CustomRole to fetch.
     */
    where: CustomRoleWhereUniqueInput
  }

  /**
   * CustomRole findUniqueOrThrow
   */
  export type CustomRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomRole
     */
    select?: CustomRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomRole
     */
    omit?: CustomRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomRoleInclude<ExtArgs> | null
    /**
     * Filter, which CustomRole to fetch.
     */
    where: CustomRoleWhereUniqueInput
  }

  /**
   * CustomRole findFirst
   */
  export type CustomRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomRole
     */
    select?: CustomRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomRole
     */
    omit?: CustomRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomRoleInclude<ExtArgs> | null
    /**
     * Filter, which CustomRole to fetch.
     */
    where?: CustomRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomRoles to fetch.
     */
    orderBy?: CustomRoleOrderByWithRelationInput | CustomRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomRoles.
     */
    cursor?: CustomRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomRoles.
     */
    distinct?: CustomRoleScalarFieldEnum | CustomRoleScalarFieldEnum[]
  }

  /**
   * CustomRole findFirstOrThrow
   */
  export type CustomRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomRole
     */
    select?: CustomRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomRole
     */
    omit?: CustomRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomRoleInclude<ExtArgs> | null
    /**
     * Filter, which CustomRole to fetch.
     */
    where?: CustomRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomRoles to fetch.
     */
    orderBy?: CustomRoleOrderByWithRelationInput | CustomRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomRoles.
     */
    cursor?: CustomRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomRoles.
     */
    distinct?: CustomRoleScalarFieldEnum | CustomRoleScalarFieldEnum[]
  }

  /**
   * CustomRole findMany
   */
  export type CustomRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomRole
     */
    select?: CustomRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomRole
     */
    omit?: CustomRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomRoleInclude<ExtArgs> | null
    /**
     * Filter, which CustomRoles to fetch.
     */
    where?: CustomRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomRoles to fetch.
     */
    orderBy?: CustomRoleOrderByWithRelationInput | CustomRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomRoles.
     */
    cursor?: CustomRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomRoles.
     */
    skip?: number
    distinct?: CustomRoleScalarFieldEnum | CustomRoleScalarFieldEnum[]
  }

  /**
   * CustomRole create
   */
  export type CustomRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomRole
     */
    select?: CustomRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomRole
     */
    omit?: CustomRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomRole.
     */
    data: XOR<CustomRoleCreateInput, CustomRoleUncheckedCreateInput>
  }

  /**
   * CustomRole createMany
   */
  export type CustomRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomRoles.
     */
    data: CustomRoleCreateManyInput | CustomRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomRole createManyAndReturn
   */
  export type CustomRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomRole
     */
    select?: CustomRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomRole
     */
    omit?: CustomRoleOmit<ExtArgs> | null
    /**
     * The data used to create many CustomRoles.
     */
    data: CustomRoleCreateManyInput | CustomRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomRole update
   */
  export type CustomRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomRole
     */
    select?: CustomRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomRole
     */
    omit?: CustomRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomRole.
     */
    data: XOR<CustomRoleUpdateInput, CustomRoleUncheckedUpdateInput>
    /**
     * Choose, which CustomRole to update.
     */
    where: CustomRoleWhereUniqueInput
  }

  /**
   * CustomRole updateMany
   */
  export type CustomRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomRoles.
     */
    data: XOR<CustomRoleUpdateManyMutationInput, CustomRoleUncheckedUpdateManyInput>
    /**
     * Filter which CustomRoles to update
     */
    where?: CustomRoleWhereInput
    /**
     * Limit how many CustomRoles to update.
     */
    limit?: number
  }

  /**
   * CustomRole updateManyAndReturn
   */
  export type CustomRoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomRole
     */
    select?: CustomRoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomRole
     */
    omit?: CustomRoleOmit<ExtArgs> | null
    /**
     * The data used to update CustomRoles.
     */
    data: XOR<CustomRoleUpdateManyMutationInput, CustomRoleUncheckedUpdateManyInput>
    /**
     * Filter which CustomRoles to update
     */
    where?: CustomRoleWhereInput
    /**
     * Limit how many CustomRoles to update.
     */
    limit?: number
  }

  /**
   * CustomRole upsert
   */
  export type CustomRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomRole
     */
    select?: CustomRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomRole
     */
    omit?: CustomRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomRole to update in case it exists.
     */
    where: CustomRoleWhereUniqueInput
    /**
     * In case the CustomRole found by the `where` argument doesn't exist, create a new CustomRole with this data.
     */
    create: XOR<CustomRoleCreateInput, CustomRoleUncheckedCreateInput>
    /**
     * In case the CustomRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomRoleUpdateInput, CustomRoleUncheckedUpdateInput>
  }

  /**
   * CustomRole delete
   */
  export type CustomRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomRole
     */
    select?: CustomRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomRole
     */
    omit?: CustomRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomRoleInclude<ExtArgs> | null
    /**
     * Filter which CustomRole to delete.
     */
    where: CustomRoleWhereUniqueInput
  }

  /**
   * CustomRole deleteMany
   */
  export type CustomRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomRoles to delete
     */
    where?: CustomRoleWhereInput
    /**
     * Limit how many CustomRoles to delete.
     */
    limit?: number
  }

  /**
   * CustomRole.hierarchy
   */
  export type CustomRole$hierarchyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleHierarchy
     */
    select?: RoleHierarchySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleHierarchy
     */
    omit?: RoleHierarchyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleHierarchyInclude<ExtArgs> | null
    where?: RoleHierarchyWhereInput
  }

  /**
   * CustomRole without action
   */
  export type CustomRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomRole
     */
    select?: CustomRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomRole
     */
    omit?: CustomRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomRoleInclude<ExtArgs> | null
  }


  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: string | null
    action: string | null
    resource: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: string | null
    action: string | null
    resource: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    name: number
    description: number
    category: number
    action: number
    resource: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PermissionMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    action?: true
    resource?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    action?: true
    resource?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    action?: true
    resource?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    id: string
    name: string
    description: string | null
    category: string
    action: string
    resource: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    action?: boolean
    resource?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    action?: boolean
    resource?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    action?: boolean
    resource?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    action?: boolean
    resource?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "category" | "action" | "resource" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["permission"]>

  export type $PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permission"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      category: string
      action: string
      resource: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionFindManyArgs>(args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends PermissionCreateArgs>(args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionCreateManyArgs>(args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permissions and returns the data saved in the database.
     * @param {PermissionCreateManyAndReturnArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, PermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends PermissionDeleteArgs>(args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionUpdateArgs>(args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionDeleteManyArgs>(args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionUpdateManyArgs>(args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions and returns the data updated in the database.
     * @param {PermissionUpdateManyAndReturnArgs} args - Arguments to update many Permissions.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, PermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permission model
   */
  readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permission model
   */
  interface PermissionFieldRefs {
    readonly id: FieldRef<"Permission", 'String'>
    readonly name: FieldRef<"Permission", 'String'>
    readonly description: FieldRef<"Permission", 'String'>
    readonly category: FieldRef<"Permission", 'String'>
    readonly action: FieldRef<"Permission", 'String'>
    readonly resource: FieldRef<"Permission", 'String'>
    readonly isActive: FieldRef<"Permission", 'Boolean'>
    readonly createdAt: FieldRef<"Permission", 'DateTime'>
    readonly updatedAt: FieldRef<"Permission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission createManyAndReturn
   */
  export type PermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission updateManyAndReturn
   */
  export type PermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to delete.
     */
    limit?: number
  }

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
  }


  /**
   * Model RoleHierarchy
   */

  export type AggregateRoleHierarchy = {
    _count: RoleHierarchyCountAggregateOutputType | null
    _avg: RoleHierarchyAvgAggregateOutputType | null
    _sum: RoleHierarchySumAggregateOutputType | null
    _min: RoleHierarchyMinAggregateOutputType | null
    _max: RoleHierarchyMaxAggregateOutputType | null
  }

  export type RoleHierarchyAvgAggregateOutputType = {
    level: number | null
  }

  export type RoleHierarchySumAggregateOutputType = {
    level: number | null
  }

  export type RoleHierarchyMinAggregateOutputType = {
    id: string | null
    roleId: string | null
    parentId: string | null
    level: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleHierarchyMaxAggregateOutputType = {
    id: string | null
    roleId: string | null
    parentId: string | null
    level: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleHierarchyCountAggregateOutputType = {
    id: number
    roleId: number
    parentId: number
    level: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleHierarchyAvgAggregateInputType = {
    level?: true
  }

  export type RoleHierarchySumAggregateInputType = {
    level?: true
  }

  export type RoleHierarchyMinAggregateInputType = {
    id?: true
    roleId?: true
    parentId?: true
    level?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleHierarchyMaxAggregateInputType = {
    id?: true
    roleId?: true
    parentId?: true
    level?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleHierarchyCountAggregateInputType = {
    id?: true
    roleId?: true
    parentId?: true
    level?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleHierarchyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoleHierarchy to aggregate.
     */
    where?: RoleHierarchyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleHierarchies to fetch.
     */
    orderBy?: RoleHierarchyOrderByWithRelationInput | RoleHierarchyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleHierarchyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleHierarchies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleHierarchies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoleHierarchies
    **/
    _count?: true | RoleHierarchyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleHierarchyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleHierarchySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleHierarchyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleHierarchyMaxAggregateInputType
  }

  export type GetRoleHierarchyAggregateType<T extends RoleHierarchyAggregateArgs> = {
        [P in keyof T & keyof AggregateRoleHierarchy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoleHierarchy[P]>
      : GetScalarType<T[P], AggregateRoleHierarchy[P]>
  }




  export type RoleHierarchyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleHierarchyWhereInput
    orderBy?: RoleHierarchyOrderByWithAggregationInput | RoleHierarchyOrderByWithAggregationInput[]
    by: RoleHierarchyScalarFieldEnum[] | RoleHierarchyScalarFieldEnum
    having?: RoleHierarchyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleHierarchyCountAggregateInputType | true
    _avg?: RoleHierarchyAvgAggregateInputType
    _sum?: RoleHierarchySumAggregateInputType
    _min?: RoleHierarchyMinAggregateInputType
    _max?: RoleHierarchyMaxAggregateInputType
  }

  export type RoleHierarchyGroupByOutputType = {
    id: string
    roleId: string
    parentId: string | null
    level: number
    createdAt: Date
    updatedAt: Date
    _count: RoleHierarchyCountAggregateOutputType | null
    _avg: RoleHierarchyAvgAggregateOutputType | null
    _sum: RoleHierarchySumAggregateOutputType | null
    _min: RoleHierarchyMinAggregateOutputType | null
    _max: RoleHierarchyMaxAggregateOutputType | null
  }

  type GetRoleHierarchyGroupByPayload<T extends RoleHierarchyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleHierarchyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleHierarchyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleHierarchyGroupByOutputType[P]>
            : GetScalarType<T[P], RoleHierarchyGroupByOutputType[P]>
        }
      >
    >


  export type RoleHierarchySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    parentId?: boolean
    level?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | RoleHierarchy$parentArgs<ExtArgs>
    children?: boolean | RoleHierarchy$childrenArgs<ExtArgs>
    role?: boolean | CustomRoleDefaultArgs<ExtArgs>
    _count?: boolean | RoleHierarchyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roleHierarchy"]>

  export type RoleHierarchySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    parentId?: boolean
    level?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | RoleHierarchy$parentArgs<ExtArgs>
    role?: boolean | CustomRoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roleHierarchy"]>

  export type RoleHierarchySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    parentId?: boolean
    level?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | RoleHierarchy$parentArgs<ExtArgs>
    role?: boolean | CustomRoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roleHierarchy"]>

  export type RoleHierarchySelectScalar = {
    id?: boolean
    roleId?: boolean
    parentId?: boolean
    level?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleHierarchyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roleId" | "parentId" | "level" | "createdAt" | "updatedAt", ExtArgs["result"]["roleHierarchy"]>
  export type RoleHierarchyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | RoleHierarchy$parentArgs<ExtArgs>
    children?: boolean | RoleHierarchy$childrenArgs<ExtArgs>
    role?: boolean | CustomRoleDefaultArgs<ExtArgs>
    _count?: boolean | RoleHierarchyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleHierarchyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | RoleHierarchy$parentArgs<ExtArgs>
    role?: boolean | CustomRoleDefaultArgs<ExtArgs>
  }
  export type RoleHierarchyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | RoleHierarchy$parentArgs<ExtArgs>
    role?: boolean | CustomRoleDefaultArgs<ExtArgs>
  }

  export type $RoleHierarchyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoleHierarchy"
    objects: {
      parent: Prisma.$RoleHierarchyPayload<ExtArgs> | null
      children: Prisma.$RoleHierarchyPayload<ExtArgs>[]
      role: Prisma.$CustomRolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roleId: string
      parentId: string | null
      level: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["roleHierarchy"]>
    composites: {}
  }

  type RoleHierarchyGetPayload<S extends boolean | null | undefined | RoleHierarchyDefaultArgs> = $Result.GetResult<Prisma.$RoleHierarchyPayload, S>

  type RoleHierarchyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleHierarchyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleHierarchyCountAggregateInputType | true
    }

  export interface RoleHierarchyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoleHierarchy'], meta: { name: 'RoleHierarchy' } }
    /**
     * Find zero or one RoleHierarchy that matches the filter.
     * @param {RoleHierarchyFindUniqueArgs} args - Arguments to find a RoleHierarchy
     * @example
     * // Get one RoleHierarchy
     * const roleHierarchy = await prisma.roleHierarchy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleHierarchyFindUniqueArgs>(args: SelectSubset<T, RoleHierarchyFindUniqueArgs<ExtArgs>>): Prisma__RoleHierarchyClient<$Result.GetResult<Prisma.$RoleHierarchyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RoleHierarchy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleHierarchyFindUniqueOrThrowArgs} args - Arguments to find a RoleHierarchy
     * @example
     * // Get one RoleHierarchy
     * const roleHierarchy = await prisma.roleHierarchy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleHierarchyFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleHierarchyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleHierarchyClient<$Result.GetResult<Prisma.$RoleHierarchyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoleHierarchy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleHierarchyFindFirstArgs} args - Arguments to find a RoleHierarchy
     * @example
     * // Get one RoleHierarchy
     * const roleHierarchy = await prisma.roleHierarchy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleHierarchyFindFirstArgs>(args?: SelectSubset<T, RoleHierarchyFindFirstArgs<ExtArgs>>): Prisma__RoleHierarchyClient<$Result.GetResult<Prisma.$RoleHierarchyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoleHierarchy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleHierarchyFindFirstOrThrowArgs} args - Arguments to find a RoleHierarchy
     * @example
     * // Get one RoleHierarchy
     * const roleHierarchy = await prisma.roleHierarchy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleHierarchyFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleHierarchyFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleHierarchyClient<$Result.GetResult<Prisma.$RoleHierarchyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RoleHierarchies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleHierarchyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoleHierarchies
     * const roleHierarchies = await prisma.roleHierarchy.findMany()
     * 
     * // Get first 10 RoleHierarchies
     * const roleHierarchies = await prisma.roleHierarchy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleHierarchyWithIdOnly = await prisma.roleHierarchy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleHierarchyFindManyArgs>(args?: SelectSubset<T, RoleHierarchyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleHierarchyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RoleHierarchy.
     * @param {RoleHierarchyCreateArgs} args - Arguments to create a RoleHierarchy.
     * @example
     * // Create one RoleHierarchy
     * const RoleHierarchy = await prisma.roleHierarchy.create({
     *   data: {
     *     // ... data to create a RoleHierarchy
     *   }
     * })
     * 
     */
    create<T extends RoleHierarchyCreateArgs>(args: SelectSubset<T, RoleHierarchyCreateArgs<ExtArgs>>): Prisma__RoleHierarchyClient<$Result.GetResult<Prisma.$RoleHierarchyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RoleHierarchies.
     * @param {RoleHierarchyCreateManyArgs} args - Arguments to create many RoleHierarchies.
     * @example
     * // Create many RoleHierarchies
     * const roleHierarchy = await prisma.roleHierarchy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleHierarchyCreateManyArgs>(args?: SelectSubset<T, RoleHierarchyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoleHierarchies and returns the data saved in the database.
     * @param {RoleHierarchyCreateManyAndReturnArgs} args - Arguments to create many RoleHierarchies.
     * @example
     * // Create many RoleHierarchies
     * const roleHierarchy = await prisma.roleHierarchy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoleHierarchies and only return the `id`
     * const roleHierarchyWithIdOnly = await prisma.roleHierarchy.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleHierarchyCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleHierarchyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleHierarchyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RoleHierarchy.
     * @param {RoleHierarchyDeleteArgs} args - Arguments to delete one RoleHierarchy.
     * @example
     * // Delete one RoleHierarchy
     * const RoleHierarchy = await prisma.roleHierarchy.delete({
     *   where: {
     *     // ... filter to delete one RoleHierarchy
     *   }
     * })
     * 
     */
    delete<T extends RoleHierarchyDeleteArgs>(args: SelectSubset<T, RoleHierarchyDeleteArgs<ExtArgs>>): Prisma__RoleHierarchyClient<$Result.GetResult<Prisma.$RoleHierarchyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RoleHierarchy.
     * @param {RoleHierarchyUpdateArgs} args - Arguments to update one RoleHierarchy.
     * @example
     * // Update one RoleHierarchy
     * const roleHierarchy = await prisma.roleHierarchy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleHierarchyUpdateArgs>(args: SelectSubset<T, RoleHierarchyUpdateArgs<ExtArgs>>): Prisma__RoleHierarchyClient<$Result.GetResult<Prisma.$RoleHierarchyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RoleHierarchies.
     * @param {RoleHierarchyDeleteManyArgs} args - Arguments to filter RoleHierarchies to delete.
     * @example
     * // Delete a few RoleHierarchies
     * const { count } = await prisma.roleHierarchy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleHierarchyDeleteManyArgs>(args?: SelectSubset<T, RoleHierarchyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoleHierarchies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleHierarchyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoleHierarchies
     * const roleHierarchy = await prisma.roleHierarchy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleHierarchyUpdateManyArgs>(args: SelectSubset<T, RoleHierarchyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoleHierarchies and returns the data updated in the database.
     * @param {RoleHierarchyUpdateManyAndReturnArgs} args - Arguments to update many RoleHierarchies.
     * @example
     * // Update many RoleHierarchies
     * const roleHierarchy = await prisma.roleHierarchy.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RoleHierarchies and only return the `id`
     * const roleHierarchyWithIdOnly = await prisma.roleHierarchy.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleHierarchyUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleHierarchyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleHierarchyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RoleHierarchy.
     * @param {RoleHierarchyUpsertArgs} args - Arguments to update or create a RoleHierarchy.
     * @example
     * // Update or create a RoleHierarchy
     * const roleHierarchy = await prisma.roleHierarchy.upsert({
     *   create: {
     *     // ... data to create a RoleHierarchy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoleHierarchy we want to update
     *   }
     * })
     */
    upsert<T extends RoleHierarchyUpsertArgs>(args: SelectSubset<T, RoleHierarchyUpsertArgs<ExtArgs>>): Prisma__RoleHierarchyClient<$Result.GetResult<Prisma.$RoleHierarchyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RoleHierarchies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleHierarchyCountArgs} args - Arguments to filter RoleHierarchies to count.
     * @example
     * // Count the number of RoleHierarchies
     * const count = await prisma.roleHierarchy.count({
     *   where: {
     *     // ... the filter for the RoleHierarchies we want to count
     *   }
     * })
    **/
    count<T extends RoleHierarchyCountArgs>(
      args?: Subset<T, RoleHierarchyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleHierarchyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoleHierarchy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleHierarchyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleHierarchyAggregateArgs>(args: Subset<T, RoleHierarchyAggregateArgs>): Prisma.PrismaPromise<GetRoleHierarchyAggregateType<T>>

    /**
     * Group by RoleHierarchy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleHierarchyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleHierarchyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleHierarchyGroupByArgs['orderBy'] }
        : { orderBy?: RoleHierarchyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleHierarchyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleHierarchyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoleHierarchy model
   */
  readonly fields: RoleHierarchyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoleHierarchy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleHierarchyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends RoleHierarchy$parentArgs<ExtArgs> = {}>(args?: Subset<T, RoleHierarchy$parentArgs<ExtArgs>>): Prisma__RoleHierarchyClient<$Result.GetResult<Prisma.$RoleHierarchyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends RoleHierarchy$childrenArgs<ExtArgs> = {}>(args?: Subset<T, RoleHierarchy$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleHierarchyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    role<T extends CustomRoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomRoleDefaultArgs<ExtArgs>>): Prisma__CustomRoleClient<$Result.GetResult<Prisma.$CustomRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoleHierarchy model
   */
  interface RoleHierarchyFieldRefs {
    readonly id: FieldRef<"RoleHierarchy", 'String'>
    readonly roleId: FieldRef<"RoleHierarchy", 'String'>
    readonly parentId: FieldRef<"RoleHierarchy", 'String'>
    readonly level: FieldRef<"RoleHierarchy", 'Int'>
    readonly createdAt: FieldRef<"RoleHierarchy", 'DateTime'>
    readonly updatedAt: FieldRef<"RoleHierarchy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RoleHierarchy findUnique
   */
  export type RoleHierarchyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleHierarchy
     */
    select?: RoleHierarchySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleHierarchy
     */
    omit?: RoleHierarchyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleHierarchyInclude<ExtArgs> | null
    /**
     * Filter, which RoleHierarchy to fetch.
     */
    where: RoleHierarchyWhereUniqueInput
  }

  /**
   * RoleHierarchy findUniqueOrThrow
   */
  export type RoleHierarchyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleHierarchy
     */
    select?: RoleHierarchySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleHierarchy
     */
    omit?: RoleHierarchyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleHierarchyInclude<ExtArgs> | null
    /**
     * Filter, which RoleHierarchy to fetch.
     */
    where: RoleHierarchyWhereUniqueInput
  }

  /**
   * RoleHierarchy findFirst
   */
  export type RoleHierarchyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleHierarchy
     */
    select?: RoleHierarchySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleHierarchy
     */
    omit?: RoleHierarchyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleHierarchyInclude<ExtArgs> | null
    /**
     * Filter, which RoleHierarchy to fetch.
     */
    where?: RoleHierarchyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleHierarchies to fetch.
     */
    orderBy?: RoleHierarchyOrderByWithRelationInput | RoleHierarchyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoleHierarchies.
     */
    cursor?: RoleHierarchyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleHierarchies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleHierarchies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoleHierarchies.
     */
    distinct?: RoleHierarchyScalarFieldEnum | RoleHierarchyScalarFieldEnum[]
  }

  /**
   * RoleHierarchy findFirstOrThrow
   */
  export type RoleHierarchyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleHierarchy
     */
    select?: RoleHierarchySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleHierarchy
     */
    omit?: RoleHierarchyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleHierarchyInclude<ExtArgs> | null
    /**
     * Filter, which RoleHierarchy to fetch.
     */
    where?: RoleHierarchyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleHierarchies to fetch.
     */
    orderBy?: RoleHierarchyOrderByWithRelationInput | RoleHierarchyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoleHierarchies.
     */
    cursor?: RoleHierarchyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleHierarchies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleHierarchies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoleHierarchies.
     */
    distinct?: RoleHierarchyScalarFieldEnum | RoleHierarchyScalarFieldEnum[]
  }

  /**
   * RoleHierarchy findMany
   */
  export type RoleHierarchyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleHierarchy
     */
    select?: RoleHierarchySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleHierarchy
     */
    omit?: RoleHierarchyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleHierarchyInclude<ExtArgs> | null
    /**
     * Filter, which RoleHierarchies to fetch.
     */
    where?: RoleHierarchyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleHierarchies to fetch.
     */
    orderBy?: RoleHierarchyOrderByWithRelationInput | RoleHierarchyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoleHierarchies.
     */
    cursor?: RoleHierarchyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleHierarchies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleHierarchies.
     */
    skip?: number
    distinct?: RoleHierarchyScalarFieldEnum | RoleHierarchyScalarFieldEnum[]
  }

  /**
   * RoleHierarchy create
   */
  export type RoleHierarchyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleHierarchy
     */
    select?: RoleHierarchySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleHierarchy
     */
    omit?: RoleHierarchyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleHierarchyInclude<ExtArgs> | null
    /**
     * The data needed to create a RoleHierarchy.
     */
    data: XOR<RoleHierarchyCreateInput, RoleHierarchyUncheckedCreateInput>
  }

  /**
   * RoleHierarchy createMany
   */
  export type RoleHierarchyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoleHierarchies.
     */
    data: RoleHierarchyCreateManyInput | RoleHierarchyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoleHierarchy createManyAndReturn
   */
  export type RoleHierarchyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleHierarchy
     */
    select?: RoleHierarchySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoleHierarchy
     */
    omit?: RoleHierarchyOmit<ExtArgs> | null
    /**
     * The data used to create many RoleHierarchies.
     */
    data: RoleHierarchyCreateManyInput | RoleHierarchyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleHierarchyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoleHierarchy update
   */
  export type RoleHierarchyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleHierarchy
     */
    select?: RoleHierarchySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleHierarchy
     */
    omit?: RoleHierarchyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleHierarchyInclude<ExtArgs> | null
    /**
     * The data needed to update a RoleHierarchy.
     */
    data: XOR<RoleHierarchyUpdateInput, RoleHierarchyUncheckedUpdateInput>
    /**
     * Choose, which RoleHierarchy to update.
     */
    where: RoleHierarchyWhereUniqueInput
  }

  /**
   * RoleHierarchy updateMany
   */
  export type RoleHierarchyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoleHierarchies.
     */
    data: XOR<RoleHierarchyUpdateManyMutationInput, RoleHierarchyUncheckedUpdateManyInput>
    /**
     * Filter which RoleHierarchies to update
     */
    where?: RoleHierarchyWhereInput
    /**
     * Limit how many RoleHierarchies to update.
     */
    limit?: number
  }

  /**
   * RoleHierarchy updateManyAndReturn
   */
  export type RoleHierarchyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleHierarchy
     */
    select?: RoleHierarchySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoleHierarchy
     */
    omit?: RoleHierarchyOmit<ExtArgs> | null
    /**
     * The data used to update RoleHierarchies.
     */
    data: XOR<RoleHierarchyUpdateManyMutationInput, RoleHierarchyUncheckedUpdateManyInput>
    /**
     * Filter which RoleHierarchies to update
     */
    where?: RoleHierarchyWhereInput
    /**
     * Limit how many RoleHierarchies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleHierarchyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoleHierarchy upsert
   */
  export type RoleHierarchyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleHierarchy
     */
    select?: RoleHierarchySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleHierarchy
     */
    omit?: RoleHierarchyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleHierarchyInclude<ExtArgs> | null
    /**
     * The filter to search for the RoleHierarchy to update in case it exists.
     */
    where: RoleHierarchyWhereUniqueInput
    /**
     * In case the RoleHierarchy found by the `where` argument doesn't exist, create a new RoleHierarchy with this data.
     */
    create: XOR<RoleHierarchyCreateInput, RoleHierarchyUncheckedCreateInput>
    /**
     * In case the RoleHierarchy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleHierarchyUpdateInput, RoleHierarchyUncheckedUpdateInput>
  }

  /**
   * RoleHierarchy delete
   */
  export type RoleHierarchyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleHierarchy
     */
    select?: RoleHierarchySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleHierarchy
     */
    omit?: RoleHierarchyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleHierarchyInclude<ExtArgs> | null
    /**
     * Filter which RoleHierarchy to delete.
     */
    where: RoleHierarchyWhereUniqueInput
  }

  /**
   * RoleHierarchy deleteMany
   */
  export type RoleHierarchyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoleHierarchies to delete
     */
    where?: RoleHierarchyWhereInput
    /**
     * Limit how many RoleHierarchies to delete.
     */
    limit?: number
  }

  /**
   * RoleHierarchy.parent
   */
  export type RoleHierarchy$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleHierarchy
     */
    select?: RoleHierarchySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleHierarchy
     */
    omit?: RoleHierarchyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleHierarchyInclude<ExtArgs> | null
    where?: RoleHierarchyWhereInput
  }

  /**
   * RoleHierarchy.children
   */
  export type RoleHierarchy$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleHierarchy
     */
    select?: RoleHierarchySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleHierarchy
     */
    omit?: RoleHierarchyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleHierarchyInclude<ExtArgs> | null
    where?: RoleHierarchyWhereInput
    orderBy?: RoleHierarchyOrderByWithRelationInput | RoleHierarchyOrderByWithRelationInput[]
    cursor?: RoleHierarchyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleHierarchyScalarFieldEnum | RoleHierarchyScalarFieldEnum[]
  }

  /**
   * RoleHierarchy without action
   */
  export type RoleHierarchyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleHierarchy
     */
    select?: RoleHierarchySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleHierarchy
     */
    omit?: RoleHierarchyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleHierarchyInclude<ExtArgs> | null
  }


  /**
   * Model PermissionAudit
   */

  export type AggregatePermissionAudit = {
    _count: PermissionAuditCountAggregateOutputType | null
    _avg: PermissionAuditAvgAggregateOutputType | null
    _sum: PermissionAuditSumAggregateOutputType | null
    _min: PermissionAuditMinAggregateOutputType | null
    _max: PermissionAuditMaxAggregateOutputType | null
  }

  export type PermissionAuditAvgAggregateOutputType = {
    userId: number | null
  }

  export type PermissionAuditSumAggregateOutputType = {
    userId: number | null
  }

  export type PermissionAuditMinAggregateOutputType = {
    id: string | null
    userId: number | null
    action: string | null
    permissionId: string | null
    oldValue: string | null
    newValue: string | null
    reason: string | null
    performedBy: string | null
    createdAt: Date | null
  }

  export type PermissionAuditMaxAggregateOutputType = {
    id: string | null
    userId: number | null
    action: string | null
    permissionId: string | null
    oldValue: string | null
    newValue: string | null
    reason: string | null
    performedBy: string | null
    createdAt: Date | null
  }

  export type PermissionAuditCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    permissionId: number
    oldValue: number
    newValue: number
    reason: number
    performedBy: number
    createdAt: number
    _all: number
  }


  export type PermissionAuditAvgAggregateInputType = {
    userId?: true
  }

  export type PermissionAuditSumAggregateInputType = {
    userId?: true
  }

  export type PermissionAuditMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    permissionId?: true
    oldValue?: true
    newValue?: true
    reason?: true
    performedBy?: true
    createdAt?: true
  }

  export type PermissionAuditMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    permissionId?: true
    oldValue?: true
    newValue?: true
    reason?: true
    performedBy?: true
    createdAt?: true
  }

  export type PermissionAuditCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    permissionId?: true
    oldValue?: true
    newValue?: true
    reason?: true
    performedBy?: true
    createdAt?: true
    _all?: true
  }

  export type PermissionAuditAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PermissionAudit to aggregate.
     */
    where?: PermissionAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PermissionAudits to fetch.
     */
    orderBy?: PermissionAuditOrderByWithRelationInput | PermissionAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PermissionAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PermissionAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PermissionAudits
    **/
    _count?: true | PermissionAuditCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PermissionAuditAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PermissionAuditSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionAuditMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionAuditMaxAggregateInputType
  }

  export type GetPermissionAuditAggregateType<T extends PermissionAuditAggregateArgs> = {
        [P in keyof T & keyof AggregatePermissionAudit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermissionAudit[P]>
      : GetScalarType<T[P], AggregatePermissionAudit[P]>
  }




  export type PermissionAuditGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionAuditWhereInput
    orderBy?: PermissionAuditOrderByWithAggregationInput | PermissionAuditOrderByWithAggregationInput[]
    by: PermissionAuditScalarFieldEnum[] | PermissionAuditScalarFieldEnum
    having?: PermissionAuditScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionAuditCountAggregateInputType | true
    _avg?: PermissionAuditAvgAggregateInputType
    _sum?: PermissionAuditSumAggregateInputType
    _min?: PermissionAuditMinAggregateInputType
    _max?: PermissionAuditMaxAggregateInputType
  }

  export type PermissionAuditGroupByOutputType = {
    id: string
    userId: number
    action: string
    permissionId: string
    oldValue: string | null
    newValue: string
    reason: string | null
    performedBy: string | null
    createdAt: Date
    _count: PermissionAuditCountAggregateOutputType | null
    _avg: PermissionAuditAvgAggregateOutputType | null
    _sum: PermissionAuditSumAggregateOutputType | null
    _min: PermissionAuditMinAggregateOutputType | null
    _max: PermissionAuditMaxAggregateOutputType | null
  }

  type GetPermissionAuditGroupByPayload<T extends PermissionAuditGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionAuditGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionAuditGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionAuditGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionAuditGroupByOutputType[P]>
        }
      >
    >


  export type PermissionAuditSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    permissionId?: boolean
    oldValue?: boolean
    newValue?: boolean
    reason?: boolean
    performedBy?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permissionAudit"]>

  export type PermissionAuditSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    permissionId?: boolean
    oldValue?: boolean
    newValue?: boolean
    reason?: boolean
    performedBy?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permissionAudit"]>

  export type PermissionAuditSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    permissionId?: boolean
    oldValue?: boolean
    newValue?: boolean
    reason?: boolean
    performedBy?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permissionAudit"]>

  export type PermissionAuditSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    permissionId?: boolean
    oldValue?: boolean
    newValue?: boolean
    reason?: boolean
    performedBy?: boolean
    createdAt?: boolean
  }

  export type PermissionAuditOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "permissionId" | "oldValue" | "newValue" | "reason" | "performedBy" | "createdAt", ExtArgs["result"]["permissionAudit"]>
  export type PermissionAuditInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PermissionAuditIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PermissionAuditIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PermissionAuditPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PermissionAudit"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: number
      action: string
      permissionId: string
      oldValue: string | null
      newValue: string
      reason: string | null
      performedBy: string | null
      createdAt: Date
    }, ExtArgs["result"]["permissionAudit"]>
    composites: {}
  }

  type PermissionAuditGetPayload<S extends boolean | null | undefined | PermissionAuditDefaultArgs> = $Result.GetResult<Prisma.$PermissionAuditPayload, S>

  type PermissionAuditCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PermissionAuditFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionAuditCountAggregateInputType | true
    }

  export interface PermissionAuditDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PermissionAudit'], meta: { name: 'PermissionAudit' } }
    /**
     * Find zero or one PermissionAudit that matches the filter.
     * @param {PermissionAuditFindUniqueArgs} args - Arguments to find a PermissionAudit
     * @example
     * // Get one PermissionAudit
     * const permissionAudit = await prisma.permissionAudit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionAuditFindUniqueArgs>(args: SelectSubset<T, PermissionAuditFindUniqueArgs<ExtArgs>>): Prisma__PermissionAuditClient<$Result.GetResult<Prisma.$PermissionAuditPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PermissionAudit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PermissionAuditFindUniqueOrThrowArgs} args - Arguments to find a PermissionAudit
     * @example
     * // Get one PermissionAudit
     * const permissionAudit = await prisma.permissionAudit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionAuditFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionAuditFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionAuditClient<$Result.GetResult<Prisma.$PermissionAuditPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PermissionAudit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAuditFindFirstArgs} args - Arguments to find a PermissionAudit
     * @example
     * // Get one PermissionAudit
     * const permissionAudit = await prisma.permissionAudit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionAuditFindFirstArgs>(args?: SelectSubset<T, PermissionAuditFindFirstArgs<ExtArgs>>): Prisma__PermissionAuditClient<$Result.GetResult<Prisma.$PermissionAuditPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PermissionAudit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAuditFindFirstOrThrowArgs} args - Arguments to find a PermissionAudit
     * @example
     * // Get one PermissionAudit
     * const permissionAudit = await prisma.permissionAudit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionAuditFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionAuditFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionAuditClient<$Result.GetResult<Prisma.$PermissionAuditPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PermissionAudits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAuditFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PermissionAudits
     * const permissionAudits = await prisma.permissionAudit.findMany()
     * 
     * // Get first 10 PermissionAudits
     * const permissionAudits = await prisma.permissionAudit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionAuditWithIdOnly = await prisma.permissionAudit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionAuditFindManyArgs>(args?: SelectSubset<T, PermissionAuditFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionAuditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PermissionAudit.
     * @param {PermissionAuditCreateArgs} args - Arguments to create a PermissionAudit.
     * @example
     * // Create one PermissionAudit
     * const PermissionAudit = await prisma.permissionAudit.create({
     *   data: {
     *     // ... data to create a PermissionAudit
     *   }
     * })
     * 
     */
    create<T extends PermissionAuditCreateArgs>(args: SelectSubset<T, PermissionAuditCreateArgs<ExtArgs>>): Prisma__PermissionAuditClient<$Result.GetResult<Prisma.$PermissionAuditPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PermissionAudits.
     * @param {PermissionAuditCreateManyArgs} args - Arguments to create many PermissionAudits.
     * @example
     * // Create many PermissionAudits
     * const permissionAudit = await prisma.permissionAudit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionAuditCreateManyArgs>(args?: SelectSubset<T, PermissionAuditCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PermissionAudits and returns the data saved in the database.
     * @param {PermissionAuditCreateManyAndReturnArgs} args - Arguments to create many PermissionAudits.
     * @example
     * // Create many PermissionAudits
     * const permissionAudit = await prisma.permissionAudit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PermissionAudits and only return the `id`
     * const permissionAuditWithIdOnly = await prisma.permissionAudit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PermissionAuditCreateManyAndReturnArgs>(args?: SelectSubset<T, PermissionAuditCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionAuditPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PermissionAudit.
     * @param {PermissionAuditDeleteArgs} args - Arguments to delete one PermissionAudit.
     * @example
     * // Delete one PermissionAudit
     * const PermissionAudit = await prisma.permissionAudit.delete({
     *   where: {
     *     // ... filter to delete one PermissionAudit
     *   }
     * })
     * 
     */
    delete<T extends PermissionAuditDeleteArgs>(args: SelectSubset<T, PermissionAuditDeleteArgs<ExtArgs>>): Prisma__PermissionAuditClient<$Result.GetResult<Prisma.$PermissionAuditPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PermissionAudit.
     * @param {PermissionAuditUpdateArgs} args - Arguments to update one PermissionAudit.
     * @example
     * // Update one PermissionAudit
     * const permissionAudit = await prisma.permissionAudit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionAuditUpdateArgs>(args: SelectSubset<T, PermissionAuditUpdateArgs<ExtArgs>>): Prisma__PermissionAuditClient<$Result.GetResult<Prisma.$PermissionAuditPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PermissionAudits.
     * @param {PermissionAuditDeleteManyArgs} args - Arguments to filter PermissionAudits to delete.
     * @example
     * // Delete a few PermissionAudits
     * const { count } = await prisma.permissionAudit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionAuditDeleteManyArgs>(args?: SelectSubset<T, PermissionAuditDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PermissionAudits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAuditUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PermissionAudits
     * const permissionAudit = await prisma.permissionAudit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionAuditUpdateManyArgs>(args: SelectSubset<T, PermissionAuditUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PermissionAudits and returns the data updated in the database.
     * @param {PermissionAuditUpdateManyAndReturnArgs} args - Arguments to update many PermissionAudits.
     * @example
     * // Update many PermissionAudits
     * const permissionAudit = await prisma.permissionAudit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PermissionAudits and only return the `id`
     * const permissionAuditWithIdOnly = await prisma.permissionAudit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PermissionAuditUpdateManyAndReturnArgs>(args: SelectSubset<T, PermissionAuditUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionAuditPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PermissionAudit.
     * @param {PermissionAuditUpsertArgs} args - Arguments to update or create a PermissionAudit.
     * @example
     * // Update or create a PermissionAudit
     * const permissionAudit = await prisma.permissionAudit.upsert({
     *   create: {
     *     // ... data to create a PermissionAudit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PermissionAudit we want to update
     *   }
     * })
     */
    upsert<T extends PermissionAuditUpsertArgs>(args: SelectSubset<T, PermissionAuditUpsertArgs<ExtArgs>>): Prisma__PermissionAuditClient<$Result.GetResult<Prisma.$PermissionAuditPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PermissionAudits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAuditCountArgs} args - Arguments to filter PermissionAudits to count.
     * @example
     * // Count the number of PermissionAudits
     * const count = await prisma.permissionAudit.count({
     *   where: {
     *     // ... the filter for the PermissionAudits we want to count
     *   }
     * })
    **/
    count<T extends PermissionAuditCountArgs>(
      args?: Subset<T, PermissionAuditCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionAuditCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PermissionAudit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAuditAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAuditAggregateArgs>(args: Subset<T, PermissionAuditAggregateArgs>): Prisma.PrismaPromise<GetPermissionAuditAggregateType<T>>

    /**
     * Group by PermissionAudit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAuditGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionAuditGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionAuditGroupByArgs['orderBy'] }
        : { orderBy?: PermissionAuditGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionAuditGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionAuditGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PermissionAudit model
   */
  readonly fields: PermissionAuditFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PermissionAudit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionAuditClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PermissionAudit model
   */
  interface PermissionAuditFieldRefs {
    readonly id: FieldRef<"PermissionAudit", 'String'>
    readonly userId: FieldRef<"PermissionAudit", 'Int'>
    readonly action: FieldRef<"PermissionAudit", 'String'>
    readonly permissionId: FieldRef<"PermissionAudit", 'String'>
    readonly oldValue: FieldRef<"PermissionAudit", 'String'>
    readonly newValue: FieldRef<"PermissionAudit", 'String'>
    readonly reason: FieldRef<"PermissionAudit", 'String'>
    readonly performedBy: FieldRef<"PermissionAudit", 'String'>
    readonly createdAt: FieldRef<"PermissionAudit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PermissionAudit findUnique
   */
  export type PermissionAuditFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionAudit
     */
    select?: PermissionAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermissionAudit
     */
    omit?: PermissionAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionAuditInclude<ExtArgs> | null
    /**
     * Filter, which PermissionAudit to fetch.
     */
    where: PermissionAuditWhereUniqueInput
  }

  /**
   * PermissionAudit findUniqueOrThrow
   */
  export type PermissionAuditFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionAudit
     */
    select?: PermissionAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermissionAudit
     */
    omit?: PermissionAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionAuditInclude<ExtArgs> | null
    /**
     * Filter, which PermissionAudit to fetch.
     */
    where: PermissionAuditWhereUniqueInput
  }

  /**
   * PermissionAudit findFirst
   */
  export type PermissionAuditFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionAudit
     */
    select?: PermissionAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermissionAudit
     */
    omit?: PermissionAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionAuditInclude<ExtArgs> | null
    /**
     * Filter, which PermissionAudit to fetch.
     */
    where?: PermissionAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PermissionAudits to fetch.
     */
    orderBy?: PermissionAuditOrderByWithRelationInput | PermissionAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PermissionAudits.
     */
    cursor?: PermissionAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PermissionAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PermissionAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PermissionAudits.
     */
    distinct?: PermissionAuditScalarFieldEnum | PermissionAuditScalarFieldEnum[]
  }

  /**
   * PermissionAudit findFirstOrThrow
   */
  export type PermissionAuditFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionAudit
     */
    select?: PermissionAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermissionAudit
     */
    omit?: PermissionAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionAuditInclude<ExtArgs> | null
    /**
     * Filter, which PermissionAudit to fetch.
     */
    where?: PermissionAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PermissionAudits to fetch.
     */
    orderBy?: PermissionAuditOrderByWithRelationInput | PermissionAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PermissionAudits.
     */
    cursor?: PermissionAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PermissionAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PermissionAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PermissionAudits.
     */
    distinct?: PermissionAuditScalarFieldEnum | PermissionAuditScalarFieldEnum[]
  }

  /**
   * PermissionAudit findMany
   */
  export type PermissionAuditFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionAudit
     */
    select?: PermissionAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermissionAudit
     */
    omit?: PermissionAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionAuditInclude<ExtArgs> | null
    /**
     * Filter, which PermissionAudits to fetch.
     */
    where?: PermissionAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PermissionAudits to fetch.
     */
    orderBy?: PermissionAuditOrderByWithRelationInput | PermissionAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PermissionAudits.
     */
    cursor?: PermissionAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PermissionAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PermissionAudits.
     */
    skip?: number
    distinct?: PermissionAuditScalarFieldEnum | PermissionAuditScalarFieldEnum[]
  }

  /**
   * PermissionAudit create
   */
  export type PermissionAuditCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionAudit
     */
    select?: PermissionAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermissionAudit
     */
    omit?: PermissionAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionAuditInclude<ExtArgs> | null
    /**
     * The data needed to create a PermissionAudit.
     */
    data: XOR<PermissionAuditCreateInput, PermissionAuditUncheckedCreateInput>
  }

  /**
   * PermissionAudit createMany
   */
  export type PermissionAuditCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PermissionAudits.
     */
    data: PermissionAuditCreateManyInput | PermissionAuditCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PermissionAudit createManyAndReturn
   */
  export type PermissionAuditCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionAudit
     */
    select?: PermissionAuditSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PermissionAudit
     */
    omit?: PermissionAuditOmit<ExtArgs> | null
    /**
     * The data used to create many PermissionAudits.
     */
    data: PermissionAuditCreateManyInput | PermissionAuditCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionAuditIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PermissionAudit update
   */
  export type PermissionAuditUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionAudit
     */
    select?: PermissionAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermissionAudit
     */
    omit?: PermissionAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionAuditInclude<ExtArgs> | null
    /**
     * The data needed to update a PermissionAudit.
     */
    data: XOR<PermissionAuditUpdateInput, PermissionAuditUncheckedUpdateInput>
    /**
     * Choose, which PermissionAudit to update.
     */
    where: PermissionAuditWhereUniqueInput
  }

  /**
   * PermissionAudit updateMany
   */
  export type PermissionAuditUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PermissionAudits.
     */
    data: XOR<PermissionAuditUpdateManyMutationInput, PermissionAuditUncheckedUpdateManyInput>
    /**
     * Filter which PermissionAudits to update
     */
    where?: PermissionAuditWhereInput
    /**
     * Limit how many PermissionAudits to update.
     */
    limit?: number
  }

  /**
   * PermissionAudit updateManyAndReturn
   */
  export type PermissionAuditUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionAudit
     */
    select?: PermissionAuditSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PermissionAudit
     */
    omit?: PermissionAuditOmit<ExtArgs> | null
    /**
     * The data used to update PermissionAudits.
     */
    data: XOR<PermissionAuditUpdateManyMutationInput, PermissionAuditUncheckedUpdateManyInput>
    /**
     * Filter which PermissionAudits to update
     */
    where?: PermissionAuditWhereInput
    /**
     * Limit how many PermissionAudits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionAuditIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PermissionAudit upsert
   */
  export type PermissionAuditUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionAudit
     */
    select?: PermissionAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermissionAudit
     */
    omit?: PermissionAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionAuditInclude<ExtArgs> | null
    /**
     * The filter to search for the PermissionAudit to update in case it exists.
     */
    where: PermissionAuditWhereUniqueInput
    /**
     * In case the PermissionAudit found by the `where` argument doesn't exist, create a new PermissionAudit with this data.
     */
    create: XOR<PermissionAuditCreateInput, PermissionAuditUncheckedCreateInput>
    /**
     * In case the PermissionAudit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionAuditUpdateInput, PermissionAuditUncheckedUpdateInput>
  }

  /**
   * PermissionAudit delete
   */
  export type PermissionAuditDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionAudit
     */
    select?: PermissionAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermissionAudit
     */
    omit?: PermissionAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionAuditInclude<ExtArgs> | null
    /**
     * Filter which PermissionAudit to delete.
     */
    where: PermissionAuditWhereUniqueInput
  }

  /**
   * PermissionAudit deleteMany
   */
  export type PermissionAuditDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PermissionAudits to delete
     */
    where?: PermissionAuditWhereInput
    /**
     * Limit how many PermissionAudits to delete.
     */
    limit?: number
  }

  /**
   * PermissionAudit without action
   */
  export type PermissionAuditDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionAudit
     */
    select?: PermissionAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermissionAudit
     */
    omit?: PermissionAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionAuditInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    username: 'username',
    email: 'email',
    phone_number: 'phone_number',
    password: 'password',
    role: 'role',
    profile_picture: 'profile_picture',
    tokenVersion: 'tokenVersion',
    created_at: 'created_at',
    updated_at: 'updated_at',
    resetToken: 'resetToken',
    resetTokenExp: 'resetTokenExp',
    bio: 'bio',
    dateOfBirth: 'dateOfBirth',
    department: 'department',
    email_verified: 'email_verified',
    gender: 'gender',
    isActive: 'isActive',
    lastLogin: 'lastLogin',
    lockedUntil: 'lockedUntil',
    loginAttempts: 'loginAttempts',
    position: 'position'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    deviceType: 'deviceType',
    deviceInfo: 'deviceInfo',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    isActive: 'isActive',
    lastActivity: 'lastActivity',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserSessionScalarFieldEnum = (typeof UserSessionScalarFieldEnum)[keyof typeof UserSessionScalarFieldEnum]


  export const UserAccessLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    success: 'success',
    details: 'details',
    createdAt: 'createdAt'
  };

  export type UserAccessLogScalarFieldEnum = (typeof UserAccessLogScalarFieldEnum)[keyof typeof UserAccessLogScalarFieldEnum]


  export const UserIPRestrictionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    ipAddress: 'ipAddress',
    type: 'type',
    reason: 'reason',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserIPRestrictionScalarFieldEnum = (typeof UserIPRestrictionScalarFieldEnum)[keyof typeof UserIPRestrictionScalarFieldEnum]


  export const UserAddressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    street: 'street',
    city: 'city',
    state: 'state',
    postalCode: 'postalCode',
    country: 'country',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserAddressScalarFieldEnum = (typeof UserAddressScalarFieldEnum)[keyof typeof UserAddressScalarFieldEnum]


  export const UserEmergencyContactScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    relationship: 'relationship',
    phone: 'phone',
    email: 'email',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserEmergencyContactScalarFieldEnum = (typeof UserEmergencyContactScalarFieldEnum)[keyof typeof UserEmergencyContactScalarFieldEnum]


  export const UserSocialMediaScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    linkedin: 'linkedin',
    twitter: 'twitter',
    facebook: 'facebook',
    instagram: 'instagram',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserSocialMediaScalarFieldEnum = (typeof UserSocialMediaScalarFieldEnum)[keyof typeof UserSocialMediaScalarFieldEnum]


  export const UserPreferencesScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    theme: 'theme',
    language: 'language',
    timezone: 'timezone',
    dateFormat: 'dateFormat',
    timeFormat: 'timeFormat',
    currency: 'currency',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserPreferencesScalarFieldEnum = (typeof UserPreferencesScalarFieldEnum)[keyof typeof UserPreferencesScalarFieldEnum]


  export const UserNotificationSettingsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    email_loginAlerts: 'email_loginAlerts',
    email_securityUpdates: 'email_securityUpdates',
    email_systemAnnouncements: 'email_systemAnnouncements',
    email_marketingEmails: 'email_marketingEmails',
    push_loginAlerts: 'push_loginAlerts',
    push_securityUpdates: 'push_securityUpdates',
    push_systemAnnouncements: 'push_systemAnnouncements',
    push_marketingNotifications: 'push_marketingNotifications',
    sms_loginAlerts: 'sms_loginAlerts',
    sms_securityUpdates: 'sms_securityUpdates',
    sms_emergencyAlerts: 'sms_emergencyAlerts',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserNotificationSettingsScalarFieldEnum = (typeof UserNotificationSettingsScalarFieldEnum)[keyof typeof UserNotificationSettingsScalarFieldEnum]


  export const UserPrivacySettingsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    profileVisibility: 'profileVisibility',
    showEmail: 'showEmail',
    showPhone: 'showPhone',
    showLocation: 'showLocation',
    allowContact: 'allowContact',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserPrivacySettingsScalarFieldEnum = (typeof UserPrivacySettingsScalarFieldEnum)[keyof typeof UserPrivacySettingsScalarFieldEnum]


  export const MemberScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone_number: 'phone_number',
    password: 'password',
    age: 'age',
    profile_picture: 'profile_picture',
    membershiptype: 'membershiptype',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    email_verification_expires: 'email_verification_expires',
    email_verification_token: 'email_verification_token',
    email_verified: 'email_verified',
    terms_accepted: 'terms_accepted',
    terms_accepted_at: 'terms_accepted_at'
  };

  export type MemberScalarFieldEnum = (typeof MemberScalarFieldEnum)[keyof typeof MemberScalarFieldEnum]


  export const MemberCheckInScalarFieldEnum: {
    id: 'id',
    memberId: 'memberId',
    checkInTime: 'checkInTime',
    checkOutTime: 'checkOutTime',
    location: 'location',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MemberCheckInScalarFieldEnum = (typeof MemberCheckInScalarFieldEnum)[keyof typeof MemberCheckInScalarFieldEnum]


  export const MemberAttendanceScalarFieldEnum: {
    id: 'id',
    memberId: 'memberId',
    date: 'date',
    timeIn: 'timeIn',
    timeOut: 'timeOut',
    duration: 'duration',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MemberAttendanceScalarFieldEnum = (typeof MemberAttendanceScalarFieldEnum)[keyof typeof MemberAttendanceScalarFieldEnum]


  export const MemberFitnessGoalScalarFieldEnum: {
    id: 'id',
    memberId: 'memberId',
    goalType: 'goalType',
    targetValue: 'targetValue',
    currentValue: 'currentValue',
    unit: 'unit',
    targetDate: 'targetDate',
    isCompleted: 'isCompleted',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MemberFitnessGoalScalarFieldEnum = (typeof MemberFitnessGoalScalarFieldEnum)[keyof typeof MemberFitnessGoalScalarFieldEnum]


  export const AddressScalarFieldEnum: {
    id: 'id',
    memberId: 'memberId',
    street: 'street',
    city: 'city',
    state: 'state',
    zipCode: 'zipCode',
    country: 'country',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const EmergencyContactScalarFieldEnum: {
    id: 'id',
    memberId: 'memberId',
    name: 'name',
    relationship: 'relationship',
    phone: 'phone',
    email: 'email',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmergencyContactScalarFieldEnum = (typeof EmergencyContactScalarFieldEnum)[keyof typeof EmergencyContactScalarFieldEnum]


  export const MedicalInfoScalarFieldEnum: {
    id: 'id',
    memberId: 'memberId',
    fitness_goals: 'fitness_goals',
    health_conditions: 'health_conditions',
    allergies: 'allergies',
    medications: 'medications',
    emergency_notes: 'emergency_notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MedicalInfoScalarFieldEnum = (typeof MedicalInfoScalarFieldEnum)[keyof typeof MedicalInfoScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    memberId: 'memberId',
    method: 'method',
    createdAt: 'createdAt',
    status: 'status',
    description: 'description',
    reference: 'reference',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    memberId: 'memberId',
    amount: 'amount',
    details: 'details',
    createdAt: 'createdAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const MembershipPlanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    price: 'price',
    duration: 'duration',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MembershipPlanScalarFieldEnum = (typeof MembershipPlanScalarFieldEnum)[keyof typeof MembershipPlanScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    memberId: 'memberId',
    planId: 'planId',
    startDate: 'startDate',
    endDate: 'endDate'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const EquipmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    quantity: 'quantity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    available: 'available',
    brand: 'brand',
    category: 'category',
    cost: 'cost',
    description: 'description',
    imageUrl: 'imageUrl',
    inUse: 'inUse',
    lastMaintenance: 'lastMaintenance',
    location: 'location',
    maintenance: 'maintenance',
    model: 'model',
    nextMaintenance: 'nextMaintenance',
    purchaseDate: 'purchaseDate',
    serialNumber: 'serialNumber',
    status: 'status',
    warrantyExpiry: 'warrantyExpiry'
  };

  export type EquipmentScalarFieldEnum = (typeof EquipmentScalarFieldEnum)[keyof typeof EquipmentScalarFieldEnum]


  export const MaintenanceLogScalarFieldEnum: {
    id: 'id',
    equipmentId: 'equipmentId',
    type: 'type',
    description: 'description',
    cost: 'cost',
    performedBy: 'performedBy',
    performedAt: 'performedAt',
    nextDue: 'nextDue'
  };

  export type MaintenanceLogScalarFieldEnum = (typeof MaintenanceLogScalarFieldEnum)[keyof typeof MaintenanceLogScalarFieldEnum]


  export const SystemIntegrationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    status: 'status',
    healthScore: 'healthScore',
    endpoint: 'endpoint',
    apiKey: 'apiKey',
    config: 'config',
    lastSync: 'lastSync',
    errorCount: 'errorCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SystemIntegrationScalarFieldEnum = (typeof SystemIntegrationScalarFieldEnum)[keyof typeof SystemIntegrationScalarFieldEnum]


  export const AutomationWorkflowScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    category: 'category',
    status: 'status',
    priority: 'priority',
    trigger: 'trigger',
    schedule: 'schedule',
    config: 'config',
    successCount: 'successCount',
    failureCount: 'failureCount',
    lastRun: 'lastRun',
    nextRun: 'nextRun',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AutomationWorkflowScalarFieldEnum = (typeof AutomationWorkflowScalarFieldEnum)[keyof typeof AutomationWorkflowScalarFieldEnum]


  export const DataSyncJobScalarFieldEnum: {
    id: 'id',
    name: 'name',
    source: 'source',
    destination: 'destination',
    status: 'status',
    processedRecords: 'processedRecords',
    failedRecords: 'failedRecords',
    totalRecords: 'totalRecords',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    errorMessage: 'errorMessage',
    config: 'config',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DataSyncJobScalarFieldEnum = (typeof DataSyncJobScalarFieldEnum)[keyof typeof DataSyncJobScalarFieldEnum]


  export const WebhookEndpointScalarFieldEnum: {
    id: 'id',
    name: 'name',
    url: 'url',
    method: 'method',
    headers: 'headers',
    events: 'events',
    isActive: 'isActive',
    secret: 'secret',
    lastTriggered: 'lastTriggered',
    successCount: 'successCount',
    failureCount: 'failureCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WebhookEndpointScalarFieldEnum = (typeof WebhookEndpointScalarFieldEnum)[keyof typeof WebhookEndpointScalarFieldEnum]


  export const APIManagementScalarFieldEnum: {
    id: 'id',
    name: 'name',
    apiKey: 'apiKey',
    permissions: 'permissions',
    rateLimit: 'rateLimit',
    isActive: 'isActive',
    lastUsed: 'lastUsed',
    usageCount: 'usageCount',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type APIManagementScalarFieldEnum = (typeof APIManagementScalarFieldEnum)[keyof typeof APIManagementScalarFieldEnum]


  export const ThreatDetectionScalarFieldEnum: {
    id: 'id',
    threatType: 'threatType',
    severity: 'severity',
    status: 'status',
    description: 'description',
    source: 'source',
    evidence: 'evidence',
    assignedTo: 'assignedTo',
    resolvedAt: 'resolvedAt',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ThreatDetectionScalarFieldEnum = (typeof ThreatDetectionScalarFieldEnum)[keyof typeof ThreatDetectionScalarFieldEnum]


  export const AnomalyDetectionScalarFieldEnum: {
    id: 'id',
    anomalyType: 'anomalyType',
    confidence: 'confidence',
    status: 'status',
    description: 'description',
    data: 'data',
    severity: 'severity',
    resolvedAt: 'resolvedAt',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AnomalyDetectionScalarFieldEnum = (typeof AnomalyDetectionScalarFieldEnum)[keyof typeof AnomalyDetectionScalarFieldEnum]


  export const ComplianceReportScalarFieldEnum: {
    id: 'id',
    reportType: 'reportType',
    status: 'status',
    period: 'period',
    findings: 'findings',
    recommendations: 'recommendations',
    submittedBy: 'submittedBy',
    submittedAt: 'submittedAt',
    approvedBy: 'approvedBy',
    approvedAt: 'approvedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ComplianceReportScalarFieldEnum = (typeof ComplianceReportScalarFieldEnum)[keyof typeof ComplianceReportScalarFieldEnum]


  export const SecurityWorkflowScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    status: 'status',
    priority: 'priority',
    assignedTo: 'assignedTo',
    dueDate: 'dueDate',
    steps: 'steps',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SecurityWorkflowScalarFieldEnum = (typeof SecurityWorkflowScalarFieldEnum)[keyof typeof SecurityWorkflowScalarFieldEnum]


  export const SecurityIntegrationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    status: 'status',
    endpoint: 'endpoint',
    apiKey: 'apiKey',
    config: 'config',
    lastSync: 'lastSync',
    healthScore: 'healthScore',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SecurityIntegrationScalarFieldEnum = (typeof SecurityIntegrationScalarFieldEnum)[keyof typeof SecurityIntegrationScalarFieldEnum]


  export const AdministrativeProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    adminLevel: 'adminLevel',
    departments: 'departments',
    responsibilities: 'responsibilities',
    criticalPermissions: 'criticalPermissions',
    emergencyContact: 'emergencyContact',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdministrativeProfileScalarFieldEnum = (typeof AdministrativeProfileScalarFieldEnum)[keyof typeof AdministrativeProfileScalarFieldEnum]


  export const CustomRoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    permissions: 'permissions',
    parentRole: 'parentRole',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomRoleScalarFieldEnum = (typeof CustomRoleScalarFieldEnum)[keyof typeof CustomRoleScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    category: 'category',
    action: 'action',
    resource: 'resource',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const RoleHierarchyScalarFieldEnum: {
    id: 'id',
    roleId: 'roleId',
    parentId: 'parentId',
    level: 'level',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleHierarchyScalarFieldEnum = (typeof RoleHierarchyScalarFieldEnum)[keyof typeof RoleHierarchyScalarFieldEnum]


  export const PermissionAuditScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    permissionId: 'permissionId',
    oldValue: 'oldValue',
    newValue: 'newValue',
    reason: 'reason',
    performedBy: 'performedBy',
    createdAt: 'createdAt'
  };

  export type PermissionAuditScalarFieldEnum = (typeof PermissionAuditScalarFieldEnum)[keyof typeof PermissionAuditScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'MemberShipType'
   */
  export type EnumMemberShipTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberShipType'>
    


  /**
   * Reference to a field of type 'MemberShipType[]'
   */
  export type ListEnumMemberShipTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberShipType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'EquipmentStatus'
   */
  export type EnumEquipmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EquipmentStatus'>
    


  /**
   * Reference to a field of type 'EquipmentStatus[]'
   */
  export type ListEnumEquipmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EquipmentStatus[]'>
    


  /**
   * Reference to a field of type 'MaintenanceType'
   */
  export type EnumMaintenanceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaintenanceType'>
    


  /**
   * Reference to a field of type 'MaintenanceType[]'
   */
  export type ListEnumMaintenanceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaintenanceType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    name?: StringFilter<"User"> | string
    username?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    phone_number?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    profile_picture?: StringNullableFilter<"User"> | string | null
    tokenVersion?: IntFilter<"User"> | number
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExp?: DateTimeNullableFilter<"User"> | Date | string | null
    bio?: StringNullableFilter<"User"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"User"> | Date | string | null
    department?: StringNullableFilter<"User"> | string | null
    email_verified?: BoolFilter<"User"> | boolean
    gender?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    lockedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    loginAttempts?: IntFilter<"User"> | number
    position?: StringNullableFilter<"User"> | string | null
    admin_profile?: XOR<AdministrativeProfileNullableScalarRelationFilter, AdministrativeProfileWhereInput> | null
    permission_audits?: PermissionAuditListRelationFilter
    access_logs?: UserAccessLogListRelationFilter
    address?: XOR<UserAddressNullableScalarRelationFilter, UserAddressWhereInput> | null
    emergency_contact?: XOR<UserEmergencyContactNullableScalarRelationFilter, UserEmergencyContactWhereInput> | null
    ip_restrictions?: UserIPRestrictionListRelationFilter
    notification_settings?: XOR<UserNotificationSettingsNullableScalarRelationFilter, UserNotificationSettingsWhereInput> | null
    preferences?: XOR<UserPreferencesNullableScalarRelationFilter, UserPreferencesWhereInput> | null
    privacy_settings?: XOR<UserPrivacySettingsNullableScalarRelationFilter, UserPrivacySettingsWhereInput> | null
    sessions?: UserSessionListRelationFilter
    social_media?: XOR<UserSocialMediaNullableScalarRelationFilter, UserSocialMediaWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrderInput | SortOrder
    email?: SortOrder
    phone_number?: SortOrderInput | SortOrder
    password?: SortOrder
    role?: SortOrder
    profile_picture?: SortOrderInput | SortOrder
    tokenVersion?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExp?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    email_verified?: SortOrder
    gender?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    loginAttempts?: SortOrder
    position?: SortOrderInput | SortOrder
    admin_profile?: AdministrativeProfileOrderByWithRelationInput
    permission_audits?: PermissionAuditOrderByRelationAggregateInput
    access_logs?: UserAccessLogOrderByRelationAggregateInput
    address?: UserAddressOrderByWithRelationInput
    emergency_contact?: UserEmergencyContactOrderByWithRelationInput
    ip_restrictions?: UserIPRestrictionOrderByRelationAggregateInput
    notification_settings?: UserNotificationSettingsOrderByWithRelationInput
    preferences?: UserPreferencesOrderByWithRelationInput
    privacy_settings?: UserPrivacySettingsOrderByWithRelationInput
    sessions?: UserSessionOrderByRelationAggregateInput
    social_media?: UserSocialMediaOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    username?: StringNullableFilter<"User"> | string | null
    phone_number?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    profile_picture?: StringNullableFilter<"User"> | string | null
    tokenVersion?: IntFilter<"User"> | number
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExp?: DateTimeNullableFilter<"User"> | Date | string | null
    bio?: StringNullableFilter<"User"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"User"> | Date | string | null
    department?: StringNullableFilter<"User"> | string | null
    email_verified?: BoolFilter<"User"> | boolean
    gender?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    lockedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    loginAttempts?: IntFilter<"User"> | number
    position?: StringNullableFilter<"User"> | string | null
    admin_profile?: XOR<AdministrativeProfileNullableScalarRelationFilter, AdministrativeProfileWhereInput> | null
    permission_audits?: PermissionAuditListRelationFilter
    access_logs?: UserAccessLogListRelationFilter
    address?: XOR<UserAddressNullableScalarRelationFilter, UserAddressWhereInput> | null
    emergency_contact?: XOR<UserEmergencyContactNullableScalarRelationFilter, UserEmergencyContactWhereInput> | null
    ip_restrictions?: UserIPRestrictionListRelationFilter
    notification_settings?: XOR<UserNotificationSettingsNullableScalarRelationFilter, UserNotificationSettingsWhereInput> | null
    preferences?: XOR<UserPreferencesNullableScalarRelationFilter, UserPreferencesWhereInput> | null
    privacy_settings?: XOR<UserPrivacySettingsNullableScalarRelationFilter, UserPrivacySettingsWhereInput> | null
    sessions?: UserSessionListRelationFilter
    social_media?: XOR<UserSocialMediaNullableScalarRelationFilter, UserSocialMediaWhereInput> | null
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrderInput | SortOrder
    email?: SortOrder
    phone_number?: SortOrderInput | SortOrder
    password?: SortOrder
    role?: SortOrder
    profile_picture?: SortOrderInput | SortOrder
    tokenVersion?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExp?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    email_verified?: SortOrder
    gender?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    loginAttempts?: SortOrder
    position?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    name?: StringWithAggregatesFilter<"User"> | string
    username?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    phone_number?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    profile_picture?: StringNullableWithAggregatesFilter<"User"> | string | null
    tokenVersion?: IntWithAggregatesFilter<"User"> | number
    created_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
    resetToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    resetTokenExp?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    department?: StringNullableWithAggregatesFilter<"User"> | string | null
    email_verified?: BoolWithAggregatesFilter<"User"> | boolean
    gender?: StringNullableWithAggregatesFilter<"User"> | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    lockedUntil?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    loginAttempts?: IntWithAggregatesFilter<"User"> | number
    position?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type UserSessionWhereInput = {
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    id?: StringFilter<"UserSession"> | string
    userId?: IntFilter<"UserSession"> | number
    token?: StringFilter<"UserSession"> | string
    deviceType?: StringNullableFilter<"UserSession"> | string | null
    deviceInfo?: StringNullableFilter<"UserSession"> | string | null
    ipAddress?: StringNullableFilter<"UserSession"> | string | null
    userAgent?: StringNullableFilter<"UserSession"> | string | null
    isActive?: BoolFilter<"UserSession"> | boolean
    lastActivity?: DateTimeFilter<"UserSession"> | Date | string
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeFilter<"UserSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    deviceType?: SortOrderInput | SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastActivity?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    userId?: IntFilter<"UserSession"> | number
    deviceType?: StringNullableFilter<"UserSession"> | string | null
    deviceInfo?: StringNullableFilter<"UserSession"> | string | null
    ipAddress?: StringNullableFilter<"UserSession"> | string | null
    userAgent?: StringNullableFilter<"UserSession"> | string | null
    isActive?: BoolFilter<"UserSession"> | boolean
    lastActivity?: DateTimeFilter<"UserSession"> | Date | string
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeFilter<"UserSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type UserSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    deviceType?: SortOrderInput | SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastActivity?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserSessionCountOrderByAggregateInput
    _avg?: UserSessionAvgOrderByAggregateInput
    _max?: UserSessionMaxOrderByAggregateInput
    _min?: UserSessionMinOrderByAggregateInput
    _sum?: UserSessionSumOrderByAggregateInput
  }

  export type UserSessionScalarWhereWithAggregatesInput = {
    AND?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    OR?: UserSessionScalarWhereWithAggregatesInput[]
    NOT?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSession"> | string
    userId?: IntWithAggregatesFilter<"UserSession"> | number
    token?: StringWithAggregatesFilter<"UserSession"> | string
    deviceType?: StringNullableWithAggregatesFilter<"UserSession"> | string | null
    deviceInfo?: StringNullableWithAggregatesFilter<"UserSession"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"UserSession"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"UserSession"> | string | null
    isActive?: BoolWithAggregatesFilter<"UserSession"> | boolean
    lastActivity?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
  }

  export type UserAccessLogWhereInput = {
    AND?: UserAccessLogWhereInput | UserAccessLogWhereInput[]
    OR?: UserAccessLogWhereInput[]
    NOT?: UserAccessLogWhereInput | UserAccessLogWhereInput[]
    id?: StringFilter<"UserAccessLog"> | string
    userId?: IntFilter<"UserAccessLog"> | number
    action?: StringFilter<"UserAccessLog"> | string
    ipAddress?: StringNullableFilter<"UserAccessLog"> | string | null
    userAgent?: StringNullableFilter<"UserAccessLog"> | string | null
    success?: BoolFilter<"UserAccessLog"> | boolean
    details?: StringNullableFilter<"UserAccessLog"> | string | null
    createdAt?: DateTimeFilter<"UserAccessLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserAccessLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    success?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserAccessLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserAccessLogWhereInput | UserAccessLogWhereInput[]
    OR?: UserAccessLogWhereInput[]
    NOT?: UserAccessLogWhereInput | UserAccessLogWhereInput[]
    userId?: IntFilter<"UserAccessLog"> | number
    action?: StringFilter<"UserAccessLog"> | string
    ipAddress?: StringNullableFilter<"UserAccessLog"> | string | null
    userAgent?: StringNullableFilter<"UserAccessLog"> | string | null
    success?: BoolFilter<"UserAccessLog"> | boolean
    details?: StringNullableFilter<"UserAccessLog"> | string | null
    createdAt?: DateTimeFilter<"UserAccessLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserAccessLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    success?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: UserAccessLogCountOrderByAggregateInput
    _avg?: UserAccessLogAvgOrderByAggregateInput
    _max?: UserAccessLogMaxOrderByAggregateInput
    _min?: UserAccessLogMinOrderByAggregateInput
    _sum?: UserAccessLogSumOrderByAggregateInput
  }

  export type UserAccessLogScalarWhereWithAggregatesInput = {
    AND?: UserAccessLogScalarWhereWithAggregatesInput | UserAccessLogScalarWhereWithAggregatesInput[]
    OR?: UserAccessLogScalarWhereWithAggregatesInput[]
    NOT?: UserAccessLogScalarWhereWithAggregatesInput | UserAccessLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserAccessLog"> | string
    userId?: IntWithAggregatesFilter<"UserAccessLog"> | number
    action?: StringWithAggregatesFilter<"UserAccessLog"> | string
    ipAddress?: StringNullableWithAggregatesFilter<"UserAccessLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"UserAccessLog"> | string | null
    success?: BoolWithAggregatesFilter<"UserAccessLog"> | boolean
    details?: StringNullableWithAggregatesFilter<"UserAccessLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserAccessLog"> | Date | string
  }

  export type UserIPRestrictionWhereInput = {
    AND?: UserIPRestrictionWhereInput | UserIPRestrictionWhereInput[]
    OR?: UserIPRestrictionWhereInput[]
    NOT?: UserIPRestrictionWhereInput | UserIPRestrictionWhereInput[]
    id?: StringFilter<"UserIPRestriction"> | string
    userId?: IntFilter<"UserIPRestriction"> | number
    ipAddress?: StringFilter<"UserIPRestriction"> | string
    type?: StringFilter<"UserIPRestriction"> | string
    reason?: StringNullableFilter<"UserIPRestriction"> | string | null
    expiresAt?: DateTimeNullableFilter<"UserIPRestriction"> | Date | string | null
    createdAt?: DateTimeFilter<"UserIPRestriction"> | Date | string
    updatedAt?: DateTimeFilter<"UserIPRestriction"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserIPRestrictionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    ipAddress?: SortOrder
    type?: SortOrder
    reason?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserIPRestrictionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserIPRestrictionWhereInput | UserIPRestrictionWhereInput[]
    OR?: UserIPRestrictionWhereInput[]
    NOT?: UserIPRestrictionWhereInput | UserIPRestrictionWhereInput[]
    userId?: IntFilter<"UserIPRestriction"> | number
    ipAddress?: StringFilter<"UserIPRestriction"> | string
    type?: StringFilter<"UserIPRestriction"> | string
    reason?: StringNullableFilter<"UserIPRestriction"> | string | null
    expiresAt?: DateTimeNullableFilter<"UserIPRestriction"> | Date | string | null
    createdAt?: DateTimeFilter<"UserIPRestriction"> | Date | string
    updatedAt?: DateTimeFilter<"UserIPRestriction"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserIPRestrictionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    ipAddress?: SortOrder
    type?: SortOrder
    reason?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserIPRestrictionCountOrderByAggregateInput
    _avg?: UserIPRestrictionAvgOrderByAggregateInput
    _max?: UserIPRestrictionMaxOrderByAggregateInput
    _min?: UserIPRestrictionMinOrderByAggregateInput
    _sum?: UserIPRestrictionSumOrderByAggregateInput
  }

  export type UserIPRestrictionScalarWhereWithAggregatesInput = {
    AND?: UserIPRestrictionScalarWhereWithAggregatesInput | UserIPRestrictionScalarWhereWithAggregatesInput[]
    OR?: UserIPRestrictionScalarWhereWithAggregatesInput[]
    NOT?: UserIPRestrictionScalarWhereWithAggregatesInput | UserIPRestrictionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserIPRestriction"> | string
    userId?: IntWithAggregatesFilter<"UserIPRestriction"> | number
    ipAddress?: StringWithAggregatesFilter<"UserIPRestriction"> | string
    type?: StringWithAggregatesFilter<"UserIPRestriction"> | string
    reason?: StringNullableWithAggregatesFilter<"UserIPRestriction"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"UserIPRestriction"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserIPRestriction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserIPRestriction"> | Date | string
  }

  export type UserAddressWhereInput = {
    AND?: UserAddressWhereInput | UserAddressWhereInput[]
    OR?: UserAddressWhereInput[]
    NOT?: UserAddressWhereInput | UserAddressWhereInput[]
    id?: IntFilter<"UserAddress"> | number
    userId?: IntFilter<"UserAddress"> | number
    street?: StringFilter<"UserAddress"> | string
    city?: StringFilter<"UserAddress"> | string
    state?: StringFilter<"UserAddress"> | string
    postalCode?: StringFilter<"UserAddress"> | string
    country?: StringFilter<"UserAddress"> | string
    createdAt?: DateTimeFilter<"UserAddress"> | Date | string
    updatedAt?: DateTimeFilter<"UserAddress"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserAddressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserAddressWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: UserAddressWhereInput | UserAddressWhereInput[]
    OR?: UserAddressWhereInput[]
    NOT?: UserAddressWhereInput | UserAddressWhereInput[]
    street?: StringFilter<"UserAddress"> | string
    city?: StringFilter<"UserAddress"> | string
    state?: StringFilter<"UserAddress"> | string
    postalCode?: StringFilter<"UserAddress"> | string
    country?: StringFilter<"UserAddress"> | string
    createdAt?: DateTimeFilter<"UserAddress"> | Date | string
    updatedAt?: DateTimeFilter<"UserAddress"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserAddressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserAddressCountOrderByAggregateInput
    _avg?: UserAddressAvgOrderByAggregateInput
    _max?: UserAddressMaxOrderByAggregateInput
    _min?: UserAddressMinOrderByAggregateInput
    _sum?: UserAddressSumOrderByAggregateInput
  }

  export type UserAddressScalarWhereWithAggregatesInput = {
    AND?: UserAddressScalarWhereWithAggregatesInput | UserAddressScalarWhereWithAggregatesInput[]
    OR?: UserAddressScalarWhereWithAggregatesInput[]
    NOT?: UserAddressScalarWhereWithAggregatesInput | UserAddressScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserAddress"> | number
    userId?: IntWithAggregatesFilter<"UserAddress"> | number
    street?: StringWithAggregatesFilter<"UserAddress"> | string
    city?: StringWithAggregatesFilter<"UserAddress"> | string
    state?: StringWithAggregatesFilter<"UserAddress"> | string
    postalCode?: StringWithAggregatesFilter<"UserAddress"> | string
    country?: StringWithAggregatesFilter<"UserAddress"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserAddress"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserAddress"> | Date | string
  }

  export type UserEmergencyContactWhereInput = {
    AND?: UserEmergencyContactWhereInput | UserEmergencyContactWhereInput[]
    OR?: UserEmergencyContactWhereInput[]
    NOT?: UserEmergencyContactWhereInput | UserEmergencyContactWhereInput[]
    id?: IntFilter<"UserEmergencyContact"> | number
    userId?: IntFilter<"UserEmergencyContact"> | number
    name?: StringFilter<"UserEmergencyContact"> | string
    relationship?: StringFilter<"UserEmergencyContact"> | string
    phone?: StringFilter<"UserEmergencyContact"> | string
    email?: StringFilter<"UserEmergencyContact"> | string
    createdAt?: DateTimeFilter<"UserEmergencyContact"> | Date | string
    updatedAt?: DateTimeFilter<"UserEmergencyContact"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserEmergencyContactOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    relationship?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserEmergencyContactWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: UserEmergencyContactWhereInput | UserEmergencyContactWhereInput[]
    OR?: UserEmergencyContactWhereInput[]
    NOT?: UserEmergencyContactWhereInput | UserEmergencyContactWhereInput[]
    name?: StringFilter<"UserEmergencyContact"> | string
    relationship?: StringFilter<"UserEmergencyContact"> | string
    phone?: StringFilter<"UserEmergencyContact"> | string
    email?: StringFilter<"UserEmergencyContact"> | string
    createdAt?: DateTimeFilter<"UserEmergencyContact"> | Date | string
    updatedAt?: DateTimeFilter<"UserEmergencyContact"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserEmergencyContactOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    relationship?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserEmergencyContactCountOrderByAggregateInput
    _avg?: UserEmergencyContactAvgOrderByAggregateInput
    _max?: UserEmergencyContactMaxOrderByAggregateInput
    _min?: UserEmergencyContactMinOrderByAggregateInput
    _sum?: UserEmergencyContactSumOrderByAggregateInput
  }

  export type UserEmergencyContactScalarWhereWithAggregatesInput = {
    AND?: UserEmergencyContactScalarWhereWithAggregatesInput | UserEmergencyContactScalarWhereWithAggregatesInput[]
    OR?: UserEmergencyContactScalarWhereWithAggregatesInput[]
    NOT?: UserEmergencyContactScalarWhereWithAggregatesInput | UserEmergencyContactScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserEmergencyContact"> | number
    userId?: IntWithAggregatesFilter<"UserEmergencyContact"> | number
    name?: StringWithAggregatesFilter<"UserEmergencyContact"> | string
    relationship?: StringWithAggregatesFilter<"UserEmergencyContact"> | string
    phone?: StringWithAggregatesFilter<"UserEmergencyContact"> | string
    email?: StringWithAggregatesFilter<"UserEmergencyContact"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserEmergencyContact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserEmergencyContact"> | Date | string
  }

  export type UserSocialMediaWhereInput = {
    AND?: UserSocialMediaWhereInput | UserSocialMediaWhereInput[]
    OR?: UserSocialMediaWhereInput[]
    NOT?: UserSocialMediaWhereInput | UserSocialMediaWhereInput[]
    id?: IntFilter<"UserSocialMedia"> | number
    userId?: IntFilter<"UserSocialMedia"> | number
    linkedin?: StringNullableFilter<"UserSocialMedia"> | string | null
    twitter?: StringNullableFilter<"UserSocialMedia"> | string | null
    facebook?: StringNullableFilter<"UserSocialMedia"> | string | null
    instagram?: StringNullableFilter<"UserSocialMedia"> | string | null
    createdAt?: DateTimeFilter<"UserSocialMedia"> | Date | string
    updatedAt?: DateTimeFilter<"UserSocialMedia"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserSocialMediaOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    linkedin?: SortOrderInput | SortOrder
    twitter?: SortOrderInput | SortOrder
    facebook?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserSocialMediaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: UserSocialMediaWhereInput | UserSocialMediaWhereInput[]
    OR?: UserSocialMediaWhereInput[]
    NOT?: UserSocialMediaWhereInput | UserSocialMediaWhereInput[]
    linkedin?: StringNullableFilter<"UserSocialMedia"> | string | null
    twitter?: StringNullableFilter<"UserSocialMedia"> | string | null
    facebook?: StringNullableFilter<"UserSocialMedia"> | string | null
    instagram?: StringNullableFilter<"UserSocialMedia"> | string | null
    createdAt?: DateTimeFilter<"UserSocialMedia"> | Date | string
    updatedAt?: DateTimeFilter<"UserSocialMedia"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserSocialMediaOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    linkedin?: SortOrderInput | SortOrder
    twitter?: SortOrderInput | SortOrder
    facebook?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserSocialMediaCountOrderByAggregateInput
    _avg?: UserSocialMediaAvgOrderByAggregateInput
    _max?: UserSocialMediaMaxOrderByAggregateInput
    _min?: UserSocialMediaMinOrderByAggregateInput
    _sum?: UserSocialMediaSumOrderByAggregateInput
  }

  export type UserSocialMediaScalarWhereWithAggregatesInput = {
    AND?: UserSocialMediaScalarWhereWithAggregatesInput | UserSocialMediaScalarWhereWithAggregatesInput[]
    OR?: UserSocialMediaScalarWhereWithAggregatesInput[]
    NOT?: UserSocialMediaScalarWhereWithAggregatesInput | UserSocialMediaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserSocialMedia"> | number
    userId?: IntWithAggregatesFilter<"UserSocialMedia"> | number
    linkedin?: StringNullableWithAggregatesFilter<"UserSocialMedia"> | string | null
    twitter?: StringNullableWithAggregatesFilter<"UserSocialMedia"> | string | null
    facebook?: StringNullableWithAggregatesFilter<"UserSocialMedia"> | string | null
    instagram?: StringNullableWithAggregatesFilter<"UserSocialMedia"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserSocialMedia"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserSocialMedia"> | Date | string
  }

  export type UserPreferencesWhereInput = {
    AND?: UserPreferencesWhereInput | UserPreferencesWhereInput[]
    OR?: UserPreferencesWhereInput[]
    NOT?: UserPreferencesWhereInput | UserPreferencesWhereInput[]
    id?: IntFilter<"UserPreferences"> | number
    userId?: IntFilter<"UserPreferences"> | number
    theme?: StringFilter<"UserPreferences"> | string
    language?: StringFilter<"UserPreferences"> | string
    timezone?: StringFilter<"UserPreferences"> | string
    dateFormat?: StringFilter<"UserPreferences"> | string
    timeFormat?: StringFilter<"UserPreferences"> | string
    currency?: StringFilter<"UserPreferences"> | string
    createdAt?: DateTimeFilter<"UserPreferences"> | Date | string
    updatedAt?: DateTimeFilter<"UserPreferences"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserPreferencesOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    theme?: SortOrder
    language?: SortOrder
    timezone?: SortOrder
    dateFormat?: SortOrder
    timeFormat?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserPreferencesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: UserPreferencesWhereInput | UserPreferencesWhereInput[]
    OR?: UserPreferencesWhereInput[]
    NOT?: UserPreferencesWhereInput | UserPreferencesWhereInput[]
    theme?: StringFilter<"UserPreferences"> | string
    language?: StringFilter<"UserPreferences"> | string
    timezone?: StringFilter<"UserPreferences"> | string
    dateFormat?: StringFilter<"UserPreferences"> | string
    timeFormat?: StringFilter<"UserPreferences"> | string
    currency?: StringFilter<"UserPreferences"> | string
    createdAt?: DateTimeFilter<"UserPreferences"> | Date | string
    updatedAt?: DateTimeFilter<"UserPreferences"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserPreferencesOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    theme?: SortOrder
    language?: SortOrder
    timezone?: SortOrder
    dateFormat?: SortOrder
    timeFormat?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserPreferencesCountOrderByAggregateInput
    _avg?: UserPreferencesAvgOrderByAggregateInput
    _max?: UserPreferencesMaxOrderByAggregateInput
    _min?: UserPreferencesMinOrderByAggregateInput
    _sum?: UserPreferencesSumOrderByAggregateInput
  }

  export type UserPreferencesScalarWhereWithAggregatesInput = {
    AND?: UserPreferencesScalarWhereWithAggregatesInput | UserPreferencesScalarWhereWithAggregatesInput[]
    OR?: UserPreferencesScalarWhereWithAggregatesInput[]
    NOT?: UserPreferencesScalarWhereWithAggregatesInput | UserPreferencesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserPreferences"> | number
    userId?: IntWithAggregatesFilter<"UserPreferences"> | number
    theme?: StringWithAggregatesFilter<"UserPreferences"> | string
    language?: StringWithAggregatesFilter<"UserPreferences"> | string
    timezone?: StringWithAggregatesFilter<"UserPreferences"> | string
    dateFormat?: StringWithAggregatesFilter<"UserPreferences"> | string
    timeFormat?: StringWithAggregatesFilter<"UserPreferences"> | string
    currency?: StringWithAggregatesFilter<"UserPreferences"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserPreferences"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserPreferences"> | Date | string
  }

  export type UserNotificationSettingsWhereInput = {
    AND?: UserNotificationSettingsWhereInput | UserNotificationSettingsWhereInput[]
    OR?: UserNotificationSettingsWhereInput[]
    NOT?: UserNotificationSettingsWhereInput | UserNotificationSettingsWhereInput[]
    id?: IntFilter<"UserNotificationSettings"> | number
    userId?: IntFilter<"UserNotificationSettings"> | number
    email_loginAlerts?: BoolFilter<"UserNotificationSettings"> | boolean
    email_securityUpdates?: BoolFilter<"UserNotificationSettings"> | boolean
    email_systemAnnouncements?: BoolFilter<"UserNotificationSettings"> | boolean
    email_marketingEmails?: BoolFilter<"UserNotificationSettings"> | boolean
    push_loginAlerts?: BoolFilter<"UserNotificationSettings"> | boolean
    push_securityUpdates?: BoolFilter<"UserNotificationSettings"> | boolean
    push_systemAnnouncements?: BoolFilter<"UserNotificationSettings"> | boolean
    push_marketingNotifications?: BoolFilter<"UserNotificationSettings"> | boolean
    sms_loginAlerts?: BoolFilter<"UserNotificationSettings"> | boolean
    sms_securityUpdates?: BoolFilter<"UserNotificationSettings"> | boolean
    sms_emergencyAlerts?: BoolFilter<"UserNotificationSettings"> | boolean
    createdAt?: DateTimeFilter<"UserNotificationSettings"> | Date | string
    updatedAt?: DateTimeFilter<"UserNotificationSettings"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserNotificationSettingsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    email_loginAlerts?: SortOrder
    email_securityUpdates?: SortOrder
    email_systemAnnouncements?: SortOrder
    email_marketingEmails?: SortOrder
    push_loginAlerts?: SortOrder
    push_securityUpdates?: SortOrder
    push_systemAnnouncements?: SortOrder
    push_marketingNotifications?: SortOrder
    sms_loginAlerts?: SortOrder
    sms_securityUpdates?: SortOrder
    sms_emergencyAlerts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserNotificationSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: UserNotificationSettingsWhereInput | UserNotificationSettingsWhereInput[]
    OR?: UserNotificationSettingsWhereInput[]
    NOT?: UserNotificationSettingsWhereInput | UserNotificationSettingsWhereInput[]
    email_loginAlerts?: BoolFilter<"UserNotificationSettings"> | boolean
    email_securityUpdates?: BoolFilter<"UserNotificationSettings"> | boolean
    email_systemAnnouncements?: BoolFilter<"UserNotificationSettings"> | boolean
    email_marketingEmails?: BoolFilter<"UserNotificationSettings"> | boolean
    push_loginAlerts?: BoolFilter<"UserNotificationSettings"> | boolean
    push_securityUpdates?: BoolFilter<"UserNotificationSettings"> | boolean
    push_systemAnnouncements?: BoolFilter<"UserNotificationSettings"> | boolean
    push_marketingNotifications?: BoolFilter<"UserNotificationSettings"> | boolean
    sms_loginAlerts?: BoolFilter<"UserNotificationSettings"> | boolean
    sms_securityUpdates?: BoolFilter<"UserNotificationSettings"> | boolean
    sms_emergencyAlerts?: BoolFilter<"UserNotificationSettings"> | boolean
    createdAt?: DateTimeFilter<"UserNotificationSettings"> | Date | string
    updatedAt?: DateTimeFilter<"UserNotificationSettings"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserNotificationSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    email_loginAlerts?: SortOrder
    email_securityUpdates?: SortOrder
    email_systemAnnouncements?: SortOrder
    email_marketingEmails?: SortOrder
    push_loginAlerts?: SortOrder
    push_securityUpdates?: SortOrder
    push_systemAnnouncements?: SortOrder
    push_marketingNotifications?: SortOrder
    sms_loginAlerts?: SortOrder
    sms_securityUpdates?: SortOrder
    sms_emergencyAlerts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserNotificationSettingsCountOrderByAggregateInput
    _avg?: UserNotificationSettingsAvgOrderByAggregateInput
    _max?: UserNotificationSettingsMaxOrderByAggregateInput
    _min?: UserNotificationSettingsMinOrderByAggregateInput
    _sum?: UserNotificationSettingsSumOrderByAggregateInput
  }

  export type UserNotificationSettingsScalarWhereWithAggregatesInput = {
    AND?: UserNotificationSettingsScalarWhereWithAggregatesInput | UserNotificationSettingsScalarWhereWithAggregatesInput[]
    OR?: UserNotificationSettingsScalarWhereWithAggregatesInput[]
    NOT?: UserNotificationSettingsScalarWhereWithAggregatesInput | UserNotificationSettingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserNotificationSettings"> | number
    userId?: IntWithAggregatesFilter<"UserNotificationSettings"> | number
    email_loginAlerts?: BoolWithAggregatesFilter<"UserNotificationSettings"> | boolean
    email_securityUpdates?: BoolWithAggregatesFilter<"UserNotificationSettings"> | boolean
    email_systemAnnouncements?: BoolWithAggregatesFilter<"UserNotificationSettings"> | boolean
    email_marketingEmails?: BoolWithAggregatesFilter<"UserNotificationSettings"> | boolean
    push_loginAlerts?: BoolWithAggregatesFilter<"UserNotificationSettings"> | boolean
    push_securityUpdates?: BoolWithAggregatesFilter<"UserNotificationSettings"> | boolean
    push_systemAnnouncements?: BoolWithAggregatesFilter<"UserNotificationSettings"> | boolean
    push_marketingNotifications?: BoolWithAggregatesFilter<"UserNotificationSettings"> | boolean
    sms_loginAlerts?: BoolWithAggregatesFilter<"UserNotificationSettings"> | boolean
    sms_securityUpdates?: BoolWithAggregatesFilter<"UserNotificationSettings"> | boolean
    sms_emergencyAlerts?: BoolWithAggregatesFilter<"UserNotificationSettings"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserNotificationSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserNotificationSettings"> | Date | string
  }

  export type UserPrivacySettingsWhereInput = {
    AND?: UserPrivacySettingsWhereInput | UserPrivacySettingsWhereInput[]
    OR?: UserPrivacySettingsWhereInput[]
    NOT?: UserPrivacySettingsWhereInput | UserPrivacySettingsWhereInput[]
    id?: IntFilter<"UserPrivacySettings"> | number
    userId?: IntFilter<"UserPrivacySettings"> | number
    profileVisibility?: StringFilter<"UserPrivacySettings"> | string
    showEmail?: BoolFilter<"UserPrivacySettings"> | boolean
    showPhone?: BoolFilter<"UserPrivacySettings"> | boolean
    showLocation?: BoolFilter<"UserPrivacySettings"> | boolean
    allowContact?: BoolFilter<"UserPrivacySettings"> | boolean
    createdAt?: DateTimeFilter<"UserPrivacySettings"> | Date | string
    updatedAt?: DateTimeFilter<"UserPrivacySettings"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserPrivacySettingsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    profileVisibility?: SortOrder
    showEmail?: SortOrder
    showPhone?: SortOrder
    showLocation?: SortOrder
    allowContact?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserPrivacySettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: UserPrivacySettingsWhereInput | UserPrivacySettingsWhereInput[]
    OR?: UserPrivacySettingsWhereInput[]
    NOT?: UserPrivacySettingsWhereInput | UserPrivacySettingsWhereInput[]
    profileVisibility?: StringFilter<"UserPrivacySettings"> | string
    showEmail?: BoolFilter<"UserPrivacySettings"> | boolean
    showPhone?: BoolFilter<"UserPrivacySettings"> | boolean
    showLocation?: BoolFilter<"UserPrivacySettings"> | boolean
    allowContact?: BoolFilter<"UserPrivacySettings"> | boolean
    createdAt?: DateTimeFilter<"UserPrivacySettings"> | Date | string
    updatedAt?: DateTimeFilter<"UserPrivacySettings"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserPrivacySettingsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    profileVisibility?: SortOrder
    showEmail?: SortOrder
    showPhone?: SortOrder
    showLocation?: SortOrder
    allowContact?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserPrivacySettingsCountOrderByAggregateInput
    _avg?: UserPrivacySettingsAvgOrderByAggregateInput
    _max?: UserPrivacySettingsMaxOrderByAggregateInput
    _min?: UserPrivacySettingsMinOrderByAggregateInput
    _sum?: UserPrivacySettingsSumOrderByAggregateInput
  }

  export type UserPrivacySettingsScalarWhereWithAggregatesInput = {
    AND?: UserPrivacySettingsScalarWhereWithAggregatesInput | UserPrivacySettingsScalarWhereWithAggregatesInput[]
    OR?: UserPrivacySettingsScalarWhereWithAggregatesInput[]
    NOT?: UserPrivacySettingsScalarWhereWithAggregatesInput | UserPrivacySettingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserPrivacySettings"> | number
    userId?: IntWithAggregatesFilter<"UserPrivacySettings"> | number
    profileVisibility?: StringWithAggregatesFilter<"UserPrivacySettings"> | string
    showEmail?: BoolWithAggregatesFilter<"UserPrivacySettings"> | boolean
    showPhone?: BoolWithAggregatesFilter<"UserPrivacySettings"> | boolean
    showLocation?: BoolWithAggregatesFilter<"UserPrivacySettings"> | boolean
    allowContact?: BoolWithAggregatesFilter<"UserPrivacySettings"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserPrivacySettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserPrivacySettings"> | Date | string
  }

  export type MemberWhereInput = {
    AND?: MemberWhereInput | MemberWhereInput[]
    OR?: MemberWhereInput[]
    NOT?: MemberWhereInput | MemberWhereInput[]
    id?: StringFilter<"Member"> | string
    name?: StringFilter<"Member"> | string
    email?: StringFilter<"Member"> | string
    phone_number?: StringNullableFilter<"Member"> | string | null
    password?: StringFilter<"Member"> | string
    age?: IntFilter<"Member"> | number
    profile_picture?: StringNullableFilter<"Member"> | string | null
    membershiptype?: EnumMemberShipTypeFilter<"Member"> | $Enums.MemberShipType
    createdAt?: DateTimeFilter<"Member"> | Date | string
    updatedAt?: DateTimeFilter<"Member"> | Date | string
    email_verification_expires?: DateTimeNullableFilter<"Member"> | Date | string | null
    email_verification_token?: StringNullableFilter<"Member"> | string | null
    email_verified?: BoolFilter<"Member"> | boolean
    terms_accepted?: BoolFilter<"Member"> | boolean
    terms_accepted_at?: DateTimeNullableFilter<"Member"> | Date | string | null
    address?: XOR<AddressNullableScalarRelationFilter, AddressWhereInput> | null
    emergency_contact?: XOR<EmergencyContactNullableScalarRelationFilter, EmergencyContactWhereInput> | null
    invoices?: InvoiceListRelationFilter
    medical_info?: XOR<MedicalInfoNullableScalarRelationFilter, MedicalInfoWhereInput> | null
    attendance?: MemberAttendanceListRelationFilter
    check_ins?: MemberCheckInListRelationFilter
    fitness_goals?: MemberFitnessGoalListRelationFilter
    payments?: PaymentListRelationFilter
    Subscription?: SubscriptionListRelationFilter
  }

  export type MemberOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrderInput | SortOrder
    password?: SortOrder
    age?: SortOrder
    profile_picture?: SortOrderInput | SortOrder
    membershiptype?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email_verification_expires?: SortOrderInput | SortOrder
    email_verification_token?: SortOrderInput | SortOrder
    email_verified?: SortOrder
    terms_accepted?: SortOrder
    terms_accepted_at?: SortOrderInput | SortOrder
    address?: AddressOrderByWithRelationInput
    emergency_contact?: EmergencyContactOrderByWithRelationInput
    invoices?: InvoiceOrderByRelationAggregateInput
    medical_info?: MedicalInfoOrderByWithRelationInput
    attendance?: MemberAttendanceOrderByRelationAggregateInput
    check_ins?: MemberCheckInOrderByRelationAggregateInput
    fitness_goals?: MemberFitnessGoalOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    Subscription?: SubscriptionOrderByRelationAggregateInput
  }

  export type MemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: MemberWhereInput | MemberWhereInput[]
    OR?: MemberWhereInput[]
    NOT?: MemberWhereInput | MemberWhereInput[]
    name?: StringFilter<"Member"> | string
    phone_number?: StringNullableFilter<"Member"> | string | null
    password?: StringFilter<"Member"> | string
    age?: IntFilter<"Member"> | number
    profile_picture?: StringNullableFilter<"Member"> | string | null
    membershiptype?: EnumMemberShipTypeFilter<"Member"> | $Enums.MemberShipType
    createdAt?: DateTimeFilter<"Member"> | Date | string
    updatedAt?: DateTimeFilter<"Member"> | Date | string
    email_verification_expires?: DateTimeNullableFilter<"Member"> | Date | string | null
    email_verification_token?: StringNullableFilter<"Member"> | string | null
    email_verified?: BoolFilter<"Member"> | boolean
    terms_accepted?: BoolFilter<"Member"> | boolean
    terms_accepted_at?: DateTimeNullableFilter<"Member"> | Date | string | null
    address?: XOR<AddressNullableScalarRelationFilter, AddressWhereInput> | null
    emergency_contact?: XOR<EmergencyContactNullableScalarRelationFilter, EmergencyContactWhereInput> | null
    invoices?: InvoiceListRelationFilter
    medical_info?: XOR<MedicalInfoNullableScalarRelationFilter, MedicalInfoWhereInput> | null
    attendance?: MemberAttendanceListRelationFilter
    check_ins?: MemberCheckInListRelationFilter
    fitness_goals?: MemberFitnessGoalListRelationFilter
    payments?: PaymentListRelationFilter
    Subscription?: SubscriptionListRelationFilter
  }, "id" | "email">

  export type MemberOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrderInput | SortOrder
    password?: SortOrder
    age?: SortOrder
    profile_picture?: SortOrderInput | SortOrder
    membershiptype?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email_verification_expires?: SortOrderInput | SortOrder
    email_verification_token?: SortOrderInput | SortOrder
    email_verified?: SortOrder
    terms_accepted?: SortOrder
    terms_accepted_at?: SortOrderInput | SortOrder
    _count?: MemberCountOrderByAggregateInput
    _avg?: MemberAvgOrderByAggregateInput
    _max?: MemberMaxOrderByAggregateInput
    _min?: MemberMinOrderByAggregateInput
    _sum?: MemberSumOrderByAggregateInput
  }

  export type MemberScalarWhereWithAggregatesInput = {
    AND?: MemberScalarWhereWithAggregatesInput | MemberScalarWhereWithAggregatesInput[]
    OR?: MemberScalarWhereWithAggregatesInput[]
    NOT?: MemberScalarWhereWithAggregatesInput | MemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Member"> | string
    name?: StringWithAggregatesFilter<"Member"> | string
    email?: StringWithAggregatesFilter<"Member"> | string
    phone_number?: StringNullableWithAggregatesFilter<"Member"> | string | null
    password?: StringWithAggregatesFilter<"Member"> | string
    age?: IntWithAggregatesFilter<"Member"> | number
    profile_picture?: StringNullableWithAggregatesFilter<"Member"> | string | null
    membershiptype?: EnumMemberShipTypeWithAggregatesFilter<"Member"> | $Enums.MemberShipType
    createdAt?: DateTimeWithAggregatesFilter<"Member"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Member"> | Date | string
    email_verification_expires?: DateTimeNullableWithAggregatesFilter<"Member"> | Date | string | null
    email_verification_token?: StringNullableWithAggregatesFilter<"Member"> | string | null
    email_verified?: BoolWithAggregatesFilter<"Member"> | boolean
    terms_accepted?: BoolWithAggregatesFilter<"Member"> | boolean
    terms_accepted_at?: DateTimeNullableWithAggregatesFilter<"Member"> | Date | string | null
  }

  export type MemberCheckInWhereInput = {
    AND?: MemberCheckInWhereInput | MemberCheckInWhereInput[]
    OR?: MemberCheckInWhereInput[]
    NOT?: MemberCheckInWhereInput | MemberCheckInWhereInput[]
    id?: StringFilter<"MemberCheckIn"> | string
    memberId?: StringFilter<"MemberCheckIn"> | string
    checkInTime?: DateTimeFilter<"MemberCheckIn"> | Date | string
    checkOutTime?: DateTimeNullableFilter<"MemberCheckIn"> | Date | string | null
    location?: StringNullableFilter<"MemberCheckIn"> | string | null
    notes?: StringNullableFilter<"MemberCheckIn"> | string | null
    createdAt?: DateTimeFilter<"MemberCheckIn"> | Date | string
    updatedAt?: DateTimeFilter<"MemberCheckIn"> | Date | string
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }

  export type MemberCheckInOrderByWithRelationInput = {
    id?: SortOrder
    memberId?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    member?: MemberOrderByWithRelationInput
  }

  export type MemberCheckInWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MemberCheckInWhereInput | MemberCheckInWhereInput[]
    OR?: MemberCheckInWhereInput[]
    NOT?: MemberCheckInWhereInput | MemberCheckInWhereInput[]
    memberId?: StringFilter<"MemberCheckIn"> | string
    checkInTime?: DateTimeFilter<"MemberCheckIn"> | Date | string
    checkOutTime?: DateTimeNullableFilter<"MemberCheckIn"> | Date | string | null
    location?: StringNullableFilter<"MemberCheckIn"> | string | null
    notes?: StringNullableFilter<"MemberCheckIn"> | string | null
    createdAt?: DateTimeFilter<"MemberCheckIn"> | Date | string
    updatedAt?: DateTimeFilter<"MemberCheckIn"> | Date | string
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }, "id">

  export type MemberCheckInOrderByWithAggregationInput = {
    id?: SortOrder
    memberId?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MemberCheckInCountOrderByAggregateInput
    _max?: MemberCheckInMaxOrderByAggregateInput
    _min?: MemberCheckInMinOrderByAggregateInput
  }

  export type MemberCheckInScalarWhereWithAggregatesInput = {
    AND?: MemberCheckInScalarWhereWithAggregatesInput | MemberCheckInScalarWhereWithAggregatesInput[]
    OR?: MemberCheckInScalarWhereWithAggregatesInput[]
    NOT?: MemberCheckInScalarWhereWithAggregatesInput | MemberCheckInScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MemberCheckIn"> | string
    memberId?: StringWithAggregatesFilter<"MemberCheckIn"> | string
    checkInTime?: DateTimeWithAggregatesFilter<"MemberCheckIn"> | Date | string
    checkOutTime?: DateTimeNullableWithAggregatesFilter<"MemberCheckIn"> | Date | string | null
    location?: StringNullableWithAggregatesFilter<"MemberCheckIn"> | string | null
    notes?: StringNullableWithAggregatesFilter<"MemberCheckIn"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MemberCheckIn"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MemberCheckIn"> | Date | string
  }

  export type MemberAttendanceWhereInput = {
    AND?: MemberAttendanceWhereInput | MemberAttendanceWhereInput[]
    OR?: MemberAttendanceWhereInput[]
    NOT?: MemberAttendanceWhereInput | MemberAttendanceWhereInput[]
    id?: StringFilter<"MemberAttendance"> | string
    memberId?: StringFilter<"MemberAttendance"> | string
    date?: DateTimeFilter<"MemberAttendance"> | Date | string
    timeIn?: DateTimeFilter<"MemberAttendance"> | Date | string
    timeOut?: DateTimeNullableFilter<"MemberAttendance"> | Date | string | null
    duration?: IntNullableFilter<"MemberAttendance"> | number | null
    createdAt?: DateTimeFilter<"MemberAttendance"> | Date | string
    updatedAt?: DateTimeFilter<"MemberAttendance"> | Date | string
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }

  export type MemberAttendanceOrderByWithRelationInput = {
    id?: SortOrder
    memberId?: SortOrder
    date?: SortOrder
    timeIn?: SortOrder
    timeOut?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    member?: MemberOrderByWithRelationInput
  }

  export type MemberAttendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MemberAttendanceWhereInput | MemberAttendanceWhereInput[]
    OR?: MemberAttendanceWhereInput[]
    NOT?: MemberAttendanceWhereInput | MemberAttendanceWhereInput[]
    memberId?: StringFilter<"MemberAttendance"> | string
    date?: DateTimeFilter<"MemberAttendance"> | Date | string
    timeIn?: DateTimeFilter<"MemberAttendance"> | Date | string
    timeOut?: DateTimeNullableFilter<"MemberAttendance"> | Date | string | null
    duration?: IntNullableFilter<"MemberAttendance"> | number | null
    createdAt?: DateTimeFilter<"MemberAttendance"> | Date | string
    updatedAt?: DateTimeFilter<"MemberAttendance"> | Date | string
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }, "id">

  export type MemberAttendanceOrderByWithAggregationInput = {
    id?: SortOrder
    memberId?: SortOrder
    date?: SortOrder
    timeIn?: SortOrder
    timeOut?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MemberAttendanceCountOrderByAggregateInput
    _avg?: MemberAttendanceAvgOrderByAggregateInput
    _max?: MemberAttendanceMaxOrderByAggregateInput
    _min?: MemberAttendanceMinOrderByAggregateInput
    _sum?: MemberAttendanceSumOrderByAggregateInput
  }

  export type MemberAttendanceScalarWhereWithAggregatesInput = {
    AND?: MemberAttendanceScalarWhereWithAggregatesInput | MemberAttendanceScalarWhereWithAggregatesInput[]
    OR?: MemberAttendanceScalarWhereWithAggregatesInput[]
    NOT?: MemberAttendanceScalarWhereWithAggregatesInput | MemberAttendanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MemberAttendance"> | string
    memberId?: StringWithAggregatesFilter<"MemberAttendance"> | string
    date?: DateTimeWithAggregatesFilter<"MemberAttendance"> | Date | string
    timeIn?: DateTimeWithAggregatesFilter<"MemberAttendance"> | Date | string
    timeOut?: DateTimeNullableWithAggregatesFilter<"MemberAttendance"> | Date | string | null
    duration?: IntNullableWithAggregatesFilter<"MemberAttendance"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"MemberAttendance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MemberAttendance"> | Date | string
  }

  export type MemberFitnessGoalWhereInput = {
    AND?: MemberFitnessGoalWhereInput | MemberFitnessGoalWhereInput[]
    OR?: MemberFitnessGoalWhereInput[]
    NOT?: MemberFitnessGoalWhereInput | MemberFitnessGoalWhereInput[]
    id?: StringFilter<"MemberFitnessGoal"> | string
    memberId?: StringFilter<"MemberFitnessGoal"> | string
    goalType?: StringFilter<"MemberFitnessGoal"> | string
    targetValue?: FloatFilter<"MemberFitnessGoal"> | number
    currentValue?: FloatFilter<"MemberFitnessGoal"> | number
    unit?: StringFilter<"MemberFitnessGoal"> | string
    targetDate?: DateTimeNullableFilter<"MemberFitnessGoal"> | Date | string | null
    isCompleted?: BoolFilter<"MemberFitnessGoal"> | boolean
    notes?: StringNullableFilter<"MemberFitnessGoal"> | string | null
    createdAt?: DateTimeFilter<"MemberFitnessGoal"> | Date | string
    updatedAt?: DateTimeFilter<"MemberFitnessGoal"> | Date | string
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }

  export type MemberFitnessGoalOrderByWithRelationInput = {
    id?: SortOrder
    memberId?: SortOrder
    goalType?: SortOrder
    targetValue?: SortOrder
    currentValue?: SortOrder
    unit?: SortOrder
    targetDate?: SortOrderInput | SortOrder
    isCompleted?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    member?: MemberOrderByWithRelationInput
  }

  export type MemberFitnessGoalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MemberFitnessGoalWhereInput | MemberFitnessGoalWhereInput[]
    OR?: MemberFitnessGoalWhereInput[]
    NOT?: MemberFitnessGoalWhereInput | MemberFitnessGoalWhereInput[]
    memberId?: StringFilter<"MemberFitnessGoal"> | string
    goalType?: StringFilter<"MemberFitnessGoal"> | string
    targetValue?: FloatFilter<"MemberFitnessGoal"> | number
    currentValue?: FloatFilter<"MemberFitnessGoal"> | number
    unit?: StringFilter<"MemberFitnessGoal"> | string
    targetDate?: DateTimeNullableFilter<"MemberFitnessGoal"> | Date | string | null
    isCompleted?: BoolFilter<"MemberFitnessGoal"> | boolean
    notes?: StringNullableFilter<"MemberFitnessGoal"> | string | null
    createdAt?: DateTimeFilter<"MemberFitnessGoal"> | Date | string
    updatedAt?: DateTimeFilter<"MemberFitnessGoal"> | Date | string
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }, "id">

  export type MemberFitnessGoalOrderByWithAggregationInput = {
    id?: SortOrder
    memberId?: SortOrder
    goalType?: SortOrder
    targetValue?: SortOrder
    currentValue?: SortOrder
    unit?: SortOrder
    targetDate?: SortOrderInput | SortOrder
    isCompleted?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MemberFitnessGoalCountOrderByAggregateInput
    _avg?: MemberFitnessGoalAvgOrderByAggregateInput
    _max?: MemberFitnessGoalMaxOrderByAggregateInput
    _min?: MemberFitnessGoalMinOrderByAggregateInput
    _sum?: MemberFitnessGoalSumOrderByAggregateInput
  }

  export type MemberFitnessGoalScalarWhereWithAggregatesInput = {
    AND?: MemberFitnessGoalScalarWhereWithAggregatesInput | MemberFitnessGoalScalarWhereWithAggregatesInput[]
    OR?: MemberFitnessGoalScalarWhereWithAggregatesInput[]
    NOT?: MemberFitnessGoalScalarWhereWithAggregatesInput | MemberFitnessGoalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MemberFitnessGoal"> | string
    memberId?: StringWithAggregatesFilter<"MemberFitnessGoal"> | string
    goalType?: StringWithAggregatesFilter<"MemberFitnessGoal"> | string
    targetValue?: FloatWithAggregatesFilter<"MemberFitnessGoal"> | number
    currentValue?: FloatWithAggregatesFilter<"MemberFitnessGoal"> | number
    unit?: StringWithAggregatesFilter<"MemberFitnessGoal"> | string
    targetDate?: DateTimeNullableWithAggregatesFilter<"MemberFitnessGoal"> | Date | string | null
    isCompleted?: BoolWithAggregatesFilter<"MemberFitnessGoal"> | boolean
    notes?: StringNullableWithAggregatesFilter<"MemberFitnessGoal"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MemberFitnessGoal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MemberFitnessGoal"> | Date | string
  }

  export type AddressWhereInput = {
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    id?: StringFilter<"Address"> | string
    memberId?: StringFilter<"Address"> | string
    street?: StringFilter<"Address"> | string
    city?: StringFilter<"Address"> | string
    state?: StringFilter<"Address"> | string
    zipCode?: StringFilter<"Address"> | string
    country?: StringFilter<"Address"> | string
    createdAt?: DateTimeFilter<"Address"> | Date | string
    updatedAt?: DateTimeFilter<"Address"> | Date | string
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }

  export type AddressOrderByWithRelationInput = {
    id?: SortOrder
    memberId?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    member?: MemberOrderByWithRelationInput
  }

  export type AddressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    memberId?: string
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    street?: StringFilter<"Address"> | string
    city?: StringFilter<"Address"> | string
    state?: StringFilter<"Address"> | string
    zipCode?: StringFilter<"Address"> | string
    country?: StringFilter<"Address"> | string
    createdAt?: DateTimeFilter<"Address"> | Date | string
    updatedAt?: DateTimeFilter<"Address"> | Date | string
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }, "id" | "memberId">

  export type AddressOrderByWithAggregationInput = {
    id?: SortOrder
    memberId?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AddressCountOrderByAggregateInput
    _max?: AddressMaxOrderByAggregateInput
    _min?: AddressMinOrderByAggregateInput
  }

  export type AddressScalarWhereWithAggregatesInput = {
    AND?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    OR?: AddressScalarWhereWithAggregatesInput[]
    NOT?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Address"> | string
    memberId?: StringWithAggregatesFilter<"Address"> | string
    street?: StringWithAggregatesFilter<"Address"> | string
    city?: StringWithAggregatesFilter<"Address"> | string
    state?: StringWithAggregatesFilter<"Address"> | string
    zipCode?: StringWithAggregatesFilter<"Address"> | string
    country?: StringWithAggregatesFilter<"Address"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Address"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Address"> | Date | string
  }

  export type EmergencyContactWhereInput = {
    AND?: EmergencyContactWhereInput | EmergencyContactWhereInput[]
    OR?: EmergencyContactWhereInput[]
    NOT?: EmergencyContactWhereInput | EmergencyContactWhereInput[]
    id?: StringFilter<"EmergencyContact"> | string
    memberId?: StringFilter<"EmergencyContact"> | string
    name?: StringFilter<"EmergencyContact"> | string
    relationship?: StringFilter<"EmergencyContact"> | string
    phone?: StringFilter<"EmergencyContact"> | string
    email?: StringNullableFilter<"EmergencyContact"> | string | null
    createdAt?: DateTimeFilter<"EmergencyContact"> | Date | string
    updatedAt?: DateTimeFilter<"EmergencyContact"> | Date | string
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }

  export type EmergencyContactOrderByWithRelationInput = {
    id?: SortOrder
    memberId?: SortOrder
    name?: SortOrder
    relationship?: SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    member?: MemberOrderByWithRelationInput
  }

  export type EmergencyContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    memberId?: string
    AND?: EmergencyContactWhereInput | EmergencyContactWhereInput[]
    OR?: EmergencyContactWhereInput[]
    NOT?: EmergencyContactWhereInput | EmergencyContactWhereInput[]
    name?: StringFilter<"EmergencyContact"> | string
    relationship?: StringFilter<"EmergencyContact"> | string
    phone?: StringFilter<"EmergencyContact"> | string
    email?: StringNullableFilter<"EmergencyContact"> | string | null
    createdAt?: DateTimeFilter<"EmergencyContact"> | Date | string
    updatedAt?: DateTimeFilter<"EmergencyContact"> | Date | string
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }, "id" | "memberId">

  export type EmergencyContactOrderByWithAggregationInput = {
    id?: SortOrder
    memberId?: SortOrder
    name?: SortOrder
    relationship?: SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmergencyContactCountOrderByAggregateInput
    _max?: EmergencyContactMaxOrderByAggregateInput
    _min?: EmergencyContactMinOrderByAggregateInput
  }

  export type EmergencyContactScalarWhereWithAggregatesInput = {
    AND?: EmergencyContactScalarWhereWithAggregatesInput | EmergencyContactScalarWhereWithAggregatesInput[]
    OR?: EmergencyContactScalarWhereWithAggregatesInput[]
    NOT?: EmergencyContactScalarWhereWithAggregatesInput | EmergencyContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmergencyContact"> | string
    memberId?: StringWithAggregatesFilter<"EmergencyContact"> | string
    name?: StringWithAggregatesFilter<"EmergencyContact"> | string
    relationship?: StringWithAggregatesFilter<"EmergencyContact"> | string
    phone?: StringWithAggregatesFilter<"EmergencyContact"> | string
    email?: StringNullableWithAggregatesFilter<"EmergencyContact"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EmergencyContact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmergencyContact"> | Date | string
  }

  export type MedicalInfoWhereInput = {
    AND?: MedicalInfoWhereInput | MedicalInfoWhereInput[]
    OR?: MedicalInfoWhereInput[]
    NOT?: MedicalInfoWhereInput | MedicalInfoWhereInput[]
    id?: StringFilter<"MedicalInfo"> | string
    memberId?: StringFilter<"MedicalInfo"> | string
    fitness_goals?: StringNullableListFilter<"MedicalInfo">
    health_conditions?: StringNullableListFilter<"MedicalInfo">
    allergies?: StringNullableListFilter<"MedicalInfo">
    medications?: StringNullableListFilter<"MedicalInfo">
    emergency_notes?: StringNullableFilter<"MedicalInfo"> | string | null
    createdAt?: DateTimeFilter<"MedicalInfo"> | Date | string
    updatedAt?: DateTimeFilter<"MedicalInfo"> | Date | string
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }

  export type MedicalInfoOrderByWithRelationInput = {
    id?: SortOrder
    memberId?: SortOrder
    fitness_goals?: SortOrder
    health_conditions?: SortOrder
    allergies?: SortOrder
    medications?: SortOrder
    emergency_notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    member?: MemberOrderByWithRelationInput
  }

  export type MedicalInfoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    memberId?: string
    AND?: MedicalInfoWhereInput | MedicalInfoWhereInput[]
    OR?: MedicalInfoWhereInput[]
    NOT?: MedicalInfoWhereInput | MedicalInfoWhereInput[]
    fitness_goals?: StringNullableListFilter<"MedicalInfo">
    health_conditions?: StringNullableListFilter<"MedicalInfo">
    allergies?: StringNullableListFilter<"MedicalInfo">
    medications?: StringNullableListFilter<"MedicalInfo">
    emergency_notes?: StringNullableFilter<"MedicalInfo"> | string | null
    createdAt?: DateTimeFilter<"MedicalInfo"> | Date | string
    updatedAt?: DateTimeFilter<"MedicalInfo"> | Date | string
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }, "id" | "memberId">

  export type MedicalInfoOrderByWithAggregationInput = {
    id?: SortOrder
    memberId?: SortOrder
    fitness_goals?: SortOrder
    health_conditions?: SortOrder
    allergies?: SortOrder
    medications?: SortOrder
    emergency_notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MedicalInfoCountOrderByAggregateInput
    _max?: MedicalInfoMaxOrderByAggregateInput
    _min?: MedicalInfoMinOrderByAggregateInput
  }

  export type MedicalInfoScalarWhereWithAggregatesInput = {
    AND?: MedicalInfoScalarWhereWithAggregatesInput | MedicalInfoScalarWhereWithAggregatesInput[]
    OR?: MedicalInfoScalarWhereWithAggregatesInput[]
    NOT?: MedicalInfoScalarWhereWithAggregatesInput | MedicalInfoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MedicalInfo"> | string
    memberId?: StringWithAggregatesFilter<"MedicalInfo"> | string
    fitness_goals?: StringNullableListFilter<"MedicalInfo">
    health_conditions?: StringNullableListFilter<"MedicalInfo">
    allergies?: StringNullableListFilter<"MedicalInfo">
    medications?: StringNullableListFilter<"MedicalInfo">
    emergency_notes?: StringNullableWithAggregatesFilter<"MedicalInfo"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MedicalInfo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MedicalInfo"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    memberId?: StringFilter<"Payment"> | string
    method?: StringFilter<"Payment"> | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    status?: StringFilter<"Payment"> | string
    description?: StringNullableFilter<"Payment"> | string | null
    reference?: StringNullableFilter<"Payment"> | string | null
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    Member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    memberId?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    description?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    Member?: MemberOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    amount?: FloatFilter<"Payment"> | number
    memberId?: StringFilter<"Payment"> | string
    method?: StringFilter<"Payment"> | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    status?: StringFilter<"Payment"> | string
    description?: StringNullableFilter<"Payment"> | string | null
    reference?: StringNullableFilter<"Payment"> | string | null
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    Member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    memberId?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    description?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    memberId?: StringWithAggregatesFilter<"Payment"> | string
    method?: StringWithAggregatesFilter<"Payment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    status?: StringWithAggregatesFilter<"Payment"> | string
    description?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    reference?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    memberId?: StringFilter<"Invoice"> | string
    amount?: FloatFilter<"Invoice"> | number
    details?: StringFilter<"Invoice"> | string
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    Member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    memberId?: SortOrder
    amount?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
    Member?: MemberOrderByWithRelationInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    memberId?: StringFilter<"Invoice"> | string
    amount?: FloatFilter<"Invoice"> | number
    details?: StringFilter<"Invoice"> | string
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    Member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }, "id">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    memberId?: SortOrder
    amount?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    memberId?: StringWithAggregatesFilter<"Invoice"> | string
    amount?: FloatWithAggregatesFilter<"Invoice"> | number
    details?: StringWithAggregatesFilter<"Invoice"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type MembershipPlanWhereInput = {
    AND?: MembershipPlanWhereInput | MembershipPlanWhereInput[]
    OR?: MembershipPlanWhereInput[]
    NOT?: MembershipPlanWhereInput | MembershipPlanWhereInput[]
    id?: StringFilter<"MembershipPlan"> | string
    name?: StringFilter<"MembershipPlan"> | string
    price?: FloatFilter<"MembershipPlan"> | number
    duration?: IntFilter<"MembershipPlan"> | number
    createdAt?: DateTimeFilter<"MembershipPlan"> | Date | string
    updatedAt?: DateTimeFilter<"MembershipPlan"> | Date | string
    subscriptions?: SubscriptionListRelationFilter
  }

  export type MembershipPlanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subscriptions?: SubscriptionOrderByRelationAggregateInput
  }

  export type MembershipPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: MembershipPlanWhereInput | MembershipPlanWhereInput[]
    OR?: MembershipPlanWhereInput[]
    NOT?: MembershipPlanWhereInput | MembershipPlanWhereInput[]
    price?: FloatFilter<"MembershipPlan"> | number
    duration?: IntFilter<"MembershipPlan"> | number
    createdAt?: DateTimeFilter<"MembershipPlan"> | Date | string
    updatedAt?: DateTimeFilter<"MembershipPlan"> | Date | string
    subscriptions?: SubscriptionListRelationFilter
  }, "id" | "name">

  export type MembershipPlanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MembershipPlanCountOrderByAggregateInput
    _avg?: MembershipPlanAvgOrderByAggregateInput
    _max?: MembershipPlanMaxOrderByAggregateInput
    _min?: MembershipPlanMinOrderByAggregateInput
    _sum?: MembershipPlanSumOrderByAggregateInput
  }

  export type MembershipPlanScalarWhereWithAggregatesInput = {
    AND?: MembershipPlanScalarWhereWithAggregatesInput | MembershipPlanScalarWhereWithAggregatesInput[]
    OR?: MembershipPlanScalarWhereWithAggregatesInput[]
    NOT?: MembershipPlanScalarWhereWithAggregatesInput | MembershipPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MembershipPlan"> | string
    name?: StringWithAggregatesFilter<"MembershipPlan"> | string
    price?: FloatWithAggregatesFilter<"MembershipPlan"> | number
    duration?: IntWithAggregatesFilter<"MembershipPlan"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MembershipPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MembershipPlan"> | Date | string
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: StringFilter<"Subscription"> | string
    memberId?: StringFilter<"Subscription"> | string
    planId?: StringFilter<"Subscription"> | string
    startDate?: DateTimeFilter<"Subscription"> | Date | string
    endDate?: DateTimeFilter<"Subscription"> | Date | string
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    plan?: XOR<MembershipPlanScalarRelationFilter, MembershipPlanWhereInput>
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    memberId?: SortOrder
    planId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    member?: MemberOrderByWithRelationInput
    plan?: MembershipPlanOrderByWithRelationInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    memberId?: StringFilter<"Subscription"> | string
    planId?: StringFilter<"Subscription"> | string
    startDate?: DateTimeFilter<"Subscription"> | Date | string
    endDate?: DateTimeFilter<"Subscription"> | Date | string
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    plan?: XOR<MembershipPlanScalarRelationFilter, MembershipPlanWhereInput>
  }, "id">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    memberId?: SortOrder
    planId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscription"> | string
    memberId?: StringWithAggregatesFilter<"Subscription"> | string
    planId?: StringWithAggregatesFilter<"Subscription"> | string
    startDate?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
  }

  export type EquipmentWhereInput = {
    AND?: EquipmentWhereInput | EquipmentWhereInput[]
    OR?: EquipmentWhereInput[]
    NOT?: EquipmentWhereInput | EquipmentWhereInput[]
    id?: StringFilter<"Equipment"> | string
    name?: StringFilter<"Equipment"> | string
    type?: StringFilter<"Equipment"> | string
    quantity?: IntFilter<"Equipment"> | number
    createdAt?: DateTimeFilter<"Equipment"> | Date | string
    updatedAt?: DateTimeFilter<"Equipment"> | Date | string
    available?: IntFilter<"Equipment"> | number
    brand?: StringNullableFilter<"Equipment"> | string | null
    category?: StringFilter<"Equipment"> | string
    cost?: FloatNullableFilter<"Equipment"> | number | null
    description?: StringNullableFilter<"Equipment"> | string | null
    imageUrl?: StringNullableFilter<"Equipment"> | string | null
    inUse?: IntFilter<"Equipment"> | number
    lastMaintenance?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    location?: StringNullableFilter<"Equipment"> | string | null
    maintenance?: BoolFilter<"Equipment"> | boolean
    model?: StringNullableFilter<"Equipment"> | string | null
    nextMaintenance?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    purchaseDate?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    serialNumber?: StringNullableFilter<"Equipment"> | string | null
    status?: EnumEquipmentStatusFilter<"Equipment"> | $Enums.EquipmentStatus
    warrantyExpiry?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    maintenanceLogs?: MaintenanceLogListRelationFilter
  }

  export type EquipmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    available?: SortOrder
    brand?: SortOrderInput | SortOrder
    category?: SortOrder
    cost?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    inUse?: SortOrder
    lastMaintenance?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    maintenance?: SortOrder
    model?: SortOrderInput | SortOrder
    nextMaintenance?: SortOrderInput | SortOrder
    purchaseDate?: SortOrderInput | SortOrder
    serialNumber?: SortOrderInput | SortOrder
    status?: SortOrder
    warrantyExpiry?: SortOrderInput | SortOrder
    maintenanceLogs?: MaintenanceLogOrderByRelationAggregateInput
  }

  export type EquipmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    serialNumber?: string
    AND?: EquipmentWhereInput | EquipmentWhereInput[]
    OR?: EquipmentWhereInput[]
    NOT?: EquipmentWhereInput | EquipmentWhereInput[]
    name?: StringFilter<"Equipment"> | string
    type?: StringFilter<"Equipment"> | string
    quantity?: IntFilter<"Equipment"> | number
    createdAt?: DateTimeFilter<"Equipment"> | Date | string
    updatedAt?: DateTimeFilter<"Equipment"> | Date | string
    available?: IntFilter<"Equipment"> | number
    brand?: StringNullableFilter<"Equipment"> | string | null
    category?: StringFilter<"Equipment"> | string
    cost?: FloatNullableFilter<"Equipment"> | number | null
    description?: StringNullableFilter<"Equipment"> | string | null
    imageUrl?: StringNullableFilter<"Equipment"> | string | null
    inUse?: IntFilter<"Equipment"> | number
    lastMaintenance?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    location?: StringNullableFilter<"Equipment"> | string | null
    maintenance?: BoolFilter<"Equipment"> | boolean
    model?: StringNullableFilter<"Equipment"> | string | null
    nextMaintenance?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    purchaseDate?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    status?: EnumEquipmentStatusFilter<"Equipment"> | $Enums.EquipmentStatus
    warrantyExpiry?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    maintenanceLogs?: MaintenanceLogListRelationFilter
  }, "id" | "serialNumber">

  export type EquipmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    available?: SortOrder
    brand?: SortOrderInput | SortOrder
    category?: SortOrder
    cost?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    inUse?: SortOrder
    lastMaintenance?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    maintenance?: SortOrder
    model?: SortOrderInput | SortOrder
    nextMaintenance?: SortOrderInput | SortOrder
    purchaseDate?: SortOrderInput | SortOrder
    serialNumber?: SortOrderInput | SortOrder
    status?: SortOrder
    warrantyExpiry?: SortOrderInput | SortOrder
    _count?: EquipmentCountOrderByAggregateInput
    _avg?: EquipmentAvgOrderByAggregateInput
    _max?: EquipmentMaxOrderByAggregateInput
    _min?: EquipmentMinOrderByAggregateInput
    _sum?: EquipmentSumOrderByAggregateInput
  }

  export type EquipmentScalarWhereWithAggregatesInput = {
    AND?: EquipmentScalarWhereWithAggregatesInput | EquipmentScalarWhereWithAggregatesInput[]
    OR?: EquipmentScalarWhereWithAggregatesInput[]
    NOT?: EquipmentScalarWhereWithAggregatesInput | EquipmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Equipment"> | string
    name?: StringWithAggregatesFilter<"Equipment"> | string
    type?: StringWithAggregatesFilter<"Equipment"> | string
    quantity?: IntWithAggregatesFilter<"Equipment"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Equipment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Equipment"> | Date | string
    available?: IntWithAggregatesFilter<"Equipment"> | number
    brand?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    category?: StringWithAggregatesFilter<"Equipment"> | string
    cost?: FloatNullableWithAggregatesFilter<"Equipment"> | number | null
    description?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    inUse?: IntWithAggregatesFilter<"Equipment"> | number
    lastMaintenance?: DateTimeNullableWithAggregatesFilter<"Equipment"> | Date | string | null
    location?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    maintenance?: BoolWithAggregatesFilter<"Equipment"> | boolean
    model?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    nextMaintenance?: DateTimeNullableWithAggregatesFilter<"Equipment"> | Date | string | null
    purchaseDate?: DateTimeNullableWithAggregatesFilter<"Equipment"> | Date | string | null
    serialNumber?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    status?: EnumEquipmentStatusWithAggregatesFilter<"Equipment"> | $Enums.EquipmentStatus
    warrantyExpiry?: DateTimeNullableWithAggregatesFilter<"Equipment"> | Date | string | null
  }

  export type MaintenanceLogWhereInput = {
    AND?: MaintenanceLogWhereInput | MaintenanceLogWhereInput[]
    OR?: MaintenanceLogWhereInput[]
    NOT?: MaintenanceLogWhereInput | MaintenanceLogWhereInput[]
    id?: StringFilter<"MaintenanceLog"> | string
    equipmentId?: StringFilter<"MaintenanceLog"> | string
    type?: EnumMaintenanceTypeFilter<"MaintenanceLog"> | $Enums.MaintenanceType
    description?: StringFilter<"MaintenanceLog"> | string
    cost?: FloatNullableFilter<"MaintenanceLog"> | number | null
    performedBy?: StringNullableFilter<"MaintenanceLog"> | string | null
    performedAt?: DateTimeFilter<"MaintenanceLog"> | Date | string
    nextDue?: DateTimeNullableFilter<"MaintenanceLog"> | Date | string | null
    equipment?: XOR<EquipmentScalarRelationFilter, EquipmentWhereInput>
  }

  export type MaintenanceLogOrderByWithRelationInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    cost?: SortOrderInput | SortOrder
    performedBy?: SortOrderInput | SortOrder
    performedAt?: SortOrder
    nextDue?: SortOrderInput | SortOrder
    equipment?: EquipmentOrderByWithRelationInput
  }

  export type MaintenanceLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MaintenanceLogWhereInput | MaintenanceLogWhereInput[]
    OR?: MaintenanceLogWhereInput[]
    NOT?: MaintenanceLogWhereInput | MaintenanceLogWhereInput[]
    equipmentId?: StringFilter<"MaintenanceLog"> | string
    type?: EnumMaintenanceTypeFilter<"MaintenanceLog"> | $Enums.MaintenanceType
    description?: StringFilter<"MaintenanceLog"> | string
    cost?: FloatNullableFilter<"MaintenanceLog"> | number | null
    performedBy?: StringNullableFilter<"MaintenanceLog"> | string | null
    performedAt?: DateTimeFilter<"MaintenanceLog"> | Date | string
    nextDue?: DateTimeNullableFilter<"MaintenanceLog"> | Date | string | null
    equipment?: XOR<EquipmentScalarRelationFilter, EquipmentWhereInput>
  }, "id">

  export type MaintenanceLogOrderByWithAggregationInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    cost?: SortOrderInput | SortOrder
    performedBy?: SortOrderInput | SortOrder
    performedAt?: SortOrder
    nextDue?: SortOrderInput | SortOrder
    _count?: MaintenanceLogCountOrderByAggregateInput
    _avg?: MaintenanceLogAvgOrderByAggregateInput
    _max?: MaintenanceLogMaxOrderByAggregateInput
    _min?: MaintenanceLogMinOrderByAggregateInput
    _sum?: MaintenanceLogSumOrderByAggregateInput
  }

  export type MaintenanceLogScalarWhereWithAggregatesInput = {
    AND?: MaintenanceLogScalarWhereWithAggregatesInput | MaintenanceLogScalarWhereWithAggregatesInput[]
    OR?: MaintenanceLogScalarWhereWithAggregatesInput[]
    NOT?: MaintenanceLogScalarWhereWithAggregatesInput | MaintenanceLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MaintenanceLog"> | string
    equipmentId?: StringWithAggregatesFilter<"MaintenanceLog"> | string
    type?: EnumMaintenanceTypeWithAggregatesFilter<"MaintenanceLog"> | $Enums.MaintenanceType
    description?: StringWithAggregatesFilter<"MaintenanceLog"> | string
    cost?: FloatNullableWithAggregatesFilter<"MaintenanceLog"> | number | null
    performedBy?: StringNullableWithAggregatesFilter<"MaintenanceLog"> | string | null
    performedAt?: DateTimeWithAggregatesFilter<"MaintenanceLog"> | Date | string
    nextDue?: DateTimeNullableWithAggregatesFilter<"MaintenanceLog"> | Date | string | null
  }

  export type SystemIntegrationWhereInput = {
    AND?: SystemIntegrationWhereInput | SystemIntegrationWhereInput[]
    OR?: SystemIntegrationWhereInput[]
    NOT?: SystemIntegrationWhereInput | SystemIntegrationWhereInput[]
    id?: StringFilter<"SystemIntegration"> | string
    name?: StringFilter<"SystemIntegration"> | string
    type?: StringFilter<"SystemIntegration"> | string
    status?: StringFilter<"SystemIntegration"> | string
    healthScore?: IntFilter<"SystemIntegration"> | number
    endpoint?: StringNullableFilter<"SystemIntegration"> | string | null
    apiKey?: StringNullableFilter<"SystemIntegration"> | string | null
    config?: JsonNullableFilter<"SystemIntegration">
    lastSync?: DateTimeNullableFilter<"SystemIntegration"> | Date | string | null
    errorCount?: IntFilter<"SystemIntegration"> | number
    createdAt?: DateTimeFilter<"SystemIntegration"> | Date | string
    updatedAt?: DateTimeFilter<"SystemIntegration"> | Date | string
  }

  export type SystemIntegrationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    healthScore?: SortOrder
    endpoint?: SortOrderInput | SortOrder
    apiKey?: SortOrderInput | SortOrder
    config?: SortOrderInput | SortOrder
    lastSync?: SortOrderInput | SortOrder
    errorCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemIntegrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SystemIntegrationWhereInput | SystemIntegrationWhereInput[]
    OR?: SystemIntegrationWhereInput[]
    NOT?: SystemIntegrationWhereInput | SystemIntegrationWhereInput[]
    name?: StringFilter<"SystemIntegration"> | string
    type?: StringFilter<"SystemIntegration"> | string
    status?: StringFilter<"SystemIntegration"> | string
    healthScore?: IntFilter<"SystemIntegration"> | number
    endpoint?: StringNullableFilter<"SystemIntegration"> | string | null
    apiKey?: StringNullableFilter<"SystemIntegration"> | string | null
    config?: JsonNullableFilter<"SystemIntegration">
    lastSync?: DateTimeNullableFilter<"SystemIntegration"> | Date | string | null
    errorCount?: IntFilter<"SystemIntegration"> | number
    createdAt?: DateTimeFilter<"SystemIntegration"> | Date | string
    updatedAt?: DateTimeFilter<"SystemIntegration"> | Date | string
  }, "id">

  export type SystemIntegrationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    healthScore?: SortOrder
    endpoint?: SortOrderInput | SortOrder
    apiKey?: SortOrderInput | SortOrder
    config?: SortOrderInput | SortOrder
    lastSync?: SortOrderInput | SortOrder
    errorCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SystemIntegrationCountOrderByAggregateInput
    _avg?: SystemIntegrationAvgOrderByAggregateInput
    _max?: SystemIntegrationMaxOrderByAggregateInput
    _min?: SystemIntegrationMinOrderByAggregateInput
    _sum?: SystemIntegrationSumOrderByAggregateInput
  }

  export type SystemIntegrationScalarWhereWithAggregatesInput = {
    AND?: SystemIntegrationScalarWhereWithAggregatesInput | SystemIntegrationScalarWhereWithAggregatesInput[]
    OR?: SystemIntegrationScalarWhereWithAggregatesInput[]
    NOT?: SystemIntegrationScalarWhereWithAggregatesInput | SystemIntegrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemIntegration"> | string
    name?: StringWithAggregatesFilter<"SystemIntegration"> | string
    type?: StringWithAggregatesFilter<"SystemIntegration"> | string
    status?: StringWithAggregatesFilter<"SystemIntegration"> | string
    healthScore?: IntWithAggregatesFilter<"SystemIntegration"> | number
    endpoint?: StringNullableWithAggregatesFilter<"SystemIntegration"> | string | null
    apiKey?: StringNullableWithAggregatesFilter<"SystemIntegration"> | string | null
    config?: JsonNullableWithAggregatesFilter<"SystemIntegration">
    lastSync?: DateTimeNullableWithAggregatesFilter<"SystemIntegration"> | Date | string | null
    errorCount?: IntWithAggregatesFilter<"SystemIntegration"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SystemIntegration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SystemIntegration"> | Date | string
  }

  export type AutomationWorkflowWhereInput = {
    AND?: AutomationWorkflowWhereInput | AutomationWorkflowWhereInput[]
    OR?: AutomationWorkflowWhereInput[]
    NOT?: AutomationWorkflowWhereInput | AutomationWorkflowWhereInput[]
    id?: StringFilter<"AutomationWorkflow"> | string
    name?: StringFilter<"AutomationWorkflow"> | string
    description?: StringNullableFilter<"AutomationWorkflow"> | string | null
    category?: StringFilter<"AutomationWorkflow"> | string
    status?: StringFilter<"AutomationWorkflow"> | string
    priority?: StringFilter<"AutomationWorkflow"> | string
    trigger?: StringFilter<"AutomationWorkflow"> | string
    schedule?: StringNullableFilter<"AutomationWorkflow"> | string | null
    config?: JsonNullableFilter<"AutomationWorkflow">
    successCount?: IntFilter<"AutomationWorkflow"> | number
    failureCount?: IntFilter<"AutomationWorkflow"> | number
    lastRun?: DateTimeNullableFilter<"AutomationWorkflow"> | Date | string | null
    nextRun?: DateTimeNullableFilter<"AutomationWorkflow"> | Date | string | null
    createdAt?: DateTimeFilter<"AutomationWorkflow"> | Date | string
    updatedAt?: DateTimeFilter<"AutomationWorkflow"> | Date | string
  }

  export type AutomationWorkflowOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    trigger?: SortOrder
    schedule?: SortOrderInput | SortOrder
    config?: SortOrderInput | SortOrder
    successCount?: SortOrder
    failureCount?: SortOrder
    lastRun?: SortOrderInput | SortOrder
    nextRun?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AutomationWorkflowWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AutomationWorkflowWhereInput | AutomationWorkflowWhereInput[]
    OR?: AutomationWorkflowWhereInput[]
    NOT?: AutomationWorkflowWhereInput | AutomationWorkflowWhereInput[]
    name?: StringFilter<"AutomationWorkflow"> | string
    description?: StringNullableFilter<"AutomationWorkflow"> | string | null
    category?: StringFilter<"AutomationWorkflow"> | string
    status?: StringFilter<"AutomationWorkflow"> | string
    priority?: StringFilter<"AutomationWorkflow"> | string
    trigger?: StringFilter<"AutomationWorkflow"> | string
    schedule?: StringNullableFilter<"AutomationWorkflow"> | string | null
    config?: JsonNullableFilter<"AutomationWorkflow">
    successCount?: IntFilter<"AutomationWorkflow"> | number
    failureCount?: IntFilter<"AutomationWorkflow"> | number
    lastRun?: DateTimeNullableFilter<"AutomationWorkflow"> | Date | string | null
    nextRun?: DateTimeNullableFilter<"AutomationWorkflow"> | Date | string | null
    createdAt?: DateTimeFilter<"AutomationWorkflow"> | Date | string
    updatedAt?: DateTimeFilter<"AutomationWorkflow"> | Date | string
  }, "id">

  export type AutomationWorkflowOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    trigger?: SortOrder
    schedule?: SortOrderInput | SortOrder
    config?: SortOrderInput | SortOrder
    successCount?: SortOrder
    failureCount?: SortOrder
    lastRun?: SortOrderInput | SortOrder
    nextRun?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AutomationWorkflowCountOrderByAggregateInput
    _avg?: AutomationWorkflowAvgOrderByAggregateInput
    _max?: AutomationWorkflowMaxOrderByAggregateInput
    _min?: AutomationWorkflowMinOrderByAggregateInput
    _sum?: AutomationWorkflowSumOrderByAggregateInput
  }

  export type AutomationWorkflowScalarWhereWithAggregatesInput = {
    AND?: AutomationWorkflowScalarWhereWithAggregatesInput | AutomationWorkflowScalarWhereWithAggregatesInput[]
    OR?: AutomationWorkflowScalarWhereWithAggregatesInput[]
    NOT?: AutomationWorkflowScalarWhereWithAggregatesInput | AutomationWorkflowScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AutomationWorkflow"> | string
    name?: StringWithAggregatesFilter<"AutomationWorkflow"> | string
    description?: StringNullableWithAggregatesFilter<"AutomationWorkflow"> | string | null
    category?: StringWithAggregatesFilter<"AutomationWorkflow"> | string
    status?: StringWithAggregatesFilter<"AutomationWorkflow"> | string
    priority?: StringWithAggregatesFilter<"AutomationWorkflow"> | string
    trigger?: StringWithAggregatesFilter<"AutomationWorkflow"> | string
    schedule?: StringNullableWithAggregatesFilter<"AutomationWorkflow"> | string | null
    config?: JsonNullableWithAggregatesFilter<"AutomationWorkflow">
    successCount?: IntWithAggregatesFilter<"AutomationWorkflow"> | number
    failureCount?: IntWithAggregatesFilter<"AutomationWorkflow"> | number
    lastRun?: DateTimeNullableWithAggregatesFilter<"AutomationWorkflow"> | Date | string | null
    nextRun?: DateTimeNullableWithAggregatesFilter<"AutomationWorkflow"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AutomationWorkflow"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AutomationWorkflow"> | Date | string
  }

  export type DataSyncJobWhereInput = {
    AND?: DataSyncJobWhereInput | DataSyncJobWhereInput[]
    OR?: DataSyncJobWhereInput[]
    NOT?: DataSyncJobWhereInput | DataSyncJobWhereInput[]
    id?: StringFilter<"DataSyncJob"> | string
    name?: StringFilter<"DataSyncJob"> | string
    source?: StringFilter<"DataSyncJob"> | string
    destination?: StringFilter<"DataSyncJob"> | string
    status?: StringFilter<"DataSyncJob"> | string
    processedRecords?: IntFilter<"DataSyncJob"> | number
    failedRecords?: IntFilter<"DataSyncJob"> | number
    totalRecords?: IntFilter<"DataSyncJob"> | number
    startedAt?: DateTimeNullableFilter<"DataSyncJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"DataSyncJob"> | Date | string | null
    errorMessage?: StringNullableFilter<"DataSyncJob"> | string | null
    config?: JsonNullableFilter<"DataSyncJob">
    createdAt?: DateTimeFilter<"DataSyncJob"> | Date | string
    updatedAt?: DateTimeFilter<"DataSyncJob"> | Date | string
  }

  export type DataSyncJobOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    source?: SortOrder
    destination?: SortOrder
    status?: SortOrder
    processedRecords?: SortOrder
    failedRecords?: SortOrder
    totalRecords?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    config?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DataSyncJobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DataSyncJobWhereInput | DataSyncJobWhereInput[]
    OR?: DataSyncJobWhereInput[]
    NOT?: DataSyncJobWhereInput | DataSyncJobWhereInput[]
    name?: StringFilter<"DataSyncJob"> | string
    source?: StringFilter<"DataSyncJob"> | string
    destination?: StringFilter<"DataSyncJob"> | string
    status?: StringFilter<"DataSyncJob"> | string
    processedRecords?: IntFilter<"DataSyncJob"> | number
    failedRecords?: IntFilter<"DataSyncJob"> | number
    totalRecords?: IntFilter<"DataSyncJob"> | number
    startedAt?: DateTimeNullableFilter<"DataSyncJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"DataSyncJob"> | Date | string | null
    errorMessage?: StringNullableFilter<"DataSyncJob"> | string | null
    config?: JsonNullableFilter<"DataSyncJob">
    createdAt?: DateTimeFilter<"DataSyncJob"> | Date | string
    updatedAt?: DateTimeFilter<"DataSyncJob"> | Date | string
  }, "id">

  export type DataSyncJobOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    source?: SortOrder
    destination?: SortOrder
    status?: SortOrder
    processedRecords?: SortOrder
    failedRecords?: SortOrder
    totalRecords?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    config?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DataSyncJobCountOrderByAggregateInput
    _avg?: DataSyncJobAvgOrderByAggregateInput
    _max?: DataSyncJobMaxOrderByAggregateInput
    _min?: DataSyncJobMinOrderByAggregateInput
    _sum?: DataSyncJobSumOrderByAggregateInput
  }

  export type DataSyncJobScalarWhereWithAggregatesInput = {
    AND?: DataSyncJobScalarWhereWithAggregatesInput | DataSyncJobScalarWhereWithAggregatesInput[]
    OR?: DataSyncJobScalarWhereWithAggregatesInput[]
    NOT?: DataSyncJobScalarWhereWithAggregatesInput | DataSyncJobScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DataSyncJob"> | string
    name?: StringWithAggregatesFilter<"DataSyncJob"> | string
    source?: StringWithAggregatesFilter<"DataSyncJob"> | string
    destination?: StringWithAggregatesFilter<"DataSyncJob"> | string
    status?: StringWithAggregatesFilter<"DataSyncJob"> | string
    processedRecords?: IntWithAggregatesFilter<"DataSyncJob"> | number
    failedRecords?: IntWithAggregatesFilter<"DataSyncJob"> | number
    totalRecords?: IntWithAggregatesFilter<"DataSyncJob"> | number
    startedAt?: DateTimeNullableWithAggregatesFilter<"DataSyncJob"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"DataSyncJob"> | Date | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"DataSyncJob"> | string | null
    config?: JsonNullableWithAggregatesFilter<"DataSyncJob">
    createdAt?: DateTimeWithAggregatesFilter<"DataSyncJob"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DataSyncJob"> | Date | string
  }

  export type WebhookEndpointWhereInput = {
    AND?: WebhookEndpointWhereInput | WebhookEndpointWhereInput[]
    OR?: WebhookEndpointWhereInput[]
    NOT?: WebhookEndpointWhereInput | WebhookEndpointWhereInput[]
    id?: StringFilter<"WebhookEndpoint"> | string
    name?: StringFilter<"WebhookEndpoint"> | string
    url?: StringFilter<"WebhookEndpoint"> | string
    method?: StringFilter<"WebhookEndpoint"> | string
    headers?: JsonNullableFilter<"WebhookEndpoint">
    events?: StringNullableListFilter<"WebhookEndpoint">
    isActive?: BoolFilter<"WebhookEndpoint"> | boolean
    secret?: StringNullableFilter<"WebhookEndpoint"> | string | null
    lastTriggered?: DateTimeNullableFilter<"WebhookEndpoint"> | Date | string | null
    successCount?: IntFilter<"WebhookEndpoint"> | number
    failureCount?: IntFilter<"WebhookEndpoint"> | number
    createdAt?: DateTimeFilter<"WebhookEndpoint"> | Date | string
    updatedAt?: DateTimeFilter<"WebhookEndpoint"> | Date | string
  }

  export type WebhookEndpointOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    method?: SortOrder
    headers?: SortOrderInput | SortOrder
    events?: SortOrder
    isActive?: SortOrder
    secret?: SortOrderInput | SortOrder
    lastTriggered?: SortOrderInput | SortOrder
    successCount?: SortOrder
    failureCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebhookEndpointWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WebhookEndpointWhereInput | WebhookEndpointWhereInput[]
    OR?: WebhookEndpointWhereInput[]
    NOT?: WebhookEndpointWhereInput | WebhookEndpointWhereInput[]
    name?: StringFilter<"WebhookEndpoint"> | string
    url?: StringFilter<"WebhookEndpoint"> | string
    method?: StringFilter<"WebhookEndpoint"> | string
    headers?: JsonNullableFilter<"WebhookEndpoint">
    events?: StringNullableListFilter<"WebhookEndpoint">
    isActive?: BoolFilter<"WebhookEndpoint"> | boolean
    secret?: StringNullableFilter<"WebhookEndpoint"> | string | null
    lastTriggered?: DateTimeNullableFilter<"WebhookEndpoint"> | Date | string | null
    successCount?: IntFilter<"WebhookEndpoint"> | number
    failureCount?: IntFilter<"WebhookEndpoint"> | number
    createdAt?: DateTimeFilter<"WebhookEndpoint"> | Date | string
    updatedAt?: DateTimeFilter<"WebhookEndpoint"> | Date | string
  }, "id">

  export type WebhookEndpointOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    method?: SortOrder
    headers?: SortOrderInput | SortOrder
    events?: SortOrder
    isActive?: SortOrder
    secret?: SortOrderInput | SortOrder
    lastTriggered?: SortOrderInput | SortOrder
    successCount?: SortOrder
    failureCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WebhookEndpointCountOrderByAggregateInput
    _avg?: WebhookEndpointAvgOrderByAggregateInput
    _max?: WebhookEndpointMaxOrderByAggregateInput
    _min?: WebhookEndpointMinOrderByAggregateInput
    _sum?: WebhookEndpointSumOrderByAggregateInput
  }

  export type WebhookEndpointScalarWhereWithAggregatesInput = {
    AND?: WebhookEndpointScalarWhereWithAggregatesInput | WebhookEndpointScalarWhereWithAggregatesInput[]
    OR?: WebhookEndpointScalarWhereWithAggregatesInput[]
    NOT?: WebhookEndpointScalarWhereWithAggregatesInput | WebhookEndpointScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WebhookEndpoint"> | string
    name?: StringWithAggregatesFilter<"WebhookEndpoint"> | string
    url?: StringWithAggregatesFilter<"WebhookEndpoint"> | string
    method?: StringWithAggregatesFilter<"WebhookEndpoint"> | string
    headers?: JsonNullableWithAggregatesFilter<"WebhookEndpoint">
    events?: StringNullableListFilter<"WebhookEndpoint">
    isActive?: BoolWithAggregatesFilter<"WebhookEndpoint"> | boolean
    secret?: StringNullableWithAggregatesFilter<"WebhookEndpoint"> | string | null
    lastTriggered?: DateTimeNullableWithAggregatesFilter<"WebhookEndpoint"> | Date | string | null
    successCount?: IntWithAggregatesFilter<"WebhookEndpoint"> | number
    failureCount?: IntWithAggregatesFilter<"WebhookEndpoint"> | number
    createdAt?: DateTimeWithAggregatesFilter<"WebhookEndpoint"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WebhookEndpoint"> | Date | string
  }

  export type APIManagementWhereInput = {
    AND?: APIManagementWhereInput | APIManagementWhereInput[]
    OR?: APIManagementWhereInput[]
    NOT?: APIManagementWhereInput | APIManagementWhereInput[]
    id?: StringFilter<"APIManagement"> | string
    name?: StringFilter<"APIManagement"> | string
    apiKey?: StringFilter<"APIManagement"> | string
    permissions?: StringNullableListFilter<"APIManagement">
    rateLimit?: IntNullableFilter<"APIManagement"> | number | null
    isActive?: BoolFilter<"APIManagement"> | boolean
    lastUsed?: DateTimeNullableFilter<"APIManagement"> | Date | string | null
    usageCount?: IntFilter<"APIManagement"> | number
    expiresAt?: DateTimeNullableFilter<"APIManagement"> | Date | string | null
    createdAt?: DateTimeFilter<"APIManagement"> | Date | string
    updatedAt?: DateTimeFilter<"APIManagement"> | Date | string
  }

  export type APIManagementOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    apiKey?: SortOrder
    permissions?: SortOrder
    rateLimit?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastUsed?: SortOrderInput | SortOrder
    usageCount?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type APIManagementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    apiKey?: string
    AND?: APIManagementWhereInput | APIManagementWhereInput[]
    OR?: APIManagementWhereInput[]
    NOT?: APIManagementWhereInput | APIManagementWhereInput[]
    name?: StringFilter<"APIManagement"> | string
    permissions?: StringNullableListFilter<"APIManagement">
    rateLimit?: IntNullableFilter<"APIManagement"> | number | null
    isActive?: BoolFilter<"APIManagement"> | boolean
    lastUsed?: DateTimeNullableFilter<"APIManagement"> | Date | string | null
    usageCount?: IntFilter<"APIManagement"> | number
    expiresAt?: DateTimeNullableFilter<"APIManagement"> | Date | string | null
    createdAt?: DateTimeFilter<"APIManagement"> | Date | string
    updatedAt?: DateTimeFilter<"APIManagement"> | Date | string
  }, "id" | "apiKey">

  export type APIManagementOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    apiKey?: SortOrder
    permissions?: SortOrder
    rateLimit?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastUsed?: SortOrderInput | SortOrder
    usageCount?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: APIManagementCountOrderByAggregateInput
    _avg?: APIManagementAvgOrderByAggregateInput
    _max?: APIManagementMaxOrderByAggregateInput
    _min?: APIManagementMinOrderByAggregateInput
    _sum?: APIManagementSumOrderByAggregateInput
  }

  export type APIManagementScalarWhereWithAggregatesInput = {
    AND?: APIManagementScalarWhereWithAggregatesInput | APIManagementScalarWhereWithAggregatesInput[]
    OR?: APIManagementScalarWhereWithAggregatesInput[]
    NOT?: APIManagementScalarWhereWithAggregatesInput | APIManagementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"APIManagement"> | string
    name?: StringWithAggregatesFilter<"APIManagement"> | string
    apiKey?: StringWithAggregatesFilter<"APIManagement"> | string
    permissions?: StringNullableListFilter<"APIManagement">
    rateLimit?: IntNullableWithAggregatesFilter<"APIManagement"> | number | null
    isActive?: BoolWithAggregatesFilter<"APIManagement"> | boolean
    lastUsed?: DateTimeNullableWithAggregatesFilter<"APIManagement"> | Date | string | null
    usageCount?: IntWithAggregatesFilter<"APIManagement"> | number
    expiresAt?: DateTimeNullableWithAggregatesFilter<"APIManagement"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"APIManagement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"APIManagement"> | Date | string
  }

  export type ThreatDetectionWhereInput = {
    AND?: ThreatDetectionWhereInput | ThreatDetectionWhereInput[]
    OR?: ThreatDetectionWhereInput[]
    NOT?: ThreatDetectionWhereInput | ThreatDetectionWhereInput[]
    id?: StringFilter<"ThreatDetection"> | string
    threatType?: StringFilter<"ThreatDetection"> | string
    severity?: StringFilter<"ThreatDetection"> | string
    status?: StringFilter<"ThreatDetection"> | string
    description?: StringFilter<"ThreatDetection"> | string
    source?: StringNullableFilter<"ThreatDetection"> | string | null
    evidence?: JsonNullableFilter<"ThreatDetection">
    assignedTo?: StringNullableFilter<"ThreatDetection"> | string | null
    resolvedAt?: DateTimeNullableFilter<"ThreatDetection"> | Date | string | null
    notes?: StringNullableFilter<"ThreatDetection"> | string | null
    createdAt?: DateTimeFilter<"ThreatDetection"> | Date | string
    updatedAt?: DateTimeFilter<"ThreatDetection"> | Date | string
  }

  export type ThreatDetectionOrderByWithRelationInput = {
    id?: SortOrder
    threatType?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    description?: SortOrder
    source?: SortOrderInput | SortOrder
    evidence?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ThreatDetectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ThreatDetectionWhereInput | ThreatDetectionWhereInput[]
    OR?: ThreatDetectionWhereInput[]
    NOT?: ThreatDetectionWhereInput | ThreatDetectionWhereInput[]
    threatType?: StringFilter<"ThreatDetection"> | string
    severity?: StringFilter<"ThreatDetection"> | string
    status?: StringFilter<"ThreatDetection"> | string
    description?: StringFilter<"ThreatDetection"> | string
    source?: StringNullableFilter<"ThreatDetection"> | string | null
    evidence?: JsonNullableFilter<"ThreatDetection">
    assignedTo?: StringNullableFilter<"ThreatDetection"> | string | null
    resolvedAt?: DateTimeNullableFilter<"ThreatDetection"> | Date | string | null
    notes?: StringNullableFilter<"ThreatDetection"> | string | null
    createdAt?: DateTimeFilter<"ThreatDetection"> | Date | string
    updatedAt?: DateTimeFilter<"ThreatDetection"> | Date | string
  }, "id">

  export type ThreatDetectionOrderByWithAggregationInput = {
    id?: SortOrder
    threatType?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    description?: SortOrder
    source?: SortOrderInput | SortOrder
    evidence?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ThreatDetectionCountOrderByAggregateInput
    _max?: ThreatDetectionMaxOrderByAggregateInput
    _min?: ThreatDetectionMinOrderByAggregateInput
  }

  export type ThreatDetectionScalarWhereWithAggregatesInput = {
    AND?: ThreatDetectionScalarWhereWithAggregatesInput | ThreatDetectionScalarWhereWithAggregatesInput[]
    OR?: ThreatDetectionScalarWhereWithAggregatesInput[]
    NOT?: ThreatDetectionScalarWhereWithAggregatesInput | ThreatDetectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ThreatDetection"> | string
    threatType?: StringWithAggregatesFilter<"ThreatDetection"> | string
    severity?: StringWithAggregatesFilter<"ThreatDetection"> | string
    status?: StringWithAggregatesFilter<"ThreatDetection"> | string
    description?: StringWithAggregatesFilter<"ThreatDetection"> | string
    source?: StringNullableWithAggregatesFilter<"ThreatDetection"> | string | null
    evidence?: JsonNullableWithAggregatesFilter<"ThreatDetection">
    assignedTo?: StringNullableWithAggregatesFilter<"ThreatDetection"> | string | null
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"ThreatDetection"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"ThreatDetection"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ThreatDetection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ThreatDetection"> | Date | string
  }

  export type AnomalyDetectionWhereInput = {
    AND?: AnomalyDetectionWhereInput | AnomalyDetectionWhereInput[]
    OR?: AnomalyDetectionWhereInput[]
    NOT?: AnomalyDetectionWhereInput | AnomalyDetectionWhereInput[]
    id?: StringFilter<"AnomalyDetection"> | string
    anomalyType?: StringFilter<"AnomalyDetection"> | string
    confidence?: FloatFilter<"AnomalyDetection"> | number
    status?: StringFilter<"AnomalyDetection"> | string
    description?: StringFilter<"AnomalyDetection"> | string
    data?: JsonNullableFilter<"AnomalyDetection">
    severity?: StringFilter<"AnomalyDetection"> | string
    resolvedAt?: DateTimeNullableFilter<"AnomalyDetection"> | Date | string | null
    notes?: StringNullableFilter<"AnomalyDetection"> | string | null
    createdAt?: DateTimeFilter<"AnomalyDetection"> | Date | string
    updatedAt?: DateTimeFilter<"AnomalyDetection"> | Date | string
  }

  export type AnomalyDetectionOrderByWithRelationInput = {
    id?: SortOrder
    anomalyType?: SortOrder
    confidence?: SortOrder
    status?: SortOrder
    description?: SortOrder
    data?: SortOrderInput | SortOrder
    severity?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnomalyDetectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnomalyDetectionWhereInput | AnomalyDetectionWhereInput[]
    OR?: AnomalyDetectionWhereInput[]
    NOT?: AnomalyDetectionWhereInput | AnomalyDetectionWhereInput[]
    anomalyType?: StringFilter<"AnomalyDetection"> | string
    confidence?: FloatFilter<"AnomalyDetection"> | number
    status?: StringFilter<"AnomalyDetection"> | string
    description?: StringFilter<"AnomalyDetection"> | string
    data?: JsonNullableFilter<"AnomalyDetection">
    severity?: StringFilter<"AnomalyDetection"> | string
    resolvedAt?: DateTimeNullableFilter<"AnomalyDetection"> | Date | string | null
    notes?: StringNullableFilter<"AnomalyDetection"> | string | null
    createdAt?: DateTimeFilter<"AnomalyDetection"> | Date | string
    updatedAt?: DateTimeFilter<"AnomalyDetection"> | Date | string
  }, "id">

  export type AnomalyDetectionOrderByWithAggregationInput = {
    id?: SortOrder
    anomalyType?: SortOrder
    confidence?: SortOrder
    status?: SortOrder
    description?: SortOrder
    data?: SortOrderInput | SortOrder
    severity?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AnomalyDetectionCountOrderByAggregateInput
    _avg?: AnomalyDetectionAvgOrderByAggregateInput
    _max?: AnomalyDetectionMaxOrderByAggregateInput
    _min?: AnomalyDetectionMinOrderByAggregateInput
    _sum?: AnomalyDetectionSumOrderByAggregateInput
  }

  export type AnomalyDetectionScalarWhereWithAggregatesInput = {
    AND?: AnomalyDetectionScalarWhereWithAggregatesInput | AnomalyDetectionScalarWhereWithAggregatesInput[]
    OR?: AnomalyDetectionScalarWhereWithAggregatesInput[]
    NOT?: AnomalyDetectionScalarWhereWithAggregatesInput | AnomalyDetectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AnomalyDetection"> | string
    anomalyType?: StringWithAggregatesFilter<"AnomalyDetection"> | string
    confidence?: FloatWithAggregatesFilter<"AnomalyDetection"> | number
    status?: StringWithAggregatesFilter<"AnomalyDetection"> | string
    description?: StringWithAggregatesFilter<"AnomalyDetection"> | string
    data?: JsonNullableWithAggregatesFilter<"AnomalyDetection">
    severity?: StringWithAggregatesFilter<"AnomalyDetection"> | string
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"AnomalyDetection"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"AnomalyDetection"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AnomalyDetection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AnomalyDetection"> | Date | string
  }

  export type ComplianceReportWhereInput = {
    AND?: ComplianceReportWhereInput | ComplianceReportWhereInput[]
    OR?: ComplianceReportWhereInput[]
    NOT?: ComplianceReportWhereInput | ComplianceReportWhereInput[]
    id?: StringFilter<"ComplianceReport"> | string
    reportType?: StringFilter<"ComplianceReport"> | string
    status?: StringFilter<"ComplianceReport"> | string
    period?: StringFilter<"ComplianceReport"> | string
    findings?: JsonNullableFilter<"ComplianceReport">
    recommendations?: StringNullableFilter<"ComplianceReport"> | string | null
    submittedBy?: StringNullableFilter<"ComplianceReport"> | string | null
    submittedAt?: DateTimeNullableFilter<"ComplianceReport"> | Date | string | null
    approvedBy?: StringNullableFilter<"ComplianceReport"> | string | null
    approvedAt?: DateTimeNullableFilter<"ComplianceReport"> | Date | string | null
    createdAt?: DateTimeFilter<"ComplianceReport"> | Date | string
    updatedAt?: DateTimeFilter<"ComplianceReport"> | Date | string
  }

  export type ComplianceReportOrderByWithRelationInput = {
    id?: SortOrder
    reportType?: SortOrder
    status?: SortOrder
    period?: SortOrder
    findings?: SortOrderInput | SortOrder
    recommendations?: SortOrderInput | SortOrder
    submittedBy?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComplianceReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ComplianceReportWhereInput | ComplianceReportWhereInput[]
    OR?: ComplianceReportWhereInput[]
    NOT?: ComplianceReportWhereInput | ComplianceReportWhereInput[]
    reportType?: StringFilter<"ComplianceReport"> | string
    status?: StringFilter<"ComplianceReport"> | string
    period?: StringFilter<"ComplianceReport"> | string
    findings?: JsonNullableFilter<"ComplianceReport">
    recommendations?: StringNullableFilter<"ComplianceReport"> | string | null
    submittedBy?: StringNullableFilter<"ComplianceReport"> | string | null
    submittedAt?: DateTimeNullableFilter<"ComplianceReport"> | Date | string | null
    approvedBy?: StringNullableFilter<"ComplianceReport"> | string | null
    approvedAt?: DateTimeNullableFilter<"ComplianceReport"> | Date | string | null
    createdAt?: DateTimeFilter<"ComplianceReport"> | Date | string
    updatedAt?: DateTimeFilter<"ComplianceReport"> | Date | string
  }, "id">

  export type ComplianceReportOrderByWithAggregationInput = {
    id?: SortOrder
    reportType?: SortOrder
    status?: SortOrder
    period?: SortOrder
    findings?: SortOrderInput | SortOrder
    recommendations?: SortOrderInput | SortOrder
    submittedBy?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ComplianceReportCountOrderByAggregateInput
    _max?: ComplianceReportMaxOrderByAggregateInput
    _min?: ComplianceReportMinOrderByAggregateInput
  }

  export type ComplianceReportScalarWhereWithAggregatesInput = {
    AND?: ComplianceReportScalarWhereWithAggregatesInput | ComplianceReportScalarWhereWithAggregatesInput[]
    OR?: ComplianceReportScalarWhereWithAggregatesInput[]
    NOT?: ComplianceReportScalarWhereWithAggregatesInput | ComplianceReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ComplianceReport"> | string
    reportType?: StringWithAggregatesFilter<"ComplianceReport"> | string
    status?: StringWithAggregatesFilter<"ComplianceReport"> | string
    period?: StringWithAggregatesFilter<"ComplianceReport"> | string
    findings?: JsonNullableWithAggregatesFilter<"ComplianceReport">
    recommendations?: StringNullableWithAggregatesFilter<"ComplianceReport"> | string | null
    submittedBy?: StringNullableWithAggregatesFilter<"ComplianceReport"> | string | null
    submittedAt?: DateTimeNullableWithAggregatesFilter<"ComplianceReport"> | Date | string | null
    approvedBy?: StringNullableWithAggregatesFilter<"ComplianceReport"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"ComplianceReport"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ComplianceReport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ComplianceReport"> | Date | string
  }

  export type SecurityWorkflowWhereInput = {
    AND?: SecurityWorkflowWhereInput | SecurityWorkflowWhereInput[]
    OR?: SecurityWorkflowWhereInput[]
    NOT?: SecurityWorkflowWhereInput | SecurityWorkflowWhereInput[]
    id?: StringFilter<"SecurityWorkflow"> | string
    name?: StringFilter<"SecurityWorkflow"> | string
    type?: StringFilter<"SecurityWorkflow"> | string
    status?: StringFilter<"SecurityWorkflow"> | string
    priority?: StringFilter<"SecurityWorkflow"> | string
    assignedTo?: StringNullableFilter<"SecurityWorkflow"> | string | null
    dueDate?: DateTimeNullableFilter<"SecurityWorkflow"> | Date | string | null
    steps?: JsonNullableFilter<"SecurityWorkflow">
    completedAt?: DateTimeNullableFilter<"SecurityWorkflow"> | Date | string | null
    createdAt?: DateTimeFilter<"SecurityWorkflow"> | Date | string
    updatedAt?: DateTimeFilter<"SecurityWorkflow"> | Date | string
  }

  export type SecurityWorkflowOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    assignedTo?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    steps?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SecurityWorkflowWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SecurityWorkflowWhereInput | SecurityWorkflowWhereInput[]
    OR?: SecurityWorkflowWhereInput[]
    NOT?: SecurityWorkflowWhereInput | SecurityWorkflowWhereInput[]
    name?: StringFilter<"SecurityWorkflow"> | string
    type?: StringFilter<"SecurityWorkflow"> | string
    status?: StringFilter<"SecurityWorkflow"> | string
    priority?: StringFilter<"SecurityWorkflow"> | string
    assignedTo?: StringNullableFilter<"SecurityWorkflow"> | string | null
    dueDate?: DateTimeNullableFilter<"SecurityWorkflow"> | Date | string | null
    steps?: JsonNullableFilter<"SecurityWorkflow">
    completedAt?: DateTimeNullableFilter<"SecurityWorkflow"> | Date | string | null
    createdAt?: DateTimeFilter<"SecurityWorkflow"> | Date | string
    updatedAt?: DateTimeFilter<"SecurityWorkflow"> | Date | string
  }, "id">

  export type SecurityWorkflowOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    assignedTo?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    steps?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SecurityWorkflowCountOrderByAggregateInput
    _max?: SecurityWorkflowMaxOrderByAggregateInput
    _min?: SecurityWorkflowMinOrderByAggregateInput
  }

  export type SecurityWorkflowScalarWhereWithAggregatesInput = {
    AND?: SecurityWorkflowScalarWhereWithAggregatesInput | SecurityWorkflowScalarWhereWithAggregatesInput[]
    OR?: SecurityWorkflowScalarWhereWithAggregatesInput[]
    NOT?: SecurityWorkflowScalarWhereWithAggregatesInput | SecurityWorkflowScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SecurityWorkflow"> | string
    name?: StringWithAggregatesFilter<"SecurityWorkflow"> | string
    type?: StringWithAggregatesFilter<"SecurityWorkflow"> | string
    status?: StringWithAggregatesFilter<"SecurityWorkflow"> | string
    priority?: StringWithAggregatesFilter<"SecurityWorkflow"> | string
    assignedTo?: StringNullableWithAggregatesFilter<"SecurityWorkflow"> | string | null
    dueDate?: DateTimeNullableWithAggregatesFilter<"SecurityWorkflow"> | Date | string | null
    steps?: JsonNullableWithAggregatesFilter<"SecurityWorkflow">
    completedAt?: DateTimeNullableWithAggregatesFilter<"SecurityWorkflow"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SecurityWorkflow"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SecurityWorkflow"> | Date | string
  }

  export type SecurityIntegrationWhereInput = {
    AND?: SecurityIntegrationWhereInput | SecurityIntegrationWhereInput[]
    OR?: SecurityIntegrationWhereInput[]
    NOT?: SecurityIntegrationWhereInput | SecurityIntegrationWhereInput[]
    id?: StringFilter<"SecurityIntegration"> | string
    name?: StringFilter<"SecurityIntegration"> | string
    type?: StringFilter<"SecurityIntegration"> | string
    status?: StringFilter<"SecurityIntegration"> | string
    endpoint?: StringNullableFilter<"SecurityIntegration"> | string | null
    apiKey?: StringNullableFilter<"SecurityIntegration"> | string | null
    config?: JsonNullableFilter<"SecurityIntegration">
    lastSync?: DateTimeNullableFilter<"SecurityIntegration"> | Date | string | null
    healthScore?: IntFilter<"SecurityIntegration"> | number
    createdAt?: DateTimeFilter<"SecurityIntegration"> | Date | string
    updatedAt?: DateTimeFilter<"SecurityIntegration"> | Date | string
  }

  export type SecurityIntegrationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    endpoint?: SortOrderInput | SortOrder
    apiKey?: SortOrderInput | SortOrder
    config?: SortOrderInput | SortOrder
    lastSync?: SortOrderInput | SortOrder
    healthScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SecurityIntegrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SecurityIntegrationWhereInput | SecurityIntegrationWhereInput[]
    OR?: SecurityIntegrationWhereInput[]
    NOT?: SecurityIntegrationWhereInput | SecurityIntegrationWhereInput[]
    name?: StringFilter<"SecurityIntegration"> | string
    type?: StringFilter<"SecurityIntegration"> | string
    status?: StringFilter<"SecurityIntegration"> | string
    endpoint?: StringNullableFilter<"SecurityIntegration"> | string | null
    apiKey?: StringNullableFilter<"SecurityIntegration"> | string | null
    config?: JsonNullableFilter<"SecurityIntegration">
    lastSync?: DateTimeNullableFilter<"SecurityIntegration"> | Date | string | null
    healthScore?: IntFilter<"SecurityIntegration"> | number
    createdAt?: DateTimeFilter<"SecurityIntegration"> | Date | string
    updatedAt?: DateTimeFilter<"SecurityIntegration"> | Date | string
  }, "id">

  export type SecurityIntegrationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    endpoint?: SortOrderInput | SortOrder
    apiKey?: SortOrderInput | SortOrder
    config?: SortOrderInput | SortOrder
    lastSync?: SortOrderInput | SortOrder
    healthScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SecurityIntegrationCountOrderByAggregateInput
    _avg?: SecurityIntegrationAvgOrderByAggregateInput
    _max?: SecurityIntegrationMaxOrderByAggregateInput
    _min?: SecurityIntegrationMinOrderByAggregateInput
    _sum?: SecurityIntegrationSumOrderByAggregateInput
  }

  export type SecurityIntegrationScalarWhereWithAggregatesInput = {
    AND?: SecurityIntegrationScalarWhereWithAggregatesInput | SecurityIntegrationScalarWhereWithAggregatesInput[]
    OR?: SecurityIntegrationScalarWhereWithAggregatesInput[]
    NOT?: SecurityIntegrationScalarWhereWithAggregatesInput | SecurityIntegrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SecurityIntegration"> | string
    name?: StringWithAggregatesFilter<"SecurityIntegration"> | string
    type?: StringWithAggregatesFilter<"SecurityIntegration"> | string
    status?: StringWithAggregatesFilter<"SecurityIntegration"> | string
    endpoint?: StringNullableWithAggregatesFilter<"SecurityIntegration"> | string | null
    apiKey?: StringNullableWithAggregatesFilter<"SecurityIntegration"> | string | null
    config?: JsonNullableWithAggregatesFilter<"SecurityIntegration">
    lastSync?: DateTimeNullableWithAggregatesFilter<"SecurityIntegration"> | Date | string | null
    healthScore?: IntWithAggregatesFilter<"SecurityIntegration"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SecurityIntegration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SecurityIntegration"> | Date | string
  }

  export type AdministrativeProfileWhereInput = {
    AND?: AdministrativeProfileWhereInput | AdministrativeProfileWhereInput[]
    OR?: AdministrativeProfileWhereInput[]
    NOT?: AdministrativeProfileWhereInput | AdministrativeProfileWhereInput[]
    id?: StringFilter<"AdministrativeProfile"> | string
    userId?: IntFilter<"AdministrativeProfile"> | number
    adminLevel?: StringFilter<"AdministrativeProfile"> | string
    departments?: StringNullableListFilter<"AdministrativeProfile">
    responsibilities?: StringNullableListFilter<"AdministrativeProfile">
    criticalPermissions?: StringNullableListFilter<"AdministrativeProfile">
    emergencyContact?: StringNullableFilter<"AdministrativeProfile"> | string | null
    createdAt?: DateTimeFilter<"AdministrativeProfile"> | Date | string
    updatedAt?: DateTimeFilter<"AdministrativeProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AdministrativeProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    adminLevel?: SortOrder
    departments?: SortOrder
    responsibilities?: SortOrder
    criticalPermissions?: SortOrder
    emergencyContact?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AdministrativeProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: number
    AND?: AdministrativeProfileWhereInput | AdministrativeProfileWhereInput[]
    OR?: AdministrativeProfileWhereInput[]
    NOT?: AdministrativeProfileWhereInput | AdministrativeProfileWhereInput[]
    adminLevel?: StringFilter<"AdministrativeProfile"> | string
    departments?: StringNullableListFilter<"AdministrativeProfile">
    responsibilities?: StringNullableListFilter<"AdministrativeProfile">
    criticalPermissions?: StringNullableListFilter<"AdministrativeProfile">
    emergencyContact?: StringNullableFilter<"AdministrativeProfile"> | string | null
    createdAt?: DateTimeFilter<"AdministrativeProfile"> | Date | string
    updatedAt?: DateTimeFilter<"AdministrativeProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type AdministrativeProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    adminLevel?: SortOrder
    departments?: SortOrder
    responsibilities?: SortOrder
    criticalPermissions?: SortOrder
    emergencyContact?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdministrativeProfileCountOrderByAggregateInput
    _avg?: AdministrativeProfileAvgOrderByAggregateInput
    _max?: AdministrativeProfileMaxOrderByAggregateInput
    _min?: AdministrativeProfileMinOrderByAggregateInput
    _sum?: AdministrativeProfileSumOrderByAggregateInput
  }

  export type AdministrativeProfileScalarWhereWithAggregatesInput = {
    AND?: AdministrativeProfileScalarWhereWithAggregatesInput | AdministrativeProfileScalarWhereWithAggregatesInput[]
    OR?: AdministrativeProfileScalarWhereWithAggregatesInput[]
    NOT?: AdministrativeProfileScalarWhereWithAggregatesInput | AdministrativeProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdministrativeProfile"> | string
    userId?: IntWithAggregatesFilter<"AdministrativeProfile"> | number
    adminLevel?: StringWithAggregatesFilter<"AdministrativeProfile"> | string
    departments?: StringNullableListFilter<"AdministrativeProfile">
    responsibilities?: StringNullableListFilter<"AdministrativeProfile">
    criticalPermissions?: StringNullableListFilter<"AdministrativeProfile">
    emergencyContact?: StringNullableWithAggregatesFilter<"AdministrativeProfile"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AdministrativeProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdministrativeProfile"> | Date | string
  }

  export type CustomRoleWhereInput = {
    AND?: CustomRoleWhereInput | CustomRoleWhereInput[]
    OR?: CustomRoleWhereInput[]
    NOT?: CustomRoleWhereInput | CustomRoleWhereInput[]
    id?: StringFilter<"CustomRole"> | string
    name?: StringFilter<"CustomRole"> | string
    description?: StringNullableFilter<"CustomRole"> | string | null
    permissions?: StringNullableListFilter<"CustomRole">
    parentRole?: StringNullableFilter<"CustomRole"> | string | null
    isActive?: BoolFilter<"CustomRole"> | boolean
    createdAt?: DateTimeFilter<"CustomRole"> | Date | string
    updatedAt?: DateTimeFilter<"CustomRole"> | Date | string
    hierarchy?: XOR<RoleHierarchyNullableScalarRelationFilter, RoleHierarchyWhereInput> | null
  }

  export type CustomRoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    permissions?: SortOrder
    parentRole?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hierarchy?: RoleHierarchyOrderByWithRelationInput
  }

  export type CustomRoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: CustomRoleWhereInput | CustomRoleWhereInput[]
    OR?: CustomRoleWhereInput[]
    NOT?: CustomRoleWhereInput | CustomRoleWhereInput[]
    description?: StringNullableFilter<"CustomRole"> | string | null
    permissions?: StringNullableListFilter<"CustomRole">
    parentRole?: StringNullableFilter<"CustomRole"> | string | null
    isActive?: BoolFilter<"CustomRole"> | boolean
    createdAt?: DateTimeFilter<"CustomRole"> | Date | string
    updatedAt?: DateTimeFilter<"CustomRole"> | Date | string
    hierarchy?: XOR<RoleHierarchyNullableScalarRelationFilter, RoleHierarchyWhereInput> | null
  }, "id" | "name">

  export type CustomRoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    permissions?: SortOrder
    parentRole?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomRoleCountOrderByAggregateInput
    _max?: CustomRoleMaxOrderByAggregateInput
    _min?: CustomRoleMinOrderByAggregateInput
  }

  export type CustomRoleScalarWhereWithAggregatesInput = {
    AND?: CustomRoleScalarWhereWithAggregatesInput | CustomRoleScalarWhereWithAggregatesInput[]
    OR?: CustomRoleScalarWhereWithAggregatesInput[]
    NOT?: CustomRoleScalarWhereWithAggregatesInput | CustomRoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomRole"> | string
    name?: StringWithAggregatesFilter<"CustomRole"> | string
    description?: StringNullableWithAggregatesFilter<"CustomRole"> | string | null
    permissions?: StringNullableListFilter<"CustomRole">
    parentRole?: StringNullableWithAggregatesFilter<"CustomRole"> | string | null
    isActive?: BoolWithAggregatesFilter<"CustomRole"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CustomRole"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomRole"> | Date | string
  }

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    id?: StringFilter<"Permission"> | string
    name?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    category?: StringFilter<"Permission"> | string
    action?: StringFilter<"Permission"> | string
    resource?: StringFilter<"Permission"> | string
    isActive?: BoolFilter<"Permission"> | boolean
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    updatedAt?: DateTimeFilter<"Permission"> | Date | string
  }

  export type PermissionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    description?: StringNullableFilter<"Permission"> | string | null
    category?: StringFilter<"Permission"> | string
    action?: StringFilter<"Permission"> | string
    resource?: StringFilter<"Permission"> | string
    isActive?: BoolFilter<"Permission"> | boolean
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    updatedAt?: DateTimeFilter<"Permission"> | Date | string
  }, "id" | "name">

  export type PermissionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    OR?: PermissionScalarWhereWithAggregatesInput[]
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Permission"> | string
    name?: StringWithAggregatesFilter<"Permission"> | string
    description?: StringNullableWithAggregatesFilter<"Permission"> | string | null
    category?: StringWithAggregatesFilter<"Permission"> | string
    action?: StringWithAggregatesFilter<"Permission"> | string
    resource?: StringWithAggregatesFilter<"Permission"> | string
    isActive?: BoolWithAggregatesFilter<"Permission"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
  }

  export type RoleHierarchyWhereInput = {
    AND?: RoleHierarchyWhereInput | RoleHierarchyWhereInput[]
    OR?: RoleHierarchyWhereInput[]
    NOT?: RoleHierarchyWhereInput | RoleHierarchyWhereInput[]
    id?: StringFilter<"RoleHierarchy"> | string
    roleId?: StringFilter<"RoleHierarchy"> | string
    parentId?: StringNullableFilter<"RoleHierarchy"> | string | null
    level?: IntFilter<"RoleHierarchy"> | number
    createdAt?: DateTimeFilter<"RoleHierarchy"> | Date | string
    updatedAt?: DateTimeFilter<"RoleHierarchy"> | Date | string
    parent?: XOR<RoleHierarchyNullableScalarRelationFilter, RoleHierarchyWhereInput> | null
    children?: RoleHierarchyListRelationFilter
    role?: XOR<CustomRoleScalarRelationFilter, CustomRoleWhereInput>
  }

  export type RoleHierarchyOrderByWithRelationInput = {
    id?: SortOrder
    roleId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    level?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parent?: RoleHierarchyOrderByWithRelationInput
    children?: RoleHierarchyOrderByRelationAggregateInput
    role?: CustomRoleOrderByWithRelationInput
  }

  export type RoleHierarchyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    roleId?: string
    AND?: RoleHierarchyWhereInput | RoleHierarchyWhereInput[]
    OR?: RoleHierarchyWhereInput[]
    NOT?: RoleHierarchyWhereInput | RoleHierarchyWhereInput[]
    parentId?: StringNullableFilter<"RoleHierarchy"> | string | null
    level?: IntFilter<"RoleHierarchy"> | number
    createdAt?: DateTimeFilter<"RoleHierarchy"> | Date | string
    updatedAt?: DateTimeFilter<"RoleHierarchy"> | Date | string
    parent?: XOR<RoleHierarchyNullableScalarRelationFilter, RoleHierarchyWhereInput> | null
    children?: RoleHierarchyListRelationFilter
    role?: XOR<CustomRoleScalarRelationFilter, CustomRoleWhereInput>
  }, "id" | "roleId">

  export type RoleHierarchyOrderByWithAggregationInput = {
    id?: SortOrder
    roleId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    level?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleHierarchyCountOrderByAggregateInput
    _avg?: RoleHierarchyAvgOrderByAggregateInput
    _max?: RoleHierarchyMaxOrderByAggregateInput
    _min?: RoleHierarchyMinOrderByAggregateInput
    _sum?: RoleHierarchySumOrderByAggregateInput
  }

  export type RoleHierarchyScalarWhereWithAggregatesInput = {
    AND?: RoleHierarchyScalarWhereWithAggregatesInput | RoleHierarchyScalarWhereWithAggregatesInput[]
    OR?: RoleHierarchyScalarWhereWithAggregatesInput[]
    NOT?: RoleHierarchyScalarWhereWithAggregatesInput | RoleHierarchyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RoleHierarchy"> | string
    roleId?: StringWithAggregatesFilter<"RoleHierarchy"> | string
    parentId?: StringNullableWithAggregatesFilter<"RoleHierarchy"> | string | null
    level?: IntWithAggregatesFilter<"RoleHierarchy"> | number
    createdAt?: DateTimeWithAggregatesFilter<"RoleHierarchy"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RoleHierarchy"> | Date | string
  }

  export type PermissionAuditWhereInput = {
    AND?: PermissionAuditWhereInput | PermissionAuditWhereInput[]
    OR?: PermissionAuditWhereInput[]
    NOT?: PermissionAuditWhereInput | PermissionAuditWhereInput[]
    id?: StringFilter<"PermissionAudit"> | string
    userId?: IntFilter<"PermissionAudit"> | number
    action?: StringFilter<"PermissionAudit"> | string
    permissionId?: StringFilter<"PermissionAudit"> | string
    oldValue?: StringNullableFilter<"PermissionAudit"> | string | null
    newValue?: StringFilter<"PermissionAudit"> | string
    reason?: StringNullableFilter<"PermissionAudit"> | string | null
    performedBy?: StringNullableFilter<"PermissionAudit"> | string | null
    createdAt?: DateTimeFilter<"PermissionAudit"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PermissionAuditOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    permissionId?: SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrder
    reason?: SortOrderInput | SortOrder
    performedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PermissionAuditWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PermissionAuditWhereInput | PermissionAuditWhereInput[]
    OR?: PermissionAuditWhereInput[]
    NOT?: PermissionAuditWhereInput | PermissionAuditWhereInput[]
    userId?: IntFilter<"PermissionAudit"> | number
    action?: StringFilter<"PermissionAudit"> | string
    permissionId?: StringFilter<"PermissionAudit"> | string
    oldValue?: StringNullableFilter<"PermissionAudit"> | string | null
    newValue?: StringFilter<"PermissionAudit"> | string
    reason?: StringNullableFilter<"PermissionAudit"> | string | null
    performedBy?: StringNullableFilter<"PermissionAudit"> | string | null
    createdAt?: DateTimeFilter<"PermissionAudit"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type PermissionAuditOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    permissionId?: SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrder
    reason?: SortOrderInput | SortOrder
    performedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PermissionAuditCountOrderByAggregateInput
    _avg?: PermissionAuditAvgOrderByAggregateInput
    _max?: PermissionAuditMaxOrderByAggregateInput
    _min?: PermissionAuditMinOrderByAggregateInput
    _sum?: PermissionAuditSumOrderByAggregateInput
  }

  export type PermissionAuditScalarWhereWithAggregatesInput = {
    AND?: PermissionAuditScalarWhereWithAggregatesInput | PermissionAuditScalarWhereWithAggregatesInput[]
    OR?: PermissionAuditScalarWhereWithAggregatesInput[]
    NOT?: PermissionAuditScalarWhereWithAggregatesInput | PermissionAuditScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PermissionAudit"> | string
    userId?: IntWithAggregatesFilter<"PermissionAudit"> | number
    action?: StringWithAggregatesFilter<"PermissionAudit"> | string
    permissionId?: StringWithAggregatesFilter<"PermissionAudit"> | string
    oldValue?: StringNullableWithAggregatesFilter<"PermissionAudit"> | string | null
    newValue?: StringWithAggregatesFilter<"PermissionAudit"> | string
    reason?: StringNullableWithAggregatesFilter<"PermissionAudit"> | string | null
    performedBy?: StringNullableWithAggregatesFilter<"PermissionAudit"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PermissionAudit"> | Date | string
  }

  export type UserCreateInput = {
    name: string
    username?: string | null
    email: string
    phone_number?: string | null
    password: string
    role?: string
    profile_picture?: string | null
    tokenVersion?: number
    created_at?: Date | string
    updated_at?: Date | string
    resetToken?: string | null
    resetTokenExp?: Date | string | null
    bio?: string | null
    dateOfBirth?: Date | string | null
    department?: string | null
    email_verified?: boolean
    gender?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    lockedUntil?: Date | string | null
    loginAttempts?: number
    position?: string | null
    admin_profile?: AdministrativeProfileCreateNestedOneWithoutUserInput
    permission_audits?: PermissionAuditCreateNestedManyWithoutUserInput
    access_logs?: UserAccessLogCreateNestedManyWithoutUserInput
    address?: UserAddressCreateNestedOneWithoutUserInput
    emergency_contact?: UserEmergencyContactCreateNestedOneWithoutUserInput
    ip_restrictions?: UserIPRestrictionCreateNestedManyWithoutUserInput
    notification_settings?: UserNotificationSettingsCreateNestedOneWithoutUserInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    privacy_settings?: UserPrivacySettingsCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    social_media?: UserSocialMediaCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    name: string
    username?: string | null
    email: string
    phone_number?: string | null
    password: string
    role?: string
    profile_picture?: string | null
    tokenVersion?: number
    created_at?: Date | string
    updated_at?: Date | string
    resetToken?: string | null
    resetTokenExp?: Date | string | null
    bio?: string | null
    dateOfBirth?: Date | string | null
    department?: string | null
    email_verified?: boolean
    gender?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    lockedUntil?: Date | string | null
    loginAttempts?: number
    position?: string | null
    admin_profile?: AdministrativeProfileUncheckedCreateNestedOneWithoutUserInput
    permission_audits?: PermissionAuditUncheckedCreateNestedManyWithoutUserInput
    access_logs?: UserAccessLogUncheckedCreateNestedManyWithoutUserInput
    address?: UserAddressUncheckedCreateNestedOneWithoutUserInput
    emergency_contact?: UserEmergencyContactUncheckedCreateNestedOneWithoutUserInput
    ip_restrictions?: UserIPRestrictionUncheckedCreateNestedManyWithoutUserInput
    notification_settings?: UserNotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    privacy_settings?: UserPrivacySettingsUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    social_media?: UserSocialMediaUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    position?: NullableStringFieldUpdateOperationsInput | string | null
    admin_profile?: AdministrativeProfileUpdateOneWithoutUserNestedInput
    permission_audits?: PermissionAuditUpdateManyWithoutUserNestedInput
    access_logs?: UserAccessLogUpdateManyWithoutUserNestedInput
    address?: UserAddressUpdateOneWithoutUserNestedInput
    emergency_contact?: UserEmergencyContactUpdateOneWithoutUserNestedInput
    ip_restrictions?: UserIPRestrictionUpdateManyWithoutUserNestedInput
    notification_settings?: UserNotificationSettingsUpdateOneWithoutUserNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    privacy_settings?: UserPrivacySettingsUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    social_media?: UserSocialMediaUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    position?: NullableStringFieldUpdateOperationsInput | string | null
    admin_profile?: AdministrativeProfileUncheckedUpdateOneWithoutUserNestedInput
    permission_audits?: PermissionAuditUncheckedUpdateManyWithoutUserNestedInput
    access_logs?: UserAccessLogUncheckedUpdateManyWithoutUserNestedInput
    address?: UserAddressUncheckedUpdateOneWithoutUserNestedInput
    emergency_contact?: UserEmergencyContactUncheckedUpdateOneWithoutUserNestedInput
    ip_restrictions?: UserIPRestrictionUncheckedUpdateManyWithoutUserNestedInput
    notification_settings?: UserNotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    privacy_settings?: UserPrivacySettingsUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    social_media?: UserSocialMediaUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    name: string
    username?: string | null
    email: string
    phone_number?: string | null
    password: string
    role?: string
    profile_picture?: string | null
    tokenVersion?: number
    created_at?: Date | string
    updated_at?: Date | string
    resetToken?: string | null
    resetTokenExp?: Date | string | null
    bio?: string | null
    dateOfBirth?: Date | string | null
    department?: string | null
    email_verified?: boolean
    gender?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    lockedUntil?: Date | string | null
    loginAttempts?: number
    position?: string | null
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    position?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    position?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserSessionCreateInput = {
    id?: string
    token: string
    deviceType?: string | null
    deviceInfo?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    isActive?: boolean
    lastActivity?: Date | string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type UserSessionUncheckedCreateInput = {
    id?: string
    userId: number
    token: string
    deviceType?: string | null
    deviceInfo?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    isActive?: boolean
    lastActivity?: Date | string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type UserSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionCreateManyInput = {
    id?: string
    userId: number
    token: string
    deviceType?: string | null
    deviceInfo?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    isActive?: boolean
    lastActivity?: Date | string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAccessLogCreateInput = {
    id?: string
    action: string
    ipAddress?: string | null
    userAgent?: string | null
    success: boolean
    details?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAccess_logsInput
  }

  export type UserAccessLogUncheckedCreateInput = {
    id?: string
    userId: number
    action: string
    ipAddress?: string | null
    userAgent?: string | null
    success: boolean
    details?: string | null
    createdAt?: Date | string
  }

  export type UserAccessLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccess_logsNestedInput
  }

  export type UserAccessLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAccessLogCreateManyInput = {
    id?: string
    userId: number
    action: string
    ipAddress?: string | null
    userAgent?: string | null
    success: boolean
    details?: string | null
    createdAt?: Date | string
  }

  export type UserAccessLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAccessLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserIPRestrictionCreateInput = {
    id?: string
    ipAddress: string
    type: string
    reason?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutIp_restrictionsInput
  }

  export type UserIPRestrictionUncheckedCreateInput = {
    id?: string
    userId: number
    ipAddress: string
    type: string
    reason?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserIPRestrictionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutIp_restrictionsNestedInput
  }

  export type UserIPRestrictionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    ipAddress?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserIPRestrictionCreateManyInput = {
    id?: string
    userId: number
    ipAddress: string
    type: string
    reason?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserIPRestrictionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserIPRestrictionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    ipAddress?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAddressCreateInput = {
    street: string
    city: string
    state: string
    postalCode: string
    country?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAddressInput
  }

  export type UserAddressUncheckedCreateInput = {
    id?: number
    userId: number
    street: string
    city: string
    state: string
    postalCode: string
    country?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAddressUpdateInput = {
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAddressNestedInput
  }

  export type UserAddressUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAddressCreateManyInput = {
    id?: number
    userId: number
    street: string
    city: string
    state: string
    postalCode: string
    country?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAddressUpdateManyMutationInput = {
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAddressUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserEmergencyContactCreateInput = {
    name: string
    relationship: string
    phone: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEmergency_contactInput
  }

  export type UserEmergencyContactUncheckedCreateInput = {
    id?: number
    userId: number
    name: string
    relationship: string
    phone: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserEmergencyContactUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmergency_contactNestedInput
  }

  export type UserEmergencyContactUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserEmergencyContactCreateManyInput = {
    id?: number
    userId: number
    name: string
    relationship: string
    phone: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserEmergencyContactUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserEmergencyContactUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSocialMediaCreateInput = {
    linkedin?: string | null
    twitter?: string | null
    facebook?: string | null
    instagram?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSocial_mediaInput
  }

  export type UserSocialMediaUncheckedCreateInput = {
    id?: number
    userId: number
    linkedin?: string | null
    twitter?: string | null
    facebook?: string | null
    instagram?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSocialMediaUpdateInput = {
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSocial_mediaNestedInput
  }

  export type UserSocialMediaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSocialMediaCreateManyInput = {
    id?: number
    userId: number
    linkedin?: string | null
    twitter?: string | null
    facebook?: string | null
    instagram?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSocialMediaUpdateManyMutationInput = {
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSocialMediaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferencesCreateInput = {
    theme?: string
    language?: string
    timezone?: string
    dateFormat?: string
    timeFormat?: string
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPreferencesInput
  }

  export type UserPreferencesUncheckedCreateInput = {
    id?: number
    userId: number
    theme?: string
    language?: string
    timezone?: string
    dateFormat?: string
    timeFormat?: string
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPreferencesUpdateInput = {
    theme?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    dateFormat?: StringFieldUpdateOperationsInput | string
    timeFormat?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPreferencesNestedInput
  }

  export type UserPreferencesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    theme?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    dateFormat?: StringFieldUpdateOperationsInput | string
    timeFormat?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferencesCreateManyInput = {
    id?: number
    userId: number
    theme?: string
    language?: string
    timezone?: string
    dateFormat?: string
    timeFormat?: string
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPreferencesUpdateManyMutationInput = {
    theme?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    dateFormat?: StringFieldUpdateOperationsInput | string
    timeFormat?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferencesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    theme?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    dateFormat?: StringFieldUpdateOperationsInput | string
    timeFormat?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNotificationSettingsCreateInput = {
    email_loginAlerts?: boolean
    email_securityUpdates?: boolean
    email_systemAnnouncements?: boolean
    email_marketingEmails?: boolean
    push_loginAlerts?: boolean
    push_securityUpdates?: boolean
    push_systemAnnouncements?: boolean
    push_marketingNotifications?: boolean
    sms_loginAlerts?: boolean
    sms_securityUpdates?: boolean
    sms_emergencyAlerts?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotification_settingsInput
  }

  export type UserNotificationSettingsUncheckedCreateInput = {
    id?: number
    userId: number
    email_loginAlerts?: boolean
    email_securityUpdates?: boolean
    email_systemAnnouncements?: boolean
    email_marketingEmails?: boolean
    push_loginAlerts?: boolean
    push_securityUpdates?: boolean
    push_systemAnnouncements?: boolean
    push_marketingNotifications?: boolean
    sms_loginAlerts?: boolean
    sms_securityUpdates?: boolean
    sms_emergencyAlerts?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserNotificationSettingsUpdateInput = {
    email_loginAlerts?: BoolFieldUpdateOperationsInput | boolean
    email_securityUpdates?: BoolFieldUpdateOperationsInput | boolean
    email_systemAnnouncements?: BoolFieldUpdateOperationsInput | boolean
    email_marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    push_loginAlerts?: BoolFieldUpdateOperationsInput | boolean
    push_securityUpdates?: BoolFieldUpdateOperationsInput | boolean
    push_systemAnnouncements?: BoolFieldUpdateOperationsInput | boolean
    push_marketingNotifications?: BoolFieldUpdateOperationsInput | boolean
    sms_loginAlerts?: BoolFieldUpdateOperationsInput | boolean
    sms_securityUpdates?: BoolFieldUpdateOperationsInput | boolean
    sms_emergencyAlerts?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotification_settingsNestedInput
  }

  export type UserNotificationSettingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    email_loginAlerts?: BoolFieldUpdateOperationsInput | boolean
    email_securityUpdates?: BoolFieldUpdateOperationsInput | boolean
    email_systemAnnouncements?: BoolFieldUpdateOperationsInput | boolean
    email_marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    push_loginAlerts?: BoolFieldUpdateOperationsInput | boolean
    push_securityUpdates?: BoolFieldUpdateOperationsInput | boolean
    push_systemAnnouncements?: BoolFieldUpdateOperationsInput | boolean
    push_marketingNotifications?: BoolFieldUpdateOperationsInput | boolean
    sms_loginAlerts?: BoolFieldUpdateOperationsInput | boolean
    sms_securityUpdates?: BoolFieldUpdateOperationsInput | boolean
    sms_emergencyAlerts?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNotificationSettingsCreateManyInput = {
    id?: number
    userId: number
    email_loginAlerts?: boolean
    email_securityUpdates?: boolean
    email_systemAnnouncements?: boolean
    email_marketingEmails?: boolean
    push_loginAlerts?: boolean
    push_securityUpdates?: boolean
    push_systemAnnouncements?: boolean
    push_marketingNotifications?: boolean
    sms_loginAlerts?: boolean
    sms_securityUpdates?: boolean
    sms_emergencyAlerts?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserNotificationSettingsUpdateManyMutationInput = {
    email_loginAlerts?: BoolFieldUpdateOperationsInput | boolean
    email_securityUpdates?: BoolFieldUpdateOperationsInput | boolean
    email_systemAnnouncements?: BoolFieldUpdateOperationsInput | boolean
    email_marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    push_loginAlerts?: BoolFieldUpdateOperationsInput | boolean
    push_securityUpdates?: BoolFieldUpdateOperationsInput | boolean
    push_systemAnnouncements?: BoolFieldUpdateOperationsInput | boolean
    push_marketingNotifications?: BoolFieldUpdateOperationsInput | boolean
    sms_loginAlerts?: BoolFieldUpdateOperationsInput | boolean
    sms_securityUpdates?: BoolFieldUpdateOperationsInput | boolean
    sms_emergencyAlerts?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNotificationSettingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    email_loginAlerts?: BoolFieldUpdateOperationsInput | boolean
    email_securityUpdates?: BoolFieldUpdateOperationsInput | boolean
    email_systemAnnouncements?: BoolFieldUpdateOperationsInput | boolean
    email_marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    push_loginAlerts?: BoolFieldUpdateOperationsInput | boolean
    push_securityUpdates?: BoolFieldUpdateOperationsInput | boolean
    push_systemAnnouncements?: BoolFieldUpdateOperationsInput | boolean
    push_marketingNotifications?: BoolFieldUpdateOperationsInput | boolean
    sms_loginAlerts?: BoolFieldUpdateOperationsInput | boolean
    sms_securityUpdates?: BoolFieldUpdateOperationsInput | boolean
    sms_emergencyAlerts?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPrivacySettingsCreateInput = {
    profileVisibility?: string
    showEmail?: boolean
    showPhone?: boolean
    showLocation?: boolean
    allowContact?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPrivacy_settingsInput
  }

  export type UserPrivacySettingsUncheckedCreateInput = {
    id?: number
    userId: number
    profileVisibility?: string
    showEmail?: boolean
    showPhone?: boolean
    showLocation?: boolean
    allowContact?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPrivacySettingsUpdateInput = {
    profileVisibility?: StringFieldUpdateOperationsInput | string
    showEmail?: BoolFieldUpdateOperationsInput | boolean
    showPhone?: BoolFieldUpdateOperationsInput | boolean
    showLocation?: BoolFieldUpdateOperationsInput | boolean
    allowContact?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPrivacy_settingsNestedInput
  }

  export type UserPrivacySettingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    profileVisibility?: StringFieldUpdateOperationsInput | string
    showEmail?: BoolFieldUpdateOperationsInput | boolean
    showPhone?: BoolFieldUpdateOperationsInput | boolean
    showLocation?: BoolFieldUpdateOperationsInput | boolean
    allowContact?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPrivacySettingsCreateManyInput = {
    id?: number
    userId: number
    profileVisibility?: string
    showEmail?: boolean
    showPhone?: boolean
    showLocation?: boolean
    allowContact?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPrivacySettingsUpdateManyMutationInput = {
    profileVisibility?: StringFieldUpdateOperationsInput | string
    showEmail?: BoolFieldUpdateOperationsInput | boolean
    showPhone?: BoolFieldUpdateOperationsInput | boolean
    showLocation?: BoolFieldUpdateOperationsInput | boolean
    allowContact?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPrivacySettingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    profileVisibility?: StringFieldUpdateOperationsInput | string
    showEmail?: BoolFieldUpdateOperationsInput | boolean
    showPhone?: BoolFieldUpdateOperationsInput | boolean
    showLocation?: BoolFieldUpdateOperationsInput | boolean
    allowContact?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberCreateInput = {
    id?: string
    name: string
    email: string
    phone_number?: string | null
    password: string
    age: number
    profile_picture?: string | null
    membershiptype: $Enums.MemberShipType
    createdAt?: Date | string
    updatedAt?: Date | string
    email_verification_expires?: Date | string | null
    email_verification_token?: string | null
    email_verified?: boolean
    terms_accepted?: boolean
    terms_accepted_at?: Date | string | null
    address?: AddressCreateNestedOneWithoutMemberInput
    emergency_contact?: EmergencyContactCreateNestedOneWithoutMemberInput
    invoices?: InvoiceCreateNestedManyWithoutMemberInput
    medical_info?: MedicalInfoCreateNestedOneWithoutMemberInput
    attendance?: MemberAttendanceCreateNestedManyWithoutMemberInput
    check_ins?: MemberCheckInCreateNestedManyWithoutMemberInput
    fitness_goals?: MemberFitnessGoalCreateNestedManyWithoutMemberInput
    payments?: PaymentCreateNestedManyWithoutMemberInput
    Subscription?: SubscriptionCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    phone_number?: string | null
    password: string
    age: number
    profile_picture?: string | null
    membershiptype: $Enums.MemberShipType
    createdAt?: Date | string
    updatedAt?: Date | string
    email_verification_expires?: Date | string | null
    email_verification_token?: string | null
    email_verified?: boolean
    terms_accepted?: boolean
    terms_accepted_at?: Date | string | null
    address?: AddressUncheckedCreateNestedOneWithoutMemberInput
    emergency_contact?: EmergencyContactUncheckedCreateNestedOneWithoutMemberInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutMemberInput
    medical_info?: MedicalInfoUncheckedCreateNestedOneWithoutMemberInput
    attendance?: MemberAttendanceUncheckedCreateNestedManyWithoutMemberInput
    check_ins?: MemberCheckInUncheckedCreateNestedManyWithoutMemberInput
    fitness_goals?: MemberFitnessGoalUncheckedCreateNestedManyWithoutMemberInput
    payments?: PaymentUncheckedCreateNestedManyWithoutMemberInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    membershiptype?: EnumMemberShipTypeFieldUpdateOperationsInput | $Enums.MemberShipType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verification_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: AddressUpdateOneWithoutMemberNestedInput
    emergency_contact?: EmergencyContactUpdateOneWithoutMemberNestedInput
    invoices?: InvoiceUpdateManyWithoutMemberNestedInput
    medical_info?: MedicalInfoUpdateOneWithoutMemberNestedInput
    attendance?: MemberAttendanceUpdateManyWithoutMemberNestedInput
    check_ins?: MemberCheckInUpdateManyWithoutMemberNestedInput
    fitness_goals?: MemberFitnessGoalUpdateManyWithoutMemberNestedInput
    payments?: PaymentUpdateManyWithoutMemberNestedInput
    Subscription?: SubscriptionUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    membershiptype?: EnumMemberShipTypeFieldUpdateOperationsInput | $Enums.MemberShipType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verification_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: AddressUncheckedUpdateOneWithoutMemberNestedInput
    emergency_contact?: EmergencyContactUncheckedUpdateOneWithoutMemberNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutMemberNestedInput
    medical_info?: MedicalInfoUncheckedUpdateOneWithoutMemberNestedInput
    attendance?: MemberAttendanceUncheckedUpdateManyWithoutMemberNestedInput
    check_ins?: MemberCheckInUncheckedUpdateManyWithoutMemberNestedInput
    fitness_goals?: MemberFitnessGoalUncheckedUpdateManyWithoutMemberNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutMemberNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type MemberCreateManyInput = {
    id?: string
    name: string
    email: string
    phone_number?: string | null
    password: string
    age: number
    profile_picture?: string | null
    membershiptype: $Enums.MemberShipType
    createdAt?: Date | string
    updatedAt?: Date | string
    email_verification_expires?: Date | string | null
    email_verification_token?: string | null
    email_verified?: boolean
    terms_accepted?: boolean
    terms_accepted_at?: Date | string | null
  }

  export type MemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    membershiptype?: EnumMemberShipTypeFieldUpdateOperationsInput | $Enums.MemberShipType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verification_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    membershiptype?: EnumMemberShipTypeFieldUpdateOperationsInput | $Enums.MemberShipType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verification_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberCheckInCreateInput = {
    id?: string
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    location?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    member: MemberCreateNestedOneWithoutCheck_insInput
  }

  export type MemberCheckInUncheckedCreateInput = {
    id?: string
    memberId: string
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    location?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberCheckInUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    member?: MemberUpdateOneRequiredWithoutCheck_insNestedInput
  }

  export type MemberCheckInUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberCheckInCreateManyInput = {
    id?: string
    memberId: string
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    location?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberCheckInUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberCheckInUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberAttendanceCreateInput = {
    id?: string
    date: Date | string
    timeIn: Date | string
    timeOut?: Date | string | null
    duration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    member: MemberCreateNestedOneWithoutAttendanceInput
  }

  export type MemberAttendanceUncheckedCreateInput = {
    id?: string
    memberId: string
    date: Date | string
    timeIn: Date | string
    timeOut?: Date | string | null
    duration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberAttendanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    timeIn?: DateTimeFieldUpdateOperationsInput | Date | string
    timeOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    member?: MemberUpdateOneRequiredWithoutAttendanceNestedInput
  }

  export type MemberAttendanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    timeIn?: DateTimeFieldUpdateOperationsInput | Date | string
    timeOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberAttendanceCreateManyInput = {
    id?: string
    memberId: string
    date: Date | string
    timeIn: Date | string
    timeOut?: Date | string | null
    duration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberAttendanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    timeIn?: DateTimeFieldUpdateOperationsInput | Date | string
    timeOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberAttendanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    timeIn?: DateTimeFieldUpdateOperationsInput | Date | string
    timeOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberFitnessGoalCreateInput = {
    id?: string
    goalType: string
    targetValue: number
    currentValue: number
    unit: string
    targetDate?: Date | string | null
    isCompleted?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    member: MemberCreateNestedOneWithoutFitness_goalsInput
  }

  export type MemberFitnessGoalUncheckedCreateInput = {
    id?: string
    memberId: string
    goalType: string
    targetValue: number
    currentValue: number
    unit: string
    targetDate?: Date | string | null
    isCompleted?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberFitnessGoalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalType?: StringFieldUpdateOperationsInput | string
    targetValue?: FloatFieldUpdateOperationsInput | number
    currentValue?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    member?: MemberUpdateOneRequiredWithoutFitness_goalsNestedInput
  }

  export type MemberFitnessGoalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    goalType?: StringFieldUpdateOperationsInput | string
    targetValue?: FloatFieldUpdateOperationsInput | number
    currentValue?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberFitnessGoalCreateManyInput = {
    id?: string
    memberId: string
    goalType: string
    targetValue: number
    currentValue: number
    unit: string
    targetDate?: Date | string | null
    isCompleted?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberFitnessGoalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalType?: StringFieldUpdateOperationsInput | string
    targetValue?: FloatFieldUpdateOperationsInput | number
    currentValue?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberFitnessGoalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    goalType?: StringFieldUpdateOperationsInput | string
    targetValue?: FloatFieldUpdateOperationsInput | number
    currentValue?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCreateInput = {
    id?: string
    street: string
    city: string
    state: string
    zipCode: string
    country?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    member: MemberCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateInput = {
    id?: string
    memberId: string
    street: string
    city: string
    state: string
    zipCode: string
    country?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    member?: MemberUpdateOneRequiredWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCreateManyInput = {
    id?: string
    memberId: string
    street: string
    city: string
    state: string
    zipCode: string
    country?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmergencyContactCreateInput = {
    id?: string
    name: string
    relationship: string
    phone: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    member: MemberCreateNestedOneWithoutEmergency_contactInput
  }

  export type EmergencyContactUncheckedCreateInput = {
    id?: string
    memberId: string
    name: string
    relationship: string
    phone: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmergencyContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    member?: MemberUpdateOneRequiredWithoutEmergency_contactNestedInput
  }

  export type EmergencyContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmergencyContactCreateManyInput = {
    id?: string
    memberId: string
    name: string
    relationship: string
    phone: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmergencyContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmergencyContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalInfoCreateInput = {
    id?: string
    fitness_goals?: MedicalInfoCreatefitness_goalsInput | string[]
    health_conditions?: MedicalInfoCreatehealth_conditionsInput | string[]
    allergies?: MedicalInfoCreateallergiesInput | string[]
    medications?: MedicalInfoCreatemedicationsInput | string[]
    emergency_notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    member: MemberCreateNestedOneWithoutMedical_infoInput
  }

  export type MedicalInfoUncheckedCreateInput = {
    id?: string
    memberId: string
    fitness_goals?: MedicalInfoCreatefitness_goalsInput | string[]
    health_conditions?: MedicalInfoCreatehealth_conditionsInput | string[]
    allergies?: MedicalInfoCreateallergiesInput | string[]
    medications?: MedicalInfoCreatemedicationsInput | string[]
    emergency_notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalInfoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fitness_goals?: MedicalInfoUpdatefitness_goalsInput | string[]
    health_conditions?: MedicalInfoUpdatehealth_conditionsInput | string[]
    allergies?: MedicalInfoUpdateallergiesInput | string[]
    medications?: MedicalInfoUpdatemedicationsInput | string[]
    emergency_notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    member?: MemberUpdateOneRequiredWithoutMedical_infoNestedInput
  }

  export type MedicalInfoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    fitness_goals?: MedicalInfoUpdatefitness_goalsInput | string[]
    health_conditions?: MedicalInfoUpdatehealth_conditionsInput | string[]
    allergies?: MedicalInfoUpdateallergiesInput | string[]
    medications?: MedicalInfoUpdatemedicationsInput | string[]
    emergency_notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalInfoCreateManyInput = {
    id?: string
    memberId: string
    fitness_goals?: MedicalInfoCreatefitness_goalsInput | string[]
    health_conditions?: MedicalInfoCreatehealth_conditionsInput | string[]
    allergies?: MedicalInfoCreateallergiesInput | string[]
    medications?: MedicalInfoCreatemedicationsInput | string[]
    emergency_notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalInfoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fitness_goals?: MedicalInfoUpdatefitness_goalsInput | string[]
    health_conditions?: MedicalInfoUpdatehealth_conditionsInput | string[]
    allergies?: MedicalInfoUpdateallergiesInput | string[]
    medications?: MedicalInfoUpdatemedicationsInput | string[]
    emergency_notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalInfoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    fitness_goals?: MedicalInfoUpdatefitness_goalsInput | string[]
    health_conditions?: MedicalInfoUpdatehealth_conditionsInput | string[]
    allergies?: MedicalInfoUpdateallergiesInput | string[]
    medications?: MedicalInfoUpdatemedicationsInput | string[]
    emergency_notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    amount: number
    method: string
    createdAt?: Date | string
    status?: string
    description?: string | null
    reference?: string | null
    updatedAt?: Date | string
    Member: MemberCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    amount: number
    memberId: string
    method: string
    createdAt?: Date | string
    status?: string
    description?: string | null
    reference?: string | null
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Member?: MemberUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    memberId?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    amount: number
    memberId: string
    method: string
    createdAt?: Date | string
    status?: string
    description?: string | null
    reference?: string | null
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    memberId?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    id?: string
    amount: number
    details: string
    createdAt?: Date | string
    Member: MemberCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    memberId: string
    amount: number
    details: string
    createdAt?: Date | string
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    details?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Member?: MemberUpdateOneRequiredWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    details?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateManyInput = {
    id?: string
    memberId: string
    amount: number
    details: string
    createdAt?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    details?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    details?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipPlanCreateInput = {
    id?: string
    name: string
    price: number
    duration: number
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: SubscriptionCreateNestedManyWithoutPlanInput
  }

  export type MembershipPlanUncheckedCreateInput = {
    id?: string
    name: string
    price: number
    duration: number
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type MembershipPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUpdateManyWithoutPlanNestedInput
  }

  export type MembershipPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type MembershipPlanCreateManyInput = {
    id?: string
    name: string
    price: number
    duration: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateInput = {
    id?: string
    startDate?: Date | string
    endDate: Date | string
    member: MemberCreateNestedOneWithoutSubscriptionInput
    plan: MembershipPlanCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    memberId: string
    planId: string
    startDate?: Date | string
    endDate: Date | string
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    member?: MemberUpdateOneRequiredWithoutSubscriptionNestedInput
    plan?: MembershipPlanUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    memberId: string
    planId: string
    startDate?: Date | string
    endDate: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentCreateInput = {
    id?: string
    name: string
    type: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    available?: number
    brand?: string | null
    category: string
    cost?: number | null
    description?: string | null
    imageUrl?: string | null
    inUse?: number
    lastMaintenance?: Date | string | null
    location?: string | null
    maintenance?: boolean
    model?: string | null
    nextMaintenance?: Date | string | null
    purchaseDate?: Date | string | null
    serialNumber?: string | null
    status?: $Enums.EquipmentStatus
    warrantyExpiry?: Date | string | null
    maintenanceLogs?: MaintenanceLogCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    available?: number
    brand?: string | null
    category: string
    cost?: number | null
    description?: string | null
    imageUrl?: string | null
    inUse?: number
    lastMaintenance?: Date | string | null
    location?: string | null
    maintenance?: boolean
    model?: string | null
    nextMaintenance?: Date | string | null
    purchaseDate?: Date | string | null
    serialNumber?: string | null
    status?: $Enums.EquipmentStatus
    warrantyExpiry?: Date | string | null
    maintenanceLogs?: MaintenanceLogUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    available?: IntFieldUpdateOperationsInput | number
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    inUse?: IntFieldUpdateOperationsInput | number
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    maintenance?: BoolFieldUpdateOperationsInput | boolean
    model?: NullableStringFieldUpdateOperationsInput | string | null
    nextMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    warrantyExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maintenanceLogs?: MaintenanceLogUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    available?: IntFieldUpdateOperationsInput | number
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    inUse?: IntFieldUpdateOperationsInput | number
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    maintenance?: BoolFieldUpdateOperationsInput | boolean
    model?: NullableStringFieldUpdateOperationsInput | string | null
    nextMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    warrantyExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maintenanceLogs?: MaintenanceLogUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentCreateManyInput = {
    id?: string
    name: string
    type: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    available?: number
    brand?: string | null
    category: string
    cost?: number | null
    description?: string | null
    imageUrl?: string | null
    inUse?: number
    lastMaintenance?: Date | string | null
    location?: string | null
    maintenance?: boolean
    model?: string | null
    nextMaintenance?: Date | string | null
    purchaseDate?: Date | string | null
    serialNumber?: string | null
    status?: $Enums.EquipmentStatus
    warrantyExpiry?: Date | string | null
  }

  export type EquipmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    available?: IntFieldUpdateOperationsInput | number
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    inUse?: IntFieldUpdateOperationsInput | number
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    maintenance?: BoolFieldUpdateOperationsInput | boolean
    model?: NullableStringFieldUpdateOperationsInput | string | null
    nextMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    warrantyExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EquipmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    available?: IntFieldUpdateOperationsInput | number
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    inUse?: IntFieldUpdateOperationsInput | number
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    maintenance?: BoolFieldUpdateOperationsInput | boolean
    model?: NullableStringFieldUpdateOperationsInput | string | null
    nextMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    warrantyExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MaintenanceLogCreateInput = {
    id?: string
    type: $Enums.MaintenanceType
    description: string
    cost?: number | null
    performedBy?: string | null
    performedAt?: Date | string
    nextDue?: Date | string | null
    equipment: EquipmentCreateNestedOneWithoutMaintenanceLogsInput
  }

  export type MaintenanceLogUncheckedCreateInput = {
    id?: string
    equipmentId: string
    type: $Enums.MaintenanceType
    description: string
    cost?: number | null
    performedBy?: string | null
    performedAt?: Date | string
    nextDue?: Date | string | null
  }

  export type MaintenanceLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMaintenanceTypeFieldUpdateOperationsInput | $Enums.MaintenanceType
    description?: StringFieldUpdateOperationsInput | string
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipment?: EquipmentUpdateOneRequiredWithoutMaintenanceLogsNestedInput
  }

  export type MaintenanceLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    type?: EnumMaintenanceTypeFieldUpdateOperationsInput | $Enums.MaintenanceType
    description?: StringFieldUpdateOperationsInput | string
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MaintenanceLogCreateManyInput = {
    id?: string
    equipmentId: string
    type: $Enums.MaintenanceType
    description: string
    cost?: number | null
    performedBy?: string | null
    performedAt?: Date | string
    nextDue?: Date | string | null
  }

  export type MaintenanceLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMaintenanceTypeFieldUpdateOperationsInput | $Enums.MaintenanceType
    description?: StringFieldUpdateOperationsInput | string
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MaintenanceLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    type?: EnumMaintenanceTypeFieldUpdateOperationsInput | $Enums.MaintenanceType
    description?: StringFieldUpdateOperationsInput | string
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SystemIntegrationCreateInput = {
    id?: string
    name: string
    type: string
    status?: string
    healthScore?: number
    endpoint?: string | null
    apiKey?: string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string | null
    errorCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemIntegrationUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    status?: string
    healthScore?: number
    endpoint?: string | null
    apiKey?: string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string | null
    errorCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemIntegrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    healthScore?: IntFieldUpdateOperationsInput | number
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemIntegrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    healthScore?: IntFieldUpdateOperationsInput | number
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemIntegrationCreateManyInput = {
    id?: string
    name: string
    type: string
    status?: string
    healthScore?: number
    endpoint?: string | null
    apiKey?: string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string | null
    errorCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemIntegrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    healthScore?: IntFieldUpdateOperationsInput | number
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemIntegrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    healthScore?: IntFieldUpdateOperationsInput | number
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationWorkflowCreateInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    status?: string
    priority?: string
    trigger: string
    schedule?: string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    successCount?: number
    failureCount?: number
    lastRun?: Date | string | null
    nextRun?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutomationWorkflowUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    status?: string
    priority?: string
    trigger: string
    schedule?: string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    successCount?: number
    failureCount?: number
    lastRun?: Date | string | null
    nextRun?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutomationWorkflowUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    successCount?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationWorkflowUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    successCount?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationWorkflowCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    status?: string
    priority?: string
    trigger: string
    schedule?: string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    successCount?: number
    failureCount?: number
    lastRun?: Date | string | null
    nextRun?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutomationWorkflowUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    successCount?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationWorkflowUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    successCount?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataSyncJobCreateInput = {
    id?: string
    name: string
    source: string
    destination: string
    status?: string
    processedRecords?: number
    failedRecords?: number
    totalRecords?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorMessage?: string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DataSyncJobUncheckedCreateInput = {
    id?: string
    name: string
    source: string
    destination: string
    status?: string
    processedRecords?: number
    failedRecords?: number
    totalRecords?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorMessage?: string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DataSyncJobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    processedRecords?: IntFieldUpdateOperationsInput | number
    failedRecords?: IntFieldUpdateOperationsInput | number
    totalRecords?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataSyncJobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    processedRecords?: IntFieldUpdateOperationsInput | number
    failedRecords?: IntFieldUpdateOperationsInput | number
    totalRecords?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataSyncJobCreateManyInput = {
    id?: string
    name: string
    source: string
    destination: string
    status?: string
    processedRecords?: number
    failedRecords?: number
    totalRecords?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorMessage?: string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DataSyncJobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    processedRecords?: IntFieldUpdateOperationsInput | number
    failedRecords?: IntFieldUpdateOperationsInput | number
    totalRecords?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataSyncJobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    processedRecords?: IntFieldUpdateOperationsInput | number
    failedRecords?: IntFieldUpdateOperationsInput | number
    totalRecords?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookEndpointCreateInput = {
    id?: string
    name: string
    url: string
    method?: string
    headers?: NullableJsonNullValueInput | InputJsonValue
    events?: WebhookEndpointCreateeventsInput | string[]
    isActive?: boolean
    secret?: string | null
    lastTriggered?: Date | string | null
    successCount?: number
    failureCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebhookEndpointUncheckedCreateInput = {
    id?: string
    name: string
    url: string
    method?: string
    headers?: NullableJsonNullValueInput | InputJsonValue
    events?: WebhookEndpointCreateeventsInput | string[]
    isActive?: boolean
    secret?: string | null
    lastTriggered?: Date | string | null
    successCount?: number
    failureCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebhookEndpointUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    headers?: NullableJsonNullValueInput | InputJsonValue
    events?: WebhookEndpointUpdateeventsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successCount?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookEndpointUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    headers?: NullableJsonNullValueInput | InputJsonValue
    events?: WebhookEndpointUpdateeventsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successCount?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookEndpointCreateManyInput = {
    id?: string
    name: string
    url: string
    method?: string
    headers?: NullableJsonNullValueInput | InputJsonValue
    events?: WebhookEndpointCreateeventsInput | string[]
    isActive?: boolean
    secret?: string | null
    lastTriggered?: Date | string | null
    successCount?: number
    failureCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebhookEndpointUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    headers?: NullableJsonNullValueInput | InputJsonValue
    events?: WebhookEndpointUpdateeventsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successCount?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookEndpointUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    headers?: NullableJsonNullValueInput | InputJsonValue
    events?: WebhookEndpointUpdateeventsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successCount?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type APIManagementCreateInput = {
    id?: string
    name: string
    apiKey: string
    permissions?: APIManagementCreatepermissionsInput | string[]
    rateLimit?: number | null
    isActive?: boolean
    lastUsed?: Date | string | null
    usageCount?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type APIManagementUncheckedCreateInput = {
    id?: string
    name: string
    apiKey: string
    permissions?: APIManagementCreatepermissionsInput | string[]
    rateLimit?: number | null
    isActive?: boolean
    lastUsed?: Date | string | null
    usageCount?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type APIManagementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    permissions?: APIManagementUpdatepermissionsInput | string[]
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type APIManagementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    permissions?: APIManagementUpdatepermissionsInput | string[]
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type APIManagementCreateManyInput = {
    id?: string
    name: string
    apiKey: string
    permissions?: APIManagementCreatepermissionsInput | string[]
    rateLimit?: number | null
    isActive?: boolean
    lastUsed?: Date | string | null
    usageCount?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type APIManagementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    permissions?: APIManagementUpdatepermissionsInput | string[]
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type APIManagementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    permissions?: APIManagementUpdatepermissionsInput | string[]
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ThreatDetectionCreateInput = {
    id?: string
    threatType: string
    severity?: string
    status?: string
    description: string
    source?: string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    assignedTo?: string | null
    resolvedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ThreatDetectionUncheckedCreateInput = {
    id?: string
    threatType: string
    severity?: string
    status?: string
    description: string
    source?: string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    assignedTo?: string | null
    resolvedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ThreatDetectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    threatType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ThreatDetectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    threatType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ThreatDetectionCreateManyInput = {
    id?: string
    threatType: string
    severity?: string
    status?: string
    description: string
    source?: string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    assignedTo?: string | null
    resolvedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ThreatDetectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    threatType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ThreatDetectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    threatType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnomalyDetectionCreateInput = {
    id?: string
    anomalyType: string
    confidence: number
    status?: string
    description: string
    data?: NullableJsonNullValueInput | InputJsonValue
    severity?: string
    resolvedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnomalyDetectionUncheckedCreateInput = {
    id?: string
    anomalyType: string
    confidence: number
    status?: string
    description: string
    data?: NullableJsonNullValueInput | InputJsonValue
    severity?: string
    resolvedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnomalyDetectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    anomalyType?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    severity?: StringFieldUpdateOperationsInput | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnomalyDetectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    anomalyType?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    severity?: StringFieldUpdateOperationsInput | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnomalyDetectionCreateManyInput = {
    id?: string
    anomalyType: string
    confidence: number
    status?: string
    description: string
    data?: NullableJsonNullValueInput | InputJsonValue
    severity?: string
    resolvedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnomalyDetectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    anomalyType?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    severity?: StringFieldUpdateOperationsInput | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnomalyDetectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    anomalyType?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    severity?: StringFieldUpdateOperationsInput | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceReportCreateInput = {
    id?: string
    reportType: string
    status?: string
    period: string
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: string | null
    submittedBy?: string | null
    submittedAt?: Date | string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplianceReportUncheckedCreateInput = {
    id?: string
    reportType: string
    status?: string
    period: string
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: string | null
    submittedBy?: string | null
    submittedAt?: Date | string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplianceReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceReportCreateManyInput = {
    id?: string
    reportType: string
    status?: string
    period: string
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: string | null
    submittedBy?: string | null
    submittedAt?: Date | string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplianceReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    findings?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityWorkflowCreateInput = {
    id?: string
    name: string
    type: string
    status?: string
    priority?: string
    assignedTo?: string | null
    dueDate?: Date | string | null
    steps?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecurityWorkflowUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    status?: string
    priority?: string
    assignedTo?: string | null
    dueDate?: Date | string | null
    steps?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecurityWorkflowUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    steps?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityWorkflowUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    steps?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityWorkflowCreateManyInput = {
    id?: string
    name: string
    type: string
    status?: string
    priority?: string
    assignedTo?: string | null
    dueDate?: Date | string | null
    steps?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecurityWorkflowUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    steps?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityWorkflowUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    steps?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityIntegrationCreateInput = {
    id?: string
    name: string
    type: string
    status?: string
    endpoint?: string | null
    apiKey?: string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string | null
    healthScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecurityIntegrationUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    status?: string
    endpoint?: string | null
    apiKey?: string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string | null
    healthScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecurityIntegrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    healthScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityIntegrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    healthScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityIntegrationCreateManyInput = {
    id?: string
    name: string
    type: string
    status?: string
    endpoint?: string | null
    apiKey?: string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string | null
    healthScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecurityIntegrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    healthScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityIntegrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    healthScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdministrativeProfileCreateInput = {
    id?: string
    adminLevel?: string
    departments?: AdministrativeProfileCreatedepartmentsInput | string[]
    responsibilities?: AdministrativeProfileCreateresponsibilitiesInput | string[]
    criticalPermissions?: AdministrativeProfileCreatecriticalPermissionsInput | string[]
    emergencyContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAdmin_profileInput
  }

  export type AdministrativeProfileUncheckedCreateInput = {
    id?: string
    userId: number
    adminLevel?: string
    departments?: AdministrativeProfileCreatedepartmentsInput | string[]
    responsibilities?: AdministrativeProfileCreateresponsibilitiesInput | string[]
    criticalPermissions?: AdministrativeProfileCreatecriticalPermissionsInput | string[]
    emergencyContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdministrativeProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminLevel?: StringFieldUpdateOperationsInput | string
    departments?: AdministrativeProfileUpdatedepartmentsInput | string[]
    responsibilities?: AdministrativeProfileUpdateresponsibilitiesInput | string[]
    criticalPermissions?: AdministrativeProfileUpdatecriticalPermissionsInput | string[]
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdmin_profileNestedInput
  }

  export type AdministrativeProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    adminLevel?: StringFieldUpdateOperationsInput | string
    departments?: AdministrativeProfileUpdatedepartmentsInput | string[]
    responsibilities?: AdministrativeProfileUpdateresponsibilitiesInput | string[]
    criticalPermissions?: AdministrativeProfileUpdatecriticalPermissionsInput | string[]
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdministrativeProfileCreateManyInput = {
    id?: string
    userId: number
    adminLevel?: string
    departments?: AdministrativeProfileCreatedepartmentsInput | string[]
    responsibilities?: AdministrativeProfileCreateresponsibilitiesInput | string[]
    criticalPermissions?: AdministrativeProfileCreatecriticalPermissionsInput | string[]
    emergencyContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdministrativeProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminLevel?: StringFieldUpdateOperationsInput | string
    departments?: AdministrativeProfileUpdatedepartmentsInput | string[]
    responsibilities?: AdministrativeProfileUpdateresponsibilitiesInput | string[]
    criticalPermissions?: AdministrativeProfileUpdatecriticalPermissionsInput | string[]
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdministrativeProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    adminLevel?: StringFieldUpdateOperationsInput | string
    departments?: AdministrativeProfileUpdatedepartmentsInput | string[]
    responsibilities?: AdministrativeProfileUpdateresponsibilitiesInput | string[]
    criticalPermissions?: AdministrativeProfileUpdatecriticalPermissionsInput | string[]
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomRoleCreateInput = {
    id?: string
    name: string
    description?: string | null
    permissions?: CustomRoleCreatepermissionsInput | string[]
    parentRole?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    hierarchy?: RoleHierarchyCreateNestedOneWithoutRoleInput
  }

  export type CustomRoleUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    permissions?: CustomRoleCreatepermissionsInput | string[]
    parentRole?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    hierarchy?: RoleHierarchyUncheckedCreateNestedOneWithoutRoleInput
  }

  export type CustomRoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: CustomRoleUpdatepermissionsInput | string[]
    parentRole?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hierarchy?: RoleHierarchyUpdateOneWithoutRoleNestedInput
  }

  export type CustomRoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: CustomRoleUpdatepermissionsInput | string[]
    parentRole?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hierarchy?: RoleHierarchyUncheckedUpdateOneWithoutRoleNestedInput
  }

  export type CustomRoleCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    permissions?: CustomRoleCreatepermissionsInput | string[]
    parentRole?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomRoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: CustomRoleUpdatepermissionsInput | string[]
    parentRole?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomRoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: CustomRoleUpdatepermissionsInput | string[]
    parentRole?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionCreateInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    action: string
    resource: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    action: string
    resource: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    action: string
    resource: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleHierarchyCreateInput = {
    id?: string
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: RoleHierarchyCreateNestedOneWithoutChildrenInput
    children?: RoleHierarchyCreateNestedManyWithoutParentInput
    role: CustomRoleCreateNestedOneWithoutHierarchyInput
  }

  export type RoleHierarchyUncheckedCreateInput = {
    id?: string
    roleId: string
    parentId?: string | null
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: RoleHierarchyUncheckedCreateNestedManyWithoutParentInput
  }

  export type RoleHierarchyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: RoleHierarchyUpdateOneWithoutChildrenNestedInput
    children?: RoleHierarchyUpdateManyWithoutParentNestedInput
    role?: CustomRoleUpdateOneRequiredWithoutHierarchyNestedInput
  }

  export type RoleHierarchyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: RoleHierarchyUncheckedUpdateManyWithoutParentNestedInput
  }

  export type RoleHierarchyCreateManyInput = {
    id?: string
    roleId: string
    parentId?: string | null
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleHierarchyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleHierarchyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionAuditCreateInput = {
    id?: string
    action: string
    permissionId: string
    oldValue?: string | null
    newValue: string
    reason?: string | null
    performedBy?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPermission_auditsInput
  }

  export type PermissionAuditUncheckedCreateInput = {
    id?: string
    userId: number
    action: string
    permissionId: string
    oldValue?: string | null
    newValue: string
    reason?: string | null
    performedBy?: string | null
    createdAt?: Date | string
  }

  export type PermissionAuditUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPermission_auditsNestedInput
  }

  export type PermissionAuditUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionAuditCreateManyInput = {
    id?: string
    userId: number
    action: string
    permissionId: string
    oldValue?: string | null
    newValue: string
    reason?: string | null
    performedBy?: string | null
    createdAt?: Date | string
  }

  export type PermissionAuditUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionAuditUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type AdministrativeProfileNullableScalarRelationFilter = {
    is?: AdministrativeProfileWhereInput | null
    isNot?: AdministrativeProfileWhereInput | null
  }

  export type PermissionAuditListRelationFilter = {
    every?: PermissionAuditWhereInput
    some?: PermissionAuditWhereInput
    none?: PermissionAuditWhereInput
  }

  export type UserAccessLogListRelationFilter = {
    every?: UserAccessLogWhereInput
    some?: UserAccessLogWhereInput
    none?: UserAccessLogWhereInput
  }

  export type UserAddressNullableScalarRelationFilter = {
    is?: UserAddressWhereInput | null
    isNot?: UserAddressWhereInput | null
  }

  export type UserEmergencyContactNullableScalarRelationFilter = {
    is?: UserEmergencyContactWhereInput | null
    isNot?: UserEmergencyContactWhereInput | null
  }

  export type UserIPRestrictionListRelationFilter = {
    every?: UserIPRestrictionWhereInput
    some?: UserIPRestrictionWhereInput
    none?: UserIPRestrictionWhereInput
  }

  export type UserNotificationSettingsNullableScalarRelationFilter = {
    is?: UserNotificationSettingsWhereInput | null
    isNot?: UserNotificationSettingsWhereInput | null
  }

  export type UserPreferencesNullableScalarRelationFilter = {
    is?: UserPreferencesWhereInput | null
    isNot?: UserPreferencesWhereInput | null
  }

  export type UserPrivacySettingsNullableScalarRelationFilter = {
    is?: UserPrivacySettingsWhereInput | null
    isNot?: UserPrivacySettingsWhereInput | null
  }

  export type UserSessionListRelationFilter = {
    every?: UserSessionWhereInput
    some?: UserSessionWhereInput
    none?: UserSessionWhereInput
  }

  export type UserSocialMediaNullableScalarRelationFilter = {
    is?: UserSocialMediaWhereInput | null
    isNot?: UserSocialMediaWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PermissionAuditOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAccessLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserIPRestrictionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    password?: SortOrder
    role?: SortOrder
    profile_picture?: SortOrder
    tokenVersion?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    resetToken?: SortOrder
    resetTokenExp?: SortOrder
    bio?: SortOrder
    dateOfBirth?: SortOrder
    department?: SortOrder
    email_verified?: SortOrder
    gender?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrder
    lockedUntil?: SortOrder
    loginAttempts?: SortOrder
    position?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    tokenVersion?: SortOrder
    loginAttempts?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    password?: SortOrder
    role?: SortOrder
    profile_picture?: SortOrder
    tokenVersion?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    resetToken?: SortOrder
    resetTokenExp?: SortOrder
    bio?: SortOrder
    dateOfBirth?: SortOrder
    department?: SortOrder
    email_verified?: SortOrder
    gender?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrder
    lockedUntil?: SortOrder
    loginAttempts?: SortOrder
    position?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    password?: SortOrder
    role?: SortOrder
    profile_picture?: SortOrder
    tokenVersion?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    resetToken?: SortOrder
    resetTokenExp?: SortOrder
    bio?: SortOrder
    dateOfBirth?: SortOrder
    department?: SortOrder
    email_verified?: SortOrder
    gender?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrder
    lockedUntil?: SortOrder
    loginAttempts?: SortOrder
    position?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    tokenVersion?: SortOrder
    loginAttempts?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    deviceType?: SortOrder
    deviceInfo?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    isActive?: SortOrder
    lastActivity?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSessionAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type UserSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    deviceType?: SortOrder
    deviceInfo?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    isActive?: SortOrder
    lastActivity?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    deviceType?: SortOrder
    deviceInfo?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    isActive?: SortOrder
    lastActivity?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSessionSumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type UserAccessLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    success?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAccessLogAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type UserAccessLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    success?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAccessLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    success?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAccessLogSumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type UserIPRestrictionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ipAddress?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserIPRestrictionAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type UserIPRestrictionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ipAddress?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserIPRestrictionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ipAddress?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserIPRestrictionSumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type UserAddressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAddressAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserAddressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAddressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAddressSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserEmergencyContactCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    relationship?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserEmergencyContactAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserEmergencyContactMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    relationship?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserEmergencyContactMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    relationship?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserEmergencyContactSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserSocialMediaCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    linkedin?: SortOrder
    twitter?: SortOrder
    facebook?: SortOrder
    instagram?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSocialMediaAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserSocialMediaMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    linkedin?: SortOrder
    twitter?: SortOrder
    facebook?: SortOrder
    instagram?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSocialMediaMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    linkedin?: SortOrder
    twitter?: SortOrder
    facebook?: SortOrder
    instagram?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSocialMediaSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserPreferencesCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    theme?: SortOrder
    language?: SortOrder
    timezone?: SortOrder
    dateFormat?: SortOrder
    timeFormat?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPreferencesAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserPreferencesMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    theme?: SortOrder
    language?: SortOrder
    timezone?: SortOrder
    dateFormat?: SortOrder
    timeFormat?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPreferencesMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    theme?: SortOrder
    language?: SortOrder
    timezone?: SortOrder
    dateFormat?: SortOrder
    timeFormat?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPreferencesSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserNotificationSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email_loginAlerts?: SortOrder
    email_securityUpdates?: SortOrder
    email_systemAnnouncements?: SortOrder
    email_marketingEmails?: SortOrder
    push_loginAlerts?: SortOrder
    push_securityUpdates?: SortOrder
    push_systemAnnouncements?: SortOrder
    push_marketingNotifications?: SortOrder
    sms_loginAlerts?: SortOrder
    sms_securityUpdates?: SortOrder
    sms_emergencyAlerts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserNotificationSettingsAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserNotificationSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email_loginAlerts?: SortOrder
    email_securityUpdates?: SortOrder
    email_systemAnnouncements?: SortOrder
    email_marketingEmails?: SortOrder
    push_loginAlerts?: SortOrder
    push_securityUpdates?: SortOrder
    push_systemAnnouncements?: SortOrder
    push_marketingNotifications?: SortOrder
    sms_loginAlerts?: SortOrder
    sms_securityUpdates?: SortOrder
    sms_emergencyAlerts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserNotificationSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email_loginAlerts?: SortOrder
    email_securityUpdates?: SortOrder
    email_systemAnnouncements?: SortOrder
    email_marketingEmails?: SortOrder
    push_loginAlerts?: SortOrder
    push_securityUpdates?: SortOrder
    push_systemAnnouncements?: SortOrder
    push_marketingNotifications?: SortOrder
    sms_loginAlerts?: SortOrder
    sms_securityUpdates?: SortOrder
    sms_emergencyAlerts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserNotificationSettingsSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserPrivacySettingsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    profileVisibility?: SortOrder
    showEmail?: SortOrder
    showPhone?: SortOrder
    showLocation?: SortOrder
    allowContact?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPrivacySettingsAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserPrivacySettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    profileVisibility?: SortOrder
    showEmail?: SortOrder
    showPhone?: SortOrder
    showLocation?: SortOrder
    allowContact?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPrivacySettingsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    profileVisibility?: SortOrder
    showEmail?: SortOrder
    showPhone?: SortOrder
    showLocation?: SortOrder
    allowContact?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPrivacySettingsSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EnumMemberShipTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberShipType | EnumMemberShipTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MemberShipType[] | ListEnumMemberShipTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberShipType[] | ListEnumMemberShipTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberShipTypeFilter<$PrismaModel> | $Enums.MemberShipType
  }

  export type AddressNullableScalarRelationFilter = {
    is?: AddressWhereInput | null
    isNot?: AddressWhereInput | null
  }

  export type EmergencyContactNullableScalarRelationFilter = {
    is?: EmergencyContactWhereInput | null
    isNot?: EmergencyContactWhereInput | null
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type MedicalInfoNullableScalarRelationFilter = {
    is?: MedicalInfoWhereInput | null
    isNot?: MedicalInfoWhereInput | null
  }

  export type MemberAttendanceListRelationFilter = {
    every?: MemberAttendanceWhereInput
    some?: MemberAttendanceWhereInput
    none?: MemberAttendanceWhereInput
  }

  export type MemberCheckInListRelationFilter = {
    every?: MemberCheckInWhereInput
    some?: MemberCheckInWhereInput
    none?: MemberCheckInWhereInput
  }

  export type MemberFitnessGoalListRelationFilter = {
    every?: MemberFitnessGoalWhereInput
    some?: MemberFitnessGoalWhereInput
    none?: MemberFitnessGoalWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type SubscriptionListRelationFilter = {
    every?: SubscriptionWhereInput
    some?: SubscriptionWhereInput
    none?: SubscriptionWhereInput
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MemberAttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MemberCheckInOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MemberFitnessGoalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MemberCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    password?: SortOrder
    age?: SortOrder
    profile_picture?: SortOrder
    membershiptype?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email_verification_expires?: SortOrder
    email_verification_token?: SortOrder
    email_verified?: SortOrder
    terms_accepted?: SortOrder
    terms_accepted_at?: SortOrder
  }

  export type MemberAvgOrderByAggregateInput = {
    age?: SortOrder
  }

  export type MemberMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    password?: SortOrder
    age?: SortOrder
    profile_picture?: SortOrder
    membershiptype?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email_verification_expires?: SortOrder
    email_verification_token?: SortOrder
    email_verified?: SortOrder
    terms_accepted?: SortOrder
    terms_accepted_at?: SortOrder
  }

  export type MemberMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    password?: SortOrder
    age?: SortOrder
    profile_picture?: SortOrder
    membershiptype?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email_verification_expires?: SortOrder
    email_verification_token?: SortOrder
    email_verified?: SortOrder
    terms_accepted?: SortOrder
    terms_accepted_at?: SortOrder
  }

  export type MemberSumOrderByAggregateInput = {
    age?: SortOrder
  }

  export type EnumMemberShipTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberShipType | EnumMemberShipTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MemberShipType[] | ListEnumMemberShipTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberShipType[] | ListEnumMemberShipTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberShipTypeWithAggregatesFilter<$PrismaModel> | $Enums.MemberShipType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMemberShipTypeFilter<$PrismaModel>
    _max?: NestedEnumMemberShipTypeFilter<$PrismaModel>
  }

  export type MemberScalarRelationFilter = {
    is?: MemberWhereInput
    isNot?: MemberWhereInput
  }

  export type MemberCheckInCountOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    location?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberCheckInMaxOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    location?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberCheckInMinOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    location?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type MemberAttendanceCountOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    date?: SortOrder
    timeIn?: SortOrder
    timeOut?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberAttendanceAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type MemberAttendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    date?: SortOrder
    timeIn?: SortOrder
    timeOut?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberAttendanceMinOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    date?: SortOrder
    timeIn?: SortOrder
    timeOut?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberAttendanceSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type MemberFitnessGoalCountOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    goalType?: SortOrder
    targetValue?: SortOrder
    currentValue?: SortOrder
    unit?: SortOrder
    targetDate?: SortOrder
    isCompleted?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberFitnessGoalAvgOrderByAggregateInput = {
    targetValue?: SortOrder
    currentValue?: SortOrder
  }

  export type MemberFitnessGoalMaxOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    goalType?: SortOrder
    targetValue?: SortOrder
    currentValue?: SortOrder
    unit?: SortOrder
    targetDate?: SortOrder
    isCompleted?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberFitnessGoalMinOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    goalType?: SortOrder
    targetValue?: SortOrder
    currentValue?: SortOrder
    unit?: SortOrder
    targetDate?: SortOrder
    isCompleted?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberFitnessGoalSumOrderByAggregateInput = {
    targetValue?: SortOrder
    currentValue?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type AddressCountOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressMaxOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressMinOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmergencyContactCountOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    name?: SortOrder
    relationship?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmergencyContactMaxOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    name?: SortOrder
    relationship?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmergencyContactMinOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    name?: SortOrder
    relationship?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type MedicalInfoCountOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    fitness_goals?: SortOrder
    health_conditions?: SortOrder
    allergies?: SortOrder
    medications?: SortOrder
    emergency_notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicalInfoMaxOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    emergency_notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicalInfoMinOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    emergency_notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    memberId?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    description?: SortOrder
    reference?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    memberId?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    description?: SortOrder
    reference?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    memberId?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    description?: SortOrder
    reference?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    amount?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    amount?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    amount?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type MembershipPlanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MembershipPlanAvgOrderByAggregateInput = {
    price?: SortOrder
    duration?: SortOrder
  }

  export type MembershipPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MembershipPlanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MembershipPlanSumOrderByAggregateInput = {
    price?: SortOrder
    duration?: SortOrder
  }

  export type MembershipPlanScalarRelationFilter = {
    is?: MembershipPlanWhereInput
    isNot?: MembershipPlanWhereInput
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    planId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    planId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    planId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumEquipmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentStatus | EnumEquipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentStatusFilter<$PrismaModel> | $Enums.EquipmentStatus
  }

  export type MaintenanceLogListRelationFilter = {
    every?: MaintenanceLogWhereInput
    some?: MaintenanceLogWhereInput
    none?: MaintenanceLogWhereInput
  }

  export type MaintenanceLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EquipmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    available?: SortOrder
    brand?: SortOrder
    category?: SortOrder
    cost?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    inUse?: SortOrder
    lastMaintenance?: SortOrder
    location?: SortOrder
    maintenance?: SortOrder
    model?: SortOrder
    nextMaintenance?: SortOrder
    purchaseDate?: SortOrder
    serialNumber?: SortOrder
    status?: SortOrder
    warrantyExpiry?: SortOrder
  }

  export type EquipmentAvgOrderByAggregateInput = {
    quantity?: SortOrder
    available?: SortOrder
    cost?: SortOrder
    inUse?: SortOrder
  }

  export type EquipmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    available?: SortOrder
    brand?: SortOrder
    category?: SortOrder
    cost?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    inUse?: SortOrder
    lastMaintenance?: SortOrder
    location?: SortOrder
    maintenance?: SortOrder
    model?: SortOrder
    nextMaintenance?: SortOrder
    purchaseDate?: SortOrder
    serialNumber?: SortOrder
    status?: SortOrder
    warrantyExpiry?: SortOrder
  }

  export type EquipmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    available?: SortOrder
    brand?: SortOrder
    category?: SortOrder
    cost?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    inUse?: SortOrder
    lastMaintenance?: SortOrder
    location?: SortOrder
    maintenance?: SortOrder
    model?: SortOrder
    nextMaintenance?: SortOrder
    purchaseDate?: SortOrder
    serialNumber?: SortOrder
    status?: SortOrder
    warrantyExpiry?: SortOrder
  }

  export type EquipmentSumOrderByAggregateInput = {
    quantity?: SortOrder
    available?: SortOrder
    cost?: SortOrder
    inUse?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumEquipmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentStatus | EnumEquipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.EquipmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEquipmentStatusFilter<$PrismaModel>
    _max?: NestedEnumEquipmentStatusFilter<$PrismaModel>
  }

  export type EnumMaintenanceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceType | EnumMaintenanceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceType[] | ListEnumMaintenanceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceType[] | ListEnumMaintenanceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceTypeFilter<$PrismaModel> | $Enums.MaintenanceType
  }

  export type EquipmentScalarRelationFilter = {
    is?: EquipmentWhereInput
    isNot?: EquipmentWhereInput
  }

  export type MaintenanceLogCountOrderByAggregateInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    cost?: SortOrder
    performedBy?: SortOrder
    performedAt?: SortOrder
    nextDue?: SortOrder
  }

  export type MaintenanceLogAvgOrderByAggregateInput = {
    cost?: SortOrder
  }

  export type MaintenanceLogMaxOrderByAggregateInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    cost?: SortOrder
    performedBy?: SortOrder
    performedAt?: SortOrder
    nextDue?: SortOrder
  }

  export type MaintenanceLogMinOrderByAggregateInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    cost?: SortOrder
    performedBy?: SortOrder
    performedAt?: SortOrder
    nextDue?: SortOrder
  }

  export type MaintenanceLogSumOrderByAggregateInput = {
    cost?: SortOrder
  }

  export type EnumMaintenanceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceType | EnumMaintenanceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceType[] | ListEnumMaintenanceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceType[] | ListEnumMaintenanceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceTypeWithAggregatesFilter<$PrismaModel> | $Enums.MaintenanceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaintenanceTypeFilter<$PrismaModel>
    _max?: NestedEnumMaintenanceTypeFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SystemIntegrationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    healthScore?: SortOrder
    endpoint?: SortOrder
    apiKey?: SortOrder
    config?: SortOrder
    lastSync?: SortOrder
    errorCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemIntegrationAvgOrderByAggregateInput = {
    healthScore?: SortOrder
    errorCount?: SortOrder
  }

  export type SystemIntegrationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    healthScore?: SortOrder
    endpoint?: SortOrder
    apiKey?: SortOrder
    lastSync?: SortOrder
    errorCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemIntegrationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    healthScore?: SortOrder
    endpoint?: SortOrder
    apiKey?: SortOrder
    lastSync?: SortOrder
    errorCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemIntegrationSumOrderByAggregateInput = {
    healthScore?: SortOrder
    errorCount?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type AutomationWorkflowCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    trigger?: SortOrder
    schedule?: SortOrder
    config?: SortOrder
    successCount?: SortOrder
    failureCount?: SortOrder
    lastRun?: SortOrder
    nextRun?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AutomationWorkflowAvgOrderByAggregateInput = {
    successCount?: SortOrder
    failureCount?: SortOrder
  }

  export type AutomationWorkflowMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    trigger?: SortOrder
    schedule?: SortOrder
    successCount?: SortOrder
    failureCount?: SortOrder
    lastRun?: SortOrder
    nextRun?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AutomationWorkflowMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    trigger?: SortOrder
    schedule?: SortOrder
    successCount?: SortOrder
    failureCount?: SortOrder
    lastRun?: SortOrder
    nextRun?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AutomationWorkflowSumOrderByAggregateInput = {
    successCount?: SortOrder
    failureCount?: SortOrder
  }

  export type DataSyncJobCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    source?: SortOrder
    destination?: SortOrder
    status?: SortOrder
    processedRecords?: SortOrder
    failedRecords?: SortOrder
    totalRecords?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorMessage?: SortOrder
    config?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DataSyncJobAvgOrderByAggregateInput = {
    processedRecords?: SortOrder
    failedRecords?: SortOrder
    totalRecords?: SortOrder
  }

  export type DataSyncJobMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    source?: SortOrder
    destination?: SortOrder
    status?: SortOrder
    processedRecords?: SortOrder
    failedRecords?: SortOrder
    totalRecords?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DataSyncJobMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    source?: SortOrder
    destination?: SortOrder
    status?: SortOrder
    processedRecords?: SortOrder
    failedRecords?: SortOrder
    totalRecords?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DataSyncJobSumOrderByAggregateInput = {
    processedRecords?: SortOrder
    failedRecords?: SortOrder
    totalRecords?: SortOrder
  }

  export type WebhookEndpointCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    method?: SortOrder
    headers?: SortOrder
    events?: SortOrder
    isActive?: SortOrder
    secret?: SortOrder
    lastTriggered?: SortOrder
    successCount?: SortOrder
    failureCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebhookEndpointAvgOrderByAggregateInput = {
    successCount?: SortOrder
    failureCount?: SortOrder
  }

  export type WebhookEndpointMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    method?: SortOrder
    isActive?: SortOrder
    secret?: SortOrder
    lastTriggered?: SortOrder
    successCount?: SortOrder
    failureCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebhookEndpointMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    method?: SortOrder
    isActive?: SortOrder
    secret?: SortOrder
    lastTriggered?: SortOrder
    successCount?: SortOrder
    failureCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebhookEndpointSumOrderByAggregateInput = {
    successCount?: SortOrder
    failureCount?: SortOrder
  }

  export type APIManagementCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    apiKey?: SortOrder
    permissions?: SortOrder
    rateLimit?: SortOrder
    isActive?: SortOrder
    lastUsed?: SortOrder
    usageCount?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type APIManagementAvgOrderByAggregateInput = {
    rateLimit?: SortOrder
    usageCount?: SortOrder
  }

  export type APIManagementMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    apiKey?: SortOrder
    rateLimit?: SortOrder
    isActive?: SortOrder
    lastUsed?: SortOrder
    usageCount?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type APIManagementMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    apiKey?: SortOrder
    rateLimit?: SortOrder
    isActive?: SortOrder
    lastUsed?: SortOrder
    usageCount?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type APIManagementSumOrderByAggregateInput = {
    rateLimit?: SortOrder
    usageCount?: SortOrder
  }

  export type ThreatDetectionCountOrderByAggregateInput = {
    id?: SortOrder
    threatType?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    description?: SortOrder
    source?: SortOrder
    evidence?: SortOrder
    assignedTo?: SortOrder
    resolvedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ThreatDetectionMaxOrderByAggregateInput = {
    id?: SortOrder
    threatType?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    description?: SortOrder
    source?: SortOrder
    assignedTo?: SortOrder
    resolvedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ThreatDetectionMinOrderByAggregateInput = {
    id?: SortOrder
    threatType?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    description?: SortOrder
    source?: SortOrder
    assignedTo?: SortOrder
    resolvedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnomalyDetectionCountOrderByAggregateInput = {
    id?: SortOrder
    anomalyType?: SortOrder
    confidence?: SortOrder
    status?: SortOrder
    description?: SortOrder
    data?: SortOrder
    severity?: SortOrder
    resolvedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnomalyDetectionAvgOrderByAggregateInput = {
    confidence?: SortOrder
  }

  export type AnomalyDetectionMaxOrderByAggregateInput = {
    id?: SortOrder
    anomalyType?: SortOrder
    confidence?: SortOrder
    status?: SortOrder
    description?: SortOrder
    severity?: SortOrder
    resolvedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnomalyDetectionMinOrderByAggregateInput = {
    id?: SortOrder
    anomalyType?: SortOrder
    confidence?: SortOrder
    status?: SortOrder
    description?: SortOrder
    severity?: SortOrder
    resolvedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnomalyDetectionSumOrderByAggregateInput = {
    confidence?: SortOrder
  }

  export type ComplianceReportCountOrderByAggregateInput = {
    id?: SortOrder
    reportType?: SortOrder
    status?: SortOrder
    period?: SortOrder
    findings?: SortOrder
    recommendations?: SortOrder
    submittedBy?: SortOrder
    submittedAt?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComplianceReportMaxOrderByAggregateInput = {
    id?: SortOrder
    reportType?: SortOrder
    status?: SortOrder
    period?: SortOrder
    recommendations?: SortOrder
    submittedBy?: SortOrder
    submittedAt?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComplianceReportMinOrderByAggregateInput = {
    id?: SortOrder
    reportType?: SortOrder
    status?: SortOrder
    period?: SortOrder
    recommendations?: SortOrder
    submittedBy?: SortOrder
    submittedAt?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SecurityWorkflowCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    assignedTo?: SortOrder
    dueDate?: SortOrder
    steps?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SecurityWorkflowMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    assignedTo?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SecurityWorkflowMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    assignedTo?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SecurityIntegrationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    endpoint?: SortOrder
    apiKey?: SortOrder
    config?: SortOrder
    lastSync?: SortOrder
    healthScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SecurityIntegrationAvgOrderByAggregateInput = {
    healthScore?: SortOrder
  }

  export type SecurityIntegrationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    endpoint?: SortOrder
    apiKey?: SortOrder
    lastSync?: SortOrder
    healthScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SecurityIntegrationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    endpoint?: SortOrder
    apiKey?: SortOrder
    lastSync?: SortOrder
    healthScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SecurityIntegrationSumOrderByAggregateInput = {
    healthScore?: SortOrder
  }

  export type AdministrativeProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    adminLevel?: SortOrder
    departments?: SortOrder
    responsibilities?: SortOrder
    criticalPermissions?: SortOrder
    emergencyContact?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdministrativeProfileAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type AdministrativeProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    adminLevel?: SortOrder
    emergencyContact?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdministrativeProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    adminLevel?: SortOrder
    emergencyContact?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdministrativeProfileSumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type RoleHierarchyNullableScalarRelationFilter = {
    is?: RoleHierarchyWhereInput | null
    isNot?: RoleHierarchyWhereInput | null
  }

  export type CustomRoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    permissions?: SortOrder
    parentRole?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    parentRole?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomRoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    parentRole?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleHierarchyListRelationFilter = {
    every?: RoleHierarchyWhereInput
    some?: RoleHierarchyWhereInput
    none?: RoleHierarchyWhereInput
  }

  export type CustomRoleScalarRelationFilter = {
    is?: CustomRoleWhereInput
    isNot?: CustomRoleWhereInput
  }

  export type RoleHierarchyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleHierarchyCountOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    parentId?: SortOrder
    level?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleHierarchyAvgOrderByAggregateInput = {
    level?: SortOrder
  }

  export type RoleHierarchyMaxOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    parentId?: SortOrder
    level?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleHierarchyMinOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    parentId?: SortOrder
    level?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleHierarchySumOrderByAggregateInput = {
    level?: SortOrder
  }

  export type PermissionAuditCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    permissionId?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    reason?: SortOrder
    performedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type PermissionAuditAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type PermissionAuditMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    permissionId?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    reason?: SortOrder
    performedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type PermissionAuditMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    permissionId?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    reason?: SortOrder
    performedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type PermissionAuditSumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type AdministrativeProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<AdministrativeProfileCreateWithoutUserInput, AdministrativeProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdministrativeProfileCreateOrConnectWithoutUserInput
    connect?: AdministrativeProfileWhereUniqueInput
  }

  export type PermissionAuditCreateNestedManyWithoutUserInput = {
    create?: XOR<PermissionAuditCreateWithoutUserInput, PermissionAuditUncheckedCreateWithoutUserInput> | PermissionAuditCreateWithoutUserInput[] | PermissionAuditUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PermissionAuditCreateOrConnectWithoutUserInput | PermissionAuditCreateOrConnectWithoutUserInput[]
    createMany?: PermissionAuditCreateManyUserInputEnvelope
    connect?: PermissionAuditWhereUniqueInput | PermissionAuditWhereUniqueInput[]
  }

  export type UserAccessLogCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAccessLogCreateWithoutUserInput, UserAccessLogUncheckedCreateWithoutUserInput> | UserAccessLogCreateWithoutUserInput[] | UserAccessLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAccessLogCreateOrConnectWithoutUserInput | UserAccessLogCreateOrConnectWithoutUserInput[]
    createMany?: UserAccessLogCreateManyUserInputEnvelope
    connect?: UserAccessLogWhereUniqueInput | UserAccessLogWhereUniqueInput[]
  }

  export type UserAddressCreateNestedOneWithoutUserInput = {
    create?: XOR<UserAddressCreateWithoutUserInput, UserAddressUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserAddressCreateOrConnectWithoutUserInput
    connect?: UserAddressWhereUniqueInput
  }

  export type UserEmergencyContactCreateNestedOneWithoutUserInput = {
    create?: XOR<UserEmergencyContactCreateWithoutUserInput, UserEmergencyContactUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserEmergencyContactCreateOrConnectWithoutUserInput
    connect?: UserEmergencyContactWhereUniqueInput
  }

  export type UserIPRestrictionCreateNestedManyWithoutUserInput = {
    create?: XOR<UserIPRestrictionCreateWithoutUserInput, UserIPRestrictionUncheckedCreateWithoutUserInput> | UserIPRestrictionCreateWithoutUserInput[] | UserIPRestrictionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserIPRestrictionCreateOrConnectWithoutUserInput | UserIPRestrictionCreateOrConnectWithoutUserInput[]
    createMany?: UserIPRestrictionCreateManyUserInputEnvelope
    connect?: UserIPRestrictionWhereUniqueInput | UserIPRestrictionWhereUniqueInput[]
  }

  export type UserNotificationSettingsCreateNestedOneWithoutUserInput = {
    create?: XOR<UserNotificationSettingsCreateWithoutUserInput, UserNotificationSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserNotificationSettingsCreateOrConnectWithoutUserInput
    connect?: UserNotificationSettingsWhereUniqueInput
  }

  export type UserPreferencesCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput
    connect?: UserPreferencesWhereUniqueInput
  }

  export type UserPrivacySettingsCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPrivacySettingsCreateWithoutUserInput, UserPrivacySettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPrivacySettingsCreateOrConnectWithoutUserInput
    connect?: UserPrivacySettingsWhereUniqueInput
  }

  export type UserSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type UserSocialMediaCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSocialMediaCreateWithoutUserInput, UserSocialMediaUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSocialMediaCreateOrConnectWithoutUserInput
    connect?: UserSocialMediaWhereUniqueInput
  }

  export type AdministrativeProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AdministrativeProfileCreateWithoutUserInput, AdministrativeProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdministrativeProfileCreateOrConnectWithoutUserInput
    connect?: AdministrativeProfileWhereUniqueInput
  }

  export type PermissionAuditUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PermissionAuditCreateWithoutUserInput, PermissionAuditUncheckedCreateWithoutUserInput> | PermissionAuditCreateWithoutUserInput[] | PermissionAuditUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PermissionAuditCreateOrConnectWithoutUserInput | PermissionAuditCreateOrConnectWithoutUserInput[]
    createMany?: PermissionAuditCreateManyUserInputEnvelope
    connect?: PermissionAuditWhereUniqueInput | PermissionAuditWhereUniqueInput[]
  }

  export type UserAccessLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAccessLogCreateWithoutUserInput, UserAccessLogUncheckedCreateWithoutUserInput> | UserAccessLogCreateWithoutUserInput[] | UserAccessLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAccessLogCreateOrConnectWithoutUserInput | UserAccessLogCreateOrConnectWithoutUserInput[]
    createMany?: UserAccessLogCreateManyUserInputEnvelope
    connect?: UserAccessLogWhereUniqueInput | UserAccessLogWhereUniqueInput[]
  }

  export type UserAddressUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserAddressCreateWithoutUserInput, UserAddressUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserAddressCreateOrConnectWithoutUserInput
    connect?: UserAddressWhereUniqueInput
  }

  export type UserEmergencyContactUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserEmergencyContactCreateWithoutUserInput, UserEmergencyContactUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserEmergencyContactCreateOrConnectWithoutUserInput
    connect?: UserEmergencyContactWhereUniqueInput
  }

  export type UserIPRestrictionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserIPRestrictionCreateWithoutUserInput, UserIPRestrictionUncheckedCreateWithoutUserInput> | UserIPRestrictionCreateWithoutUserInput[] | UserIPRestrictionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserIPRestrictionCreateOrConnectWithoutUserInput | UserIPRestrictionCreateOrConnectWithoutUserInput[]
    createMany?: UserIPRestrictionCreateManyUserInputEnvelope
    connect?: UserIPRestrictionWhereUniqueInput | UserIPRestrictionWhereUniqueInput[]
  }

  export type UserNotificationSettingsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserNotificationSettingsCreateWithoutUserInput, UserNotificationSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserNotificationSettingsCreateOrConnectWithoutUserInput
    connect?: UserNotificationSettingsWhereUniqueInput
  }

  export type UserPreferencesUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput
    connect?: UserPreferencesWhereUniqueInput
  }

  export type UserPrivacySettingsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPrivacySettingsCreateWithoutUserInput, UserPrivacySettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPrivacySettingsCreateOrConnectWithoutUserInput
    connect?: UserPrivacySettingsWhereUniqueInput
  }

  export type UserSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type UserSocialMediaUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSocialMediaCreateWithoutUserInput, UserSocialMediaUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSocialMediaCreateOrConnectWithoutUserInput
    connect?: UserSocialMediaWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type AdministrativeProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdministrativeProfileCreateWithoutUserInput, AdministrativeProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdministrativeProfileCreateOrConnectWithoutUserInput
    upsert?: AdministrativeProfileUpsertWithoutUserInput
    disconnect?: AdministrativeProfileWhereInput | boolean
    delete?: AdministrativeProfileWhereInput | boolean
    connect?: AdministrativeProfileWhereUniqueInput
    update?: XOR<XOR<AdministrativeProfileUpdateToOneWithWhereWithoutUserInput, AdministrativeProfileUpdateWithoutUserInput>, AdministrativeProfileUncheckedUpdateWithoutUserInput>
  }

  export type PermissionAuditUpdateManyWithoutUserNestedInput = {
    create?: XOR<PermissionAuditCreateWithoutUserInput, PermissionAuditUncheckedCreateWithoutUserInput> | PermissionAuditCreateWithoutUserInput[] | PermissionAuditUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PermissionAuditCreateOrConnectWithoutUserInput | PermissionAuditCreateOrConnectWithoutUserInput[]
    upsert?: PermissionAuditUpsertWithWhereUniqueWithoutUserInput | PermissionAuditUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PermissionAuditCreateManyUserInputEnvelope
    set?: PermissionAuditWhereUniqueInput | PermissionAuditWhereUniqueInput[]
    disconnect?: PermissionAuditWhereUniqueInput | PermissionAuditWhereUniqueInput[]
    delete?: PermissionAuditWhereUniqueInput | PermissionAuditWhereUniqueInput[]
    connect?: PermissionAuditWhereUniqueInput | PermissionAuditWhereUniqueInput[]
    update?: PermissionAuditUpdateWithWhereUniqueWithoutUserInput | PermissionAuditUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PermissionAuditUpdateManyWithWhereWithoutUserInput | PermissionAuditUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PermissionAuditScalarWhereInput | PermissionAuditScalarWhereInput[]
  }

  export type UserAccessLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAccessLogCreateWithoutUserInput, UserAccessLogUncheckedCreateWithoutUserInput> | UserAccessLogCreateWithoutUserInput[] | UserAccessLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAccessLogCreateOrConnectWithoutUserInput | UserAccessLogCreateOrConnectWithoutUserInput[]
    upsert?: UserAccessLogUpsertWithWhereUniqueWithoutUserInput | UserAccessLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAccessLogCreateManyUserInputEnvelope
    set?: UserAccessLogWhereUniqueInput | UserAccessLogWhereUniqueInput[]
    disconnect?: UserAccessLogWhereUniqueInput | UserAccessLogWhereUniqueInput[]
    delete?: UserAccessLogWhereUniqueInput | UserAccessLogWhereUniqueInput[]
    connect?: UserAccessLogWhereUniqueInput | UserAccessLogWhereUniqueInput[]
    update?: UserAccessLogUpdateWithWhereUniqueWithoutUserInput | UserAccessLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAccessLogUpdateManyWithWhereWithoutUserInput | UserAccessLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAccessLogScalarWhereInput | UserAccessLogScalarWhereInput[]
  }

  export type UserAddressUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserAddressCreateWithoutUserInput, UserAddressUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserAddressCreateOrConnectWithoutUserInput
    upsert?: UserAddressUpsertWithoutUserInput
    disconnect?: UserAddressWhereInput | boolean
    delete?: UserAddressWhereInput | boolean
    connect?: UserAddressWhereUniqueInput
    update?: XOR<XOR<UserAddressUpdateToOneWithWhereWithoutUserInput, UserAddressUpdateWithoutUserInput>, UserAddressUncheckedUpdateWithoutUserInput>
  }

  export type UserEmergencyContactUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserEmergencyContactCreateWithoutUserInput, UserEmergencyContactUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserEmergencyContactCreateOrConnectWithoutUserInput
    upsert?: UserEmergencyContactUpsertWithoutUserInput
    disconnect?: UserEmergencyContactWhereInput | boolean
    delete?: UserEmergencyContactWhereInput | boolean
    connect?: UserEmergencyContactWhereUniqueInput
    update?: XOR<XOR<UserEmergencyContactUpdateToOneWithWhereWithoutUserInput, UserEmergencyContactUpdateWithoutUserInput>, UserEmergencyContactUncheckedUpdateWithoutUserInput>
  }

  export type UserIPRestrictionUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserIPRestrictionCreateWithoutUserInput, UserIPRestrictionUncheckedCreateWithoutUserInput> | UserIPRestrictionCreateWithoutUserInput[] | UserIPRestrictionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserIPRestrictionCreateOrConnectWithoutUserInput | UserIPRestrictionCreateOrConnectWithoutUserInput[]
    upsert?: UserIPRestrictionUpsertWithWhereUniqueWithoutUserInput | UserIPRestrictionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserIPRestrictionCreateManyUserInputEnvelope
    set?: UserIPRestrictionWhereUniqueInput | UserIPRestrictionWhereUniqueInput[]
    disconnect?: UserIPRestrictionWhereUniqueInput | UserIPRestrictionWhereUniqueInput[]
    delete?: UserIPRestrictionWhereUniqueInput | UserIPRestrictionWhereUniqueInput[]
    connect?: UserIPRestrictionWhereUniqueInput | UserIPRestrictionWhereUniqueInput[]
    update?: UserIPRestrictionUpdateWithWhereUniqueWithoutUserInput | UserIPRestrictionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserIPRestrictionUpdateManyWithWhereWithoutUserInput | UserIPRestrictionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserIPRestrictionScalarWhereInput | UserIPRestrictionScalarWhereInput[]
  }

  export type UserNotificationSettingsUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserNotificationSettingsCreateWithoutUserInput, UserNotificationSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserNotificationSettingsCreateOrConnectWithoutUserInput
    upsert?: UserNotificationSettingsUpsertWithoutUserInput
    disconnect?: UserNotificationSettingsWhereInput | boolean
    delete?: UserNotificationSettingsWhereInput | boolean
    connect?: UserNotificationSettingsWhereUniqueInput
    update?: XOR<XOR<UserNotificationSettingsUpdateToOneWithWhereWithoutUserInput, UserNotificationSettingsUpdateWithoutUserInput>, UserNotificationSettingsUncheckedUpdateWithoutUserInput>
  }

  export type UserPreferencesUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput
    upsert?: UserPreferencesUpsertWithoutUserInput
    disconnect?: UserPreferencesWhereInput | boolean
    delete?: UserPreferencesWhereInput | boolean
    connect?: UserPreferencesWhereUniqueInput
    update?: XOR<XOR<UserPreferencesUpdateToOneWithWhereWithoutUserInput, UserPreferencesUpdateWithoutUserInput>, UserPreferencesUncheckedUpdateWithoutUserInput>
  }

  export type UserPrivacySettingsUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPrivacySettingsCreateWithoutUserInput, UserPrivacySettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPrivacySettingsCreateOrConnectWithoutUserInput
    upsert?: UserPrivacySettingsUpsertWithoutUserInput
    disconnect?: UserPrivacySettingsWhereInput | boolean
    delete?: UserPrivacySettingsWhereInput | boolean
    connect?: UserPrivacySettingsWhereUniqueInput
    update?: XOR<XOR<UserPrivacySettingsUpdateToOneWithWhereWithoutUserInput, UserPrivacySettingsUpdateWithoutUserInput>, UserPrivacySettingsUncheckedUpdateWithoutUserInput>
  }

  export type UserSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type UserSocialMediaUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSocialMediaCreateWithoutUserInput, UserSocialMediaUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSocialMediaCreateOrConnectWithoutUserInput
    upsert?: UserSocialMediaUpsertWithoutUserInput
    disconnect?: UserSocialMediaWhereInput | boolean
    delete?: UserSocialMediaWhereInput | boolean
    connect?: UserSocialMediaWhereUniqueInput
    update?: XOR<XOR<UserSocialMediaUpdateToOneWithWhereWithoutUserInput, UserSocialMediaUpdateWithoutUserInput>, UserSocialMediaUncheckedUpdateWithoutUserInput>
  }

  export type AdministrativeProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdministrativeProfileCreateWithoutUserInput, AdministrativeProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdministrativeProfileCreateOrConnectWithoutUserInput
    upsert?: AdministrativeProfileUpsertWithoutUserInput
    disconnect?: AdministrativeProfileWhereInput | boolean
    delete?: AdministrativeProfileWhereInput | boolean
    connect?: AdministrativeProfileWhereUniqueInput
    update?: XOR<XOR<AdministrativeProfileUpdateToOneWithWhereWithoutUserInput, AdministrativeProfileUpdateWithoutUserInput>, AdministrativeProfileUncheckedUpdateWithoutUserInput>
  }

  export type PermissionAuditUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PermissionAuditCreateWithoutUserInput, PermissionAuditUncheckedCreateWithoutUserInput> | PermissionAuditCreateWithoutUserInput[] | PermissionAuditUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PermissionAuditCreateOrConnectWithoutUserInput | PermissionAuditCreateOrConnectWithoutUserInput[]
    upsert?: PermissionAuditUpsertWithWhereUniqueWithoutUserInput | PermissionAuditUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PermissionAuditCreateManyUserInputEnvelope
    set?: PermissionAuditWhereUniqueInput | PermissionAuditWhereUniqueInput[]
    disconnect?: PermissionAuditWhereUniqueInput | PermissionAuditWhereUniqueInput[]
    delete?: PermissionAuditWhereUniqueInput | PermissionAuditWhereUniqueInput[]
    connect?: PermissionAuditWhereUniqueInput | PermissionAuditWhereUniqueInput[]
    update?: PermissionAuditUpdateWithWhereUniqueWithoutUserInput | PermissionAuditUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PermissionAuditUpdateManyWithWhereWithoutUserInput | PermissionAuditUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PermissionAuditScalarWhereInput | PermissionAuditScalarWhereInput[]
  }

  export type UserAccessLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAccessLogCreateWithoutUserInput, UserAccessLogUncheckedCreateWithoutUserInput> | UserAccessLogCreateWithoutUserInput[] | UserAccessLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAccessLogCreateOrConnectWithoutUserInput | UserAccessLogCreateOrConnectWithoutUserInput[]
    upsert?: UserAccessLogUpsertWithWhereUniqueWithoutUserInput | UserAccessLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAccessLogCreateManyUserInputEnvelope
    set?: UserAccessLogWhereUniqueInput | UserAccessLogWhereUniqueInput[]
    disconnect?: UserAccessLogWhereUniqueInput | UserAccessLogWhereUniqueInput[]
    delete?: UserAccessLogWhereUniqueInput | UserAccessLogWhereUniqueInput[]
    connect?: UserAccessLogWhereUniqueInput | UserAccessLogWhereUniqueInput[]
    update?: UserAccessLogUpdateWithWhereUniqueWithoutUserInput | UserAccessLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAccessLogUpdateManyWithWhereWithoutUserInput | UserAccessLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAccessLogScalarWhereInput | UserAccessLogScalarWhereInput[]
  }

  export type UserAddressUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserAddressCreateWithoutUserInput, UserAddressUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserAddressCreateOrConnectWithoutUserInput
    upsert?: UserAddressUpsertWithoutUserInput
    disconnect?: UserAddressWhereInput | boolean
    delete?: UserAddressWhereInput | boolean
    connect?: UserAddressWhereUniqueInput
    update?: XOR<XOR<UserAddressUpdateToOneWithWhereWithoutUserInput, UserAddressUpdateWithoutUserInput>, UserAddressUncheckedUpdateWithoutUserInput>
  }

  export type UserEmergencyContactUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserEmergencyContactCreateWithoutUserInput, UserEmergencyContactUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserEmergencyContactCreateOrConnectWithoutUserInput
    upsert?: UserEmergencyContactUpsertWithoutUserInput
    disconnect?: UserEmergencyContactWhereInput | boolean
    delete?: UserEmergencyContactWhereInput | boolean
    connect?: UserEmergencyContactWhereUniqueInput
    update?: XOR<XOR<UserEmergencyContactUpdateToOneWithWhereWithoutUserInput, UserEmergencyContactUpdateWithoutUserInput>, UserEmergencyContactUncheckedUpdateWithoutUserInput>
  }

  export type UserIPRestrictionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserIPRestrictionCreateWithoutUserInput, UserIPRestrictionUncheckedCreateWithoutUserInput> | UserIPRestrictionCreateWithoutUserInput[] | UserIPRestrictionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserIPRestrictionCreateOrConnectWithoutUserInput | UserIPRestrictionCreateOrConnectWithoutUserInput[]
    upsert?: UserIPRestrictionUpsertWithWhereUniqueWithoutUserInput | UserIPRestrictionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserIPRestrictionCreateManyUserInputEnvelope
    set?: UserIPRestrictionWhereUniqueInput | UserIPRestrictionWhereUniqueInput[]
    disconnect?: UserIPRestrictionWhereUniqueInput | UserIPRestrictionWhereUniqueInput[]
    delete?: UserIPRestrictionWhereUniqueInput | UserIPRestrictionWhereUniqueInput[]
    connect?: UserIPRestrictionWhereUniqueInput | UserIPRestrictionWhereUniqueInput[]
    update?: UserIPRestrictionUpdateWithWhereUniqueWithoutUserInput | UserIPRestrictionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserIPRestrictionUpdateManyWithWhereWithoutUserInput | UserIPRestrictionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserIPRestrictionScalarWhereInput | UserIPRestrictionScalarWhereInput[]
  }

  export type UserNotificationSettingsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserNotificationSettingsCreateWithoutUserInput, UserNotificationSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserNotificationSettingsCreateOrConnectWithoutUserInput
    upsert?: UserNotificationSettingsUpsertWithoutUserInput
    disconnect?: UserNotificationSettingsWhereInput | boolean
    delete?: UserNotificationSettingsWhereInput | boolean
    connect?: UserNotificationSettingsWhereUniqueInput
    update?: XOR<XOR<UserNotificationSettingsUpdateToOneWithWhereWithoutUserInput, UserNotificationSettingsUpdateWithoutUserInput>, UserNotificationSettingsUncheckedUpdateWithoutUserInput>
  }

  export type UserPreferencesUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput
    upsert?: UserPreferencesUpsertWithoutUserInput
    disconnect?: UserPreferencesWhereInput | boolean
    delete?: UserPreferencesWhereInput | boolean
    connect?: UserPreferencesWhereUniqueInput
    update?: XOR<XOR<UserPreferencesUpdateToOneWithWhereWithoutUserInput, UserPreferencesUpdateWithoutUserInput>, UserPreferencesUncheckedUpdateWithoutUserInput>
  }

  export type UserPrivacySettingsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPrivacySettingsCreateWithoutUserInput, UserPrivacySettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPrivacySettingsCreateOrConnectWithoutUserInput
    upsert?: UserPrivacySettingsUpsertWithoutUserInput
    disconnect?: UserPrivacySettingsWhereInput | boolean
    delete?: UserPrivacySettingsWhereInput | boolean
    connect?: UserPrivacySettingsWhereUniqueInput
    update?: XOR<XOR<UserPrivacySettingsUpdateToOneWithWhereWithoutUserInput, UserPrivacySettingsUpdateWithoutUserInput>, UserPrivacySettingsUncheckedUpdateWithoutUserInput>
  }

  export type UserSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type UserSocialMediaUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSocialMediaCreateWithoutUserInput, UserSocialMediaUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSocialMediaCreateOrConnectWithoutUserInput
    upsert?: UserSocialMediaUpsertWithoutUserInput
    disconnect?: UserSocialMediaWhereInput | boolean
    delete?: UserSocialMediaWhereInput | boolean
    connect?: UserSocialMediaWhereUniqueInput
    update?: XOR<XOR<UserSocialMediaUpdateToOneWithWhereWithoutUserInput, UserSocialMediaUpdateWithoutUserInput>, UserSocialMediaUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutAccess_logsInput = {
    create?: XOR<UserCreateWithoutAccess_logsInput, UserUncheckedCreateWithoutAccess_logsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccess_logsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccess_logsNestedInput = {
    create?: XOR<UserCreateWithoutAccess_logsInput, UserUncheckedCreateWithoutAccess_logsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccess_logsInput
    upsert?: UserUpsertWithoutAccess_logsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccess_logsInput, UserUpdateWithoutAccess_logsInput>, UserUncheckedUpdateWithoutAccess_logsInput>
  }

  export type UserCreateNestedOneWithoutIp_restrictionsInput = {
    create?: XOR<UserCreateWithoutIp_restrictionsInput, UserUncheckedCreateWithoutIp_restrictionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutIp_restrictionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutIp_restrictionsNestedInput = {
    create?: XOR<UserCreateWithoutIp_restrictionsInput, UserUncheckedCreateWithoutIp_restrictionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutIp_restrictionsInput
    upsert?: UserUpsertWithoutIp_restrictionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutIp_restrictionsInput, UserUpdateWithoutIp_restrictionsInput>, UserUncheckedUpdateWithoutIp_restrictionsInput>
  }

  export type UserCreateNestedOneWithoutAddressInput = {
    create?: XOR<UserCreateWithoutAddressInput, UserUncheckedCreateWithoutAddressInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddressInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAddressNestedInput = {
    create?: XOR<UserCreateWithoutAddressInput, UserUncheckedCreateWithoutAddressInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddressInput
    upsert?: UserUpsertWithoutAddressInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAddressInput, UserUpdateWithoutAddressInput>, UserUncheckedUpdateWithoutAddressInput>
  }

  export type UserCreateNestedOneWithoutEmergency_contactInput = {
    create?: XOR<UserCreateWithoutEmergency_contactInput, UserUncheckedCreateWithoutEmergency_contactInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmergency_contactInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutEmergency_contactNestedInput = {
    create?: XOR<UserCreateWithoutEmergency_contactInput, UserUncheckedCreateWithoutEmergency_contactInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmergency_contactInput
    upsert?: UserUpsertWithoutEmergency_contactInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmergency_contactInput, UserUpdateWithoutEmergency_contactInput>, UserUncheckedUpdateWithoutEmergency_contactInput>
  }

  export type UserCreateNestedOneWithoutSocial_mediaInput = {
    create?: XOR<UserCreateWithoutSocial_mediaInput, UserUncheckedCreateWithoutSocial_mediaInput>
    connectOrCreate?: UserCreateOrConnectWithoutSocial_mediaInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSocial_mediaNestedInput = {
    create?: XOR<UserCreateWithoutSocial_mediaInput, UserUncheckedCreateWithoutSocial_mediaInput>
    connectOrCreate?: UserCreateOrConnectWithoutSocial_mediaInput
    upsert?: UserUpsertWithoutSocial_mediaInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSocial_mediaInput, UserUpdateWithoutSocial_mediaInput>, UserUncheckedUpdateWithoutSocial_mediaInput>
  }

  export type UserCreateNestedOneWithoutPreferencesInput = {
    create?: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPreferencesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPreferencesNestedInput = {
    create?: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPreferencesInput
    upsert?: UserUpsertWithoutPreferencesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPreferencesInput, UserUpdateWithoutPreferencesInput>, UserUncheckedUpdateWithoutPreferencesInput>
  }

  export type UserCreateNestedOneWithoutNotification_settingsInput = {
    create?: XOR<UserCreateWithoutNotification_settingsInput, UserUncheckedCreateWithoutNotification_settingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotification_settingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotification_settingsNestedInput = {
    create?: XOR<UserCreateWithoutNotification_settingsInput, UserUncheckedCreateWithoutNotification_settingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotification_settingsInput
    upsert?: UserUpsertWithoutNotification_settingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotification_settingsInput, UserUpdateWithoutNotification_settingsInput>, UserUncheckedUpdateWithoutNotification_settingsInput>
  }

  export type UserCreateNestedOneWithoutPrivacy_settingsInput = {
    create?: XOR<UserCreateWithoutPrivacy_settingsInput, UserUncheckedCreateWithoutPrivacy_settingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPrivacy_settingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPrivacy_settingsNestedInput = {
    create?: XOR<UserCreateWithoutPrivacy_settingsInput, UserUncheckedCreateWithoutPrivacy_settingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPrivacy_settingsInput
    upsert?: UserUpsertWithoutPrivacy_settingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPrivacy_settingsInput, UserUpdateWithoutPrivacy_settingsInput>, UserUncheckedUpdateWithoutPrivacy_settingsInput>
  }

  export type AddressCreateNestedOneWithoutMemberInput = {
    create?: XOR<AddressCreateWithoutMemberInput, AddressUncheckedCreateWithoutMemberInput>
    connectOrCreate?: AddressCreateOrConnectWithoutMemberInput
    connect?: AddressWhereUniqueInput
  }

  export type EmergencyContactCreateNestedOneWithoutMemberInput = {
    create?: XOR<EmergencyContactCreateWithoutMemberInput, EmergencyContactUncheckedCreateWithoutMemberInput>
    connectOrCreate?: EmergencyContactCreateOrConnectWithoutMemberInput
    connect?: EmergencyContactWhereUniqueInput
  }

  export type InvoiceCreateNestedManyWithoutMemberInput = {
    create?: XOR<InvoiceCreateWithoutMemberInput, InvoiceUncheckedCreateWithoutMemberInput> | InvoiceCreateWithoutMemberInput[] | InvoiceUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutMemberInput | InvoiceCreateOrConnectWithoutMemberInput[]
    createMany?: InvoiceCreateManyMemberInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type MedicalInfoCreateNestedOneWithoutMemberInput = {
    create?: XOR<MedicalInfoCreateWithoutMemberInput, MedicalInfoUncheckedCreateWithoutMemberInput>
    connectOrCreate?: MedicalInfoCreateOrConnectWithoutMemberInput
    connect?: MedicalInfoWhereUniqueInput
  }

  export type MemberAttendanceCreateNestedManyWithoutMemberInput = {
    create?: XOR<MemberAttendanceCreateWithoutMemberInput, MemberAttendanceUncheckedCreateWithoutMemberInput> | MemberAttendanceCreateWithoutMemberInput[] | MemberAttendanceUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberAttendanceCreateOrConnectWithoutMemberInput | MemberAttendanceCreateOrConnectWithoutMemberInput[]
    createMany?: MemberAttendanceCreateManyMemberInputEnvelope
    connect?: MemberAttendanceWhereUniqueInput | MemberAttendanceWhereUniqueInput[]
  }

  export type MemberCheckInCreateNestedManyWithoutMemberInput = {
    create?: XOR<MemberCheckInCreateWithoutMemberInput, MemberCheckInUncheckedCreateWithoutMemberInput> | MemberCheckInCreateWithoutMemberInput[] | MemberCheckInUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberCheckInCreateOrConnectWithoutMemberInput | MemberCheckInCreateOrConnectWithoutMemberInput[]
    createMany?: MemberCheckInCreateManyMemberInputEnvelope
    connect?: MemberCheckInWhereUniqueInput | MemberCheckInWhereUniqueInput[]
  }

  export type MemberFitnessGoalCreateNestedManyWithoutMemberInput = {
    create?: XOR<MemberFitnessGoalCreateWithoutMemberInput, MemberFitnessGoalUncheckedCreateWithoutMemberInput> | MemberFitnessGoalCreateWithoutMemberInput[] | MemberFitnessGoalUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberFitnessGoalCreateOrConnectWithoutMemberInput | MemberFitnessGoalCreateOrConnectWithoutMemberInput[]
    createMany?: MemberFitnessGoalCreateManyMemberInputEnvelope
    connect?: MemberFitnessGoalWhereUniqueInput | MemberFitnessGoalWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutMemberInput = {
    create?: XOR<PaymentCreateWithoutMemberInput, PaymentUncheckedCreateWithoutMemberInput> | PaymentCreateWithoutMemberInput[] | PaymentUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutMemberInput | PaymentCreateOrConnectWithoutMemberInput[]
    createMany?: PaymentCreateManyMemberInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedManyWithoutMemberInput = {
    create?: XOR<SubscriptionCreateWithoutMemberInput, SubscriptionUncheckedCreateWithoutMemberInput> | SubscriptionCreateWithoutMemberInput[] | SubscriptionUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutMemberInput | SubscriptionCreateOrConnectWithoutMemberInput[]
    createMany?: SubscriptionCreateManyMemberInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type AddressUncheckedCreateNestedOneWithoutMemberInput = {
    create?: XOR<AddressCreateWithoutMemberInput, AddressUncheckedCreateWithoutMemberInput>
    connectOrCreate?: AddressCreateOrConnectWithoutMemberInput
    connect?: AddressWhereUniqueInput
  }

  export type EmergencyContactUncheckedCreateNestedOneWithoutMemberInput = {
    create?: XOR<EmergencyContactCreateWithoutMemberInput, EmergencyContactUncheckedCreateWithoutMemberInput>
    connectOrCreate?: EmergencyContactCreateOrConnectWithoutMemberInput
    connect?: EmergencyContactWhereUniqueInput
  }

  export type InvoiceUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<InvoiceCreateWithoutMemberInput, InvoiceUncheckedCreateWithoutMemberInput> | InvoiceCreateWithoutMemberInput[] | InvoiceUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutMemberInput | InvoiceCreateOrConnectWithoutMemberInput[]
    createMany?: InvoiceCreateManyMemberInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type MedicalInfoUncheckedCreateNestedOneWithoutMemberInput = {
    create?: XOR<MedicalInfoCreateWithoutMemberInput, MedicalInfoUncheckedCreateWithoutMemberInput>
    connectOrCreate?: MedicalInfoCreateOrConnectWithoutMemberInput
    connect?: MedicalInfoWhereUniqueInput
  }

  export type MemberAttendanceUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<MemberAttendanceCreateWithoutMemberInput, MemberAttendanceUncheckedCreateWithoutMemberInput> | MemberAttendanceCreateWithoutMemberInput[] | MemberAttendanceUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberAttendanceCreateOrConnectWithoutMemberInput | MemberAttendanceCreateOrConnectWithoutMemberInput[]
    createMany?: MemberAttendanceCreateManyMemberInputEnvelope
    connect?: MemberAttendanceWhereUniqueInput | MemberAttendanceWhereUniqueInput[]
  }

  export type MemberCheckInUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<MemberCheckInCreateWithoutMemberInput, MemberCheckInUncheckedCreateWithoutMemberInput> | MemberCheckInCreateWithoutMemberInput[] | MemberCheckInUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberCheckInCreateOrConnectWithoutMemberInput | MemberCheckInCreateOrConnectWithoutMemberInput[]
    createMany?: MemberCheckInCreateManyMemberInputEnvelope
    connect?: MemberCheckInWhereUniqueInput | MemberCheckInWhereUniqueInput[]
  }

  export type MemberFitnessGoalUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<MemberFitnessGoalCreateWithoutMemberInput, MemberFitnessGoalUncheckedCreateWithoutMemberInput> | MemberFitnessGoalCreateWithoutMemberInput[] | MemberFitnessGoalUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberFitnessGoalCreateOrConnectWithoutMemberInput | MemberFitnessGoalCreateOrConnectWithoutMemberInput[]
    createMany?: MemberFitnessGoalCreateManyMemberInputEnvelope
    connect?: MemberFitnessGoalWhereUniqueInput | MemberFitnessGoalWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<PaymentCreateWithoutMemberInput, PaymentUncheckedCreateWithoutMemberInput> | PaymentCreateWithoutMemberInput[] | PaymentUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutMemberInput | PaymentCreateOrConnectWithoutMemberInput[]
    createMany?: PaymentCreateManyMemberInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<SubscriptionCreateWithoutMemberInput, SubscriptionUncheckedCreateWithoutMemberInput> | SubscriptionCreateWithoutMemberInput[] | SubscriptionUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutMemberInput | SubscriptionCreateOrConnectWithoutMemberInput[]
    createMany?: SubscriptionCreateManyMemberInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type EnumMemberShipTypeFieldUpdateOperationsInput = {
    set?: $Enums.MemberShipType
  }

  export type AddressUpdateOneWithoutMemberNestedInput = {
    create?: XOR<AddressCreateWithoutMemberInput, AddressUncheckedCreateWithoutMemberInput>
    connectOrCreate?: AddressCreateOrConnectWithoutMemberInput
    upsert?: AddressUpsertWithoutMemberInput
    disconnect?: AddressWhereInput | boolean
    delete?: AddressWhereInput | boolean
    connect?: AddressWhereUniqueInput
    update?: XOR<XOR<AddressUpdateToOneWithWhereWithoutMemberInput, AddressUpdateWithoutMemberInput>, AddressUncheckedUpdateWithoutMemberInput>
  }

  export type EmergencyContactUpdateOneWithoutMemberNestedInput = {
    create?: XOR<EmergencyContactCreateWithoutMemberInput, EmergencyContactUncheckedCreateWithoutMemberInput>
    connectOrCreate?: EmergencyContactCreateOrConnectWithoutMemberInput
    upsert?: EmergencyContactUpsertWithoutMemberInput
    disconnect?: EmergencyContactWhereInput | boolean
    delete?: EmergencyContactWhereInput | boolean
    connect?: EmergencyContactWhereUniqueInput
    update?: XOR<XOR<EmergencyContactUpdateToOneWithWhereWithoutMemberInput, EmergencyContactUpdateWithoutMemberInput>, EmergencyContactUncheckedUpdateWithoutMemberInput>
  }

  export type InvoiceUpdateManyWithoutMemberNestedInput = {
    create?: XOR<InvoiceCreateWithoutMemberInput, InvoiceUncheckedCreateWithoutMemberInput> | InvoiceCreateWithoutMemberInput[] | InvoiceUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutMemberInput | InvoiceCreateOrConnectWithoutMemberInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutMemberInput | InvoiceUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: InvoiceCreateManyMemberInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutMemberInput | InvoiceUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutMemberInput | InvoiceUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type MedicalInfoUpdateOneWithoutMemberNestedInput = {
    create?: XOR<MedicalInfoCreateWithoutMemberInput, MedicalInfoUncheckedCreateWithoutMemberInput>
    connectOrCreate?: MedicalInfoCreateOrConnectWithoutMemberInput
    upsert?: MedicalInfoUpsertWithoutMemberInput
    disconnect?: MedicalInfoWhereInput | boolean
    delete?: MedicalInfoWhereInput | boolean
    connect?: MedicalInfoWhereUniqueInput
    update?: XOR<XOR<MedicalInfoUpdateToOneWithWhereWithoutMemberInput, MedicalInfoUpdateWithoutMemberInput>, MedicalInfoUncheckedUpdateWithoutMemberInput>
  }

  export type MemberAttendanceUpdateManyWithoutMemberNestedInput = {
    create?: XOR<MemberAttendanceCreateWithoutMemberInput, MemberAttendanceUncheckedCreateWithoutMemberInput> | MemberAttendanceCreateWithoutMemberInput[] | MemberAttendanceUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberAttendanceCreateOrConnectWithoutMemberInput | MemberAttendanceCreateOrConnectWithoutMemberInput[]
    upsert?: MemberAttendanceUpsertWithWhereUniqueWithoutMemberInput | MemberAttendanceUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: MemberAttendanceCreateManyMemberInputEnvelope
    set?: MemberAttendanceWhereUniqueInput | MemberAttendanceWhereUniqueInput[]
    disconnect?: MemberAttendanceWhereUniqueInput | MemberAttendanceWhereUniqueInput[]
    delete?: MemberAttendanceWhereUniqueInput | MemberAttendanceWhereUniqueInput[]
    connect?: MemberAttendanceWhereUniqueInput | MemberAttendanceWhereUniqueInput[]
    update?: MemberAttendanceUpdateWithWhereUniqueWithoutMemberInput | MemberAttendanceUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: MemberAttendanceUpdateManyWithWhereWithoutMemberInput | MemberAttendanceUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: MemberAttendanceScalarWhereInput | MemberAttendanceScalarWhereInput[]
  }

  export type MemberCheckInUpdateManyWithoutMemberNestedInput = {
    create?: XOR<MemberCheckInCreateWithoutMemberInput, MemberCheckInUncheckedCreateWithoutMemberInput> | MemberCheckInCreateWithoutMemberInput[] | MemberCheckInUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberCheckInCreateOrConnectWithoutMemberInput | MemberCheckInCreateOrConnectWithoutMemberInput[]
    upsert?: MemberCheckInUpsertWithWhereUniqueWithoutMemberInput | MemberCheckInUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: MemberCheckInCreateManyMemberInputEnvelope
    set?: MemberCheckInWhereUniqueInput | MemberCheckInWhereUniqueInput[]
    disconnect?: MemberCheckInWhereUniqueInput | MemberCheckInWhereUniqueInput[]
    delete?: MemberCheckInWhereUniqueInput | MemberCheckInWhereUniqueInput[]
    connect?: MemberCheckInWhereUniqueInput | MemberCheckInWhereUniqueInput[]
    update?: MemberCheckInUpdateWithWhereUniqueWithoutMemberInput | MemberCheckInUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: MemberCheckInUpdateManyWithWhereWithoutMemberInput | MemberCheckInUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: MemberCheckInScalarWhereInput | MemberCheckInScalarWhereInput[]
  }

  export type MemberFitnessGoalUpdateManyWithoutMemberNestedInput = {
    create?: XOR<MemberFitnessGoalCreateWithoutMemberInput, MemberFitnessGoalUncheckedCreateWithoutMemberInput> | MemberFitnessGoalCreateWithoutMemberInput[] | MemberFitnessGoalUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberFitnessGoalCreateOrConnectWithoutMemberInput | MemberFitnessGoalCreateOrConnectWithoutMemberInput[]
    upsert?: MemberFitnessGoalUpsertWithWhereUniqueWithoutMemberInput | MemberFitnessGoalUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: MemberFitnessGoalCreateManyMemberInputEnvelope
    set?: MemberFitnessGoalWhereUniqueInput | MemberFitnessGoalWhereUniqueInput[]
    disconnect?: MemberFitnessGoalWhereUniqueInput | MemberFitnessGoalWhereUniqueInput[]
    delete?: MemberFitnessGoalWhereUniqueInput | MemberFitnessGoalWhereUniqueInput[]
    connect?: MemberFitnessGoalWhereUniqueInput | MemberFitnessGoalWhereUniqueInput[]
    update?: MemberFitnessGoalUpdateWithWhereUniqueWithoutMemberInput | MemberFitnessGoalUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: MemberFitnessGoalUpdateManyWithWhereWithoutMemberInput | MemberFitnessGoalUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: MemberFitnessGoalScalarWhereInput | MemberFitnessGoalScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutMemberNestedInput = {
    create?: XOR<PaymentCreateWithoutMemberInput, PaymentUncheckedCreateWithoutMemberInput> | PaymentCreateWithoutMemberInput[] | PaymentUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutMemberInput | PaymentCreateOrConnectWithoutMemberInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutMemberInput | PaymentUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: PaymentCreateManyMemberInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutMemberInput | PaymentUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutMemberInput | PaymentUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type SubscriptionUpdateManyWithoutMemberNestedInput = {
    create?: XOR<SubscriptionCreateWithoutMemberInput, SubscriptionUncheckedCreateWithoutMemberInput> | SubscriptionCreateWithoutMemberInput[] | SubscriptionUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutMemberInput | SubscriptionCreateOrConnectWithoutMemberInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutMemberInput | SubscriptionUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: SubscriptionCreateManyMemberInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutMemberInput | SubscriptionUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutMemberInput | SubscriptionUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type AddressUncheckedUpdateOneWithoutMemberNestedInput = {
    create?: XOR<AddressCreateWithoutMemberInput, AddressUncheckedCreateWithoutMemberInput>
    connectOrCreate?: AddressCreateOrConnectWithoutMemberInput
    upsert?: AddressUpsertWithoutMemberInput
    disconnect?: AddressWhereInput | boolean
    delete?: AddressWhereInput | boolean
    connect?: AddressWhereUniqueInput
    update?: XOR<XOR<AddressUpdateToOneWithWhereWithoutMemberInput, AddressUpdateWithoutMemberInput>, AddressUncheckedUpdateWithoutMemberInput>
  }

  export type EmergencyContactUncheckedUpdateOneWithoutMemberNestedInput = {
    create?: XOR<EmergencyContactCreateWithoutMemberInput, EmergencyContactUncheckedCreateWithoutMemberInput>
    connectOrCreate?: EmergencyContactCreateOrConnectWithoutMemberInput
    upsert?: EmergencyContactUpsertWithoutMemberInput
    disconnect?: EmergencyContactWhereInput | boolean
    delete?: EmergencyContactWhereInput | boolean
    connect?: EmergencyContactWhereUniqueInput
    update?: XOR<XOR<EmergencyContactUpdateToOneWithWhereWithoutMemberInput, EmergencyContactUpdateWithoutMemberInput>, EmergencyContactUncheckedUpdateWithoutMemberInput>
  }

  export type InvoiceUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<InvoiceCreateWithoutMemberInput, InvoiceUncheckedCreateWithoutMemberInput> | InvoiceCreateWithoutMemberInput[] | InvoiceUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutMemberInput | InvoiceCreateOrConnectWithoutMemberInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutMemberInput | InvoiceUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: InvoiceCreateManyMemberInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutMemberInput | InvoiceUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutMemberInput | InvoiceUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type MedicalInfoUncheckedUpdateOneWithoutMemberNestedInput = {
    create?: XOR<MedicalInfoCreateWithoutMemberInput, MedicalInfoUncheckedCreateWithoutMemberInput>
    connectOrCreate?: MedicalInfoCreateOrConnectWithoutMemberInput
    upsert?: MedicalInfoUpsertWithoutMemberInput
    disconnect?: MedicalInfoWhereInput | boolean
    delete?: MedicalInfoWhereInput | boolean
    connect?: MedicalInfoWhereUniqueInput
    update?: XOR<XOR<MedicalInfoUpdateToOneWithWhereWithoutMemberInput, MedicalInfoUpdateWithoutMemberInput>, MedicalInfoUncheckedUpdateWithoutMemberInput>
  }

  export type MemberAttendanceUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<MemberAttendanceCreateWithoutMemberInput, MemberAttendanceUncheckedCreateWithoutMemberInput> | MemberAttendanceCreateWithoutMemberInput[] | MemberAttendanceUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberAttendanceCreateOrConnectWithoutMemberInput | MemberAttendanceCreateOrConnectWithoutMemberInput[]
    upsert?: MemberAttendanceUpsertWithWhereUniqueWithoutMemberInput | MemberAttendanceUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: MemberAttendanceCreateManyMemberInputEnvelope
    set?: MemberAttendanceWhereUniqueInput | MemberAttendanceWhereUniqueInput[]
    disconnect?: MemberAttendanceWhereUniqueInput | MemberAttendanceWhereUniqueInput[]
    delete?: MemberAttendanceWhereUniqueInput | MemberAttendanceWhereUniqueInput[]
    connect?: MemberAttendanceWhereUniqueInput | MemberAttendanceWhereUniqueInput[]
    update?: MemberAttendanceUpdateWithWhereUniqueWithoutMemberInput | MemberAttendanceUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: MemberAttendanceUpdateManyWithWhereWithoutMemberInput | MemberAttendanceUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: MemberAttendanceScalarWhereInput | MemberAttendanceScalarWhereInput[]
  }

  export type MemberCheckInUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<MemberCheckInCreateWithoutMemberInput, MemberCheckInUncheckedCreateWithoutMemberInput> | MemberCheckInCreateWithoutMemberInput[] | MemberCheckInUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberCheckInCreateOrConnectWithoutMemberInput | MemberCheckInCreateOrConnectWithoutMemberInput[]
    upsert?: MemberCheckInUpsertWithWhereUniqueWithoutMemberInput | MemberCheckInUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: MemberCheckInCreateManyMemberInputEnvelope
    set?: MemberCheckInWhereUniqueInput | MemberCheckInWhereUniqueInput[]
    disconnect?: MemberCheckInWhereUniqueInput | MemberCheckInWhereUniqueInput[]
    delete?: MemberCheckInWhereUniqueInput | MemberCheckInWhereUniqueInput[]
    connect?: MemberCheckInWhereUniqueInput | MemberCheckInWhereUniqueInput[]
    update?: MemberCheckInUpdateWithWhereUniqueWithoutMemberInput | MemberCheckInUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: MemberCheckInUpdateManyWithWhereWithoutMemberInput | MemberCheckInUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: MemberCheckInScalarWhereInput | MemberCheckInScalarWhereInput[]
  }

  export type MemberFitnessGoalUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<MemberFitnessGoalCreateWithoutMemberInput, MemberFitnessGoalUncheckedCreateWithoutMemberInput> | MemberFitnessGoalCreateWithoutMemberInput[] | MemberFitnessGoalUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberFitnessGoalCreateOrConnectWithoutMemberInput | MemberFitnessGoalCreateOrConnectWithoutMemberInput[]
    upsert?: MemberFitnessGoalUpsertWithWhereUniqueWithoutMemberInput | MemberFitnessGoalUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: MemberFitnessGoalCreateManyMemberInputEnvelope
    set?: MemberFitnessGoalWhereUniqueInput | MemberFitnessGoalWhereUniqueInput[]
    disconnect?: MemberFitnessGoalWhereUniqueInput | MemberFitnessGoalWhereUniqueInput[]
    delete?: MemberFitnessGoalWhereUniqueInput | MemberFitnessGoalWhereUniqueInput[]
    connect?: MemberFitnessGoalWhereUniqueInput | MemberFitnessGoalWhereUniqueInput[]
    update?: MemberFitnessGoalUpdateWithWhereUniqueWithoutMemberInput | MemberFitnessGoalUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: MemberFitnessGoalUpdateManyWithWhereWithoutMemberInput | MemberFitnessGoalUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: MemberFitnessGoalScalarWhereInput | MemberFitnessGoalScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<PaymentCreateWithoutMemberInput, PaymentUncheckedCreateWithoutMemberInput> | PaymentCreateWithoutMemberInput[] | PaymentUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutMemberInput | PaymentCreateOrConnectWithoutMemberInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutMemberInput | PaymentUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: PaymentCreateManyMemberInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutMemberInput | PaymentUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutMemberInput | PaymentUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<SubscriptionCreateWithoutMemberInput, SubscriptionUncheckedCreateWithoutMemberInput> | SubscriptionCreateWithoutMemberInput[] | SubscriptionUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutMemberInput | SubscriptionCreateOrConnectWithoutMemberInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutMemberInput | SubscriptionUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: SubscriptionCreateManyMemberInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutMemberInput | SubscriptionUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutMemberInput | SubscriptionUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type MemberCreateNestedOneWithoutCheck_insInput = {
    create?: XOR<MemberCreateWithoutCheck_insInput, MemberUncheckedCreateWithoutCheck_insInput>
    connectOrCreate?: MemberCreateOrConnectWithoutCheck_insInput
    connect?: MemberWhereUniqueInput
  }

  export type MemberUpdateOneRequiredWithoutCheck_insNestedInput = {
    create?: XOR<MemberCreateWithoutCheck_insInput, MemberUncheckedCreateWithoutCheck_insInput>
    connectOrCreate?: MemberCreateOrConnectWithoutCheck_insInput
    upsert?: MemberUpsertWithoutCheck_insInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutCheck_insInput, MemberUpdateWithoutCheck_insInput>, MemberUncheckedUpdateWithoutCheck_insInput>
  }

  export type MemberCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<MemberCreateWithoutAttendanceInput, MemberUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: MemberCreateOrConnectWithoutAttendanceInput
    connect?: MemberWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MemberUpdateOneRequiredWithoutAttendanceNestedInput = {
    create?: XOR<MemberCreateWithoutAttendanceInput, MemberUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: MemberCreateOrConnectWithoutAttendanceInput
    upsert?: MemberUpsertWithoutAttendanceInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutAttendanceInput, MemberUpdateWithoutAttendanceInput>, MemberUncheckedUpdateWithoutAttendanceInput>
  }

  export type MemberCreateNestedOneWithoutFitness_goalsInput = {
    create?: XOR<MemberCreateWithoutFitness_goalsInput, MemberUncheckedCreateWithoutFitness_goalsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutFitness_goalsInput
    connect?: MemberWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MemberUpdateOneRequiredWithoutFitness_goalsNestedInput = {
    create?: XOR<MemberCreateWithoutFitness_goalsInput, MemberUncheckedCreateWithoutFitness_goalsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutFitness_goalsInput
    upsert?: MemberUpsertWithoutFitness_goalsInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutFitness_goalsInput, MemberUpdateWithoutFitness_goalsInput>, MemberUncheckedUpdateWithoutFitness_goalsInput>
  }

  export type MemberCreateNestedOneWithoutAddressInput = {
    create?: XOR<MemberCreateWithoutAddressInput, MemberUncheckedCreateWithoutAddressInput>
    connectOrCreate?: MemberCreateOrConnectWithoutAddressInput
    connect?: MemberWhereUniqueInput
  }

  export type MemberUpdateOneRequiredWithoutAddressNestedInput = {
    create?: XOR<MemberCreateWithoutAddressInput, MemberUncheckedCreateWithoutAddressInput>
    connectOrCreate?: MemberCreateOrConnectWithoutAddressInput
    upsert?: MemberUpsertWithoutAddressInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutAddressInput, MemberUpdateWithoutAddressInput>, MemberUncheckedUpdateWithoutAddressInput>
  }

  export type MemberCreateNestedOneWithoutEmergency_contactInput = {
    create?: XOR<MemberCreateWithoutEmergency_contactInput, MemberUncheckedCreateWithoutEmergency_contactInput>
    connectOrCreate?: MemberCreateOrConnectWithoutEmergency_contactInput
    connect?: MemberWhereUniqueInput
  }

  export type MemberUpdateOneRequiredWithoutEmergency_contactNestedInput = {
    create?: XOR<MemberCreateWithoutEmergency_contactInput, MemberUncheckedCreateWithoutEmergency_contactInput>
    connectOrCreate?: MemberCreateOrConnectWithoutEmergency_contactInput
    upsert?: MemberUpsertWithoutEmergency_contactInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutEmergency_contactInput, MemberUpdateWithoutEmergency_contactInput>, MemberUncheckedUpdateWithoutEmergency_contactInput>
  }

  export type MedicalInfoCreatefitness_goalsInput = {
    set: string[]
  }

  export type MedicalInfoCreatehealth_conditionsInput = {
    set: string[]
  }

  export type MedicalInfoCreateallergiesInput = {
    set: string[]
  }

  export type MedicalInfoCreatemedicationsInput = {
    set: string[]
  }

  export type MemberCreateNestedOneWithoutMedical_infoInput = {
    create?: XOR<MemberCreateWithoutMedical_infoInput, MemberUncheckedCreateWithoutMedical_infoInput>
    connectOrCreate?: MemberCreateOrConnectWithoutMedical_infoInput
    connect?: MemberWhereUniqueInput
  }

  export type MedicalInfoUpdatefitness_goalsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MedicalInfoUpdatehealth_conditionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MedicalInfoUpdateallergiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MedicalInfoUpdatemedicationsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MemberUpdateOneRequiredWithoutMedical_infoNestedInput = {
    create?: XOR<MemberCreateWithoutMedical_infoInput, MemberUncheckedCreateWithoutMedical_infoInput>
    connectOrCreate?: MemberCreateOrConnectWithoutMedical_infoInput
    upsert?: MemberUpsertWithoutMedical_infoInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutMedical_infoInput, MemberUpdateWithoutMedical_infoInput>, MemberUncheckedUpdateWithoutMedical_infoInput>
  }

  export type MemberCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<MemberCreateWithoutPaymentsInput, MemberUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutPaymentsInput
    connect?: MemberWhereUniqueInput
  }

  export type MemberUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<MemberCreateWithoutPaymentsInput, MemberUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutPaymentsInput
    upsert?: MemberUpsertWithoutPaymentsInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutPaymentsInput, MemberUpdateWithoutPaymentsInput>, MemberUncheckedUpdateWithoutPaymentsInput>
  }

  export type MemberCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<MemberCreateWithoutInvoicesInput, MemberUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: MemberCreateOrConnectWithoutInvoicesInput
    connect?: MemberWhereUniqueInput
  }

  export type MemberUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<MemberCreateWithoutInvoicesInput, MemberUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: MemberCreateOrConnectWithoutInvoicesInput
    upsert?: MemberUpsertWithoutInvoicesInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutInvoicesInput, MemberUpdateWithoutInvoicesInput>, MemberUncheckedUpdateWithoutInvoicesInput>
  }

  export type SubscriptionCreateNestedManyWithoutPlanInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type SubscriptionUpdateManyWithoutPlanNestedInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutPlanInput | SubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutPlanInput | SubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutPlanInput | SubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutPlanInput | SubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutPlanInput | SubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutPlanInput | SubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type MemberCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<MemberCreateWithoutSubscriptionInput, MemberUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: MemberCreateOrConnectWithoutSubscriptionInput
    connect?: MemberWhereUniqueInput
  }

  export type MembershipPlanCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<MembershipPlanCreateWithoutSubscriptionsInput, MembershipPlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: MembershipPlanCreateOrConnectWithoutSubscriptionsInput
    connect?: MembershipPlanWhereUniqueInput
  }

  export type MemberUpdateOneRequiredWithoutSubscriptionNestedInput = {
    create?: XOR<MemberCreateWithoutSubscriptionInput, MemberUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: MemberCreateOrConnectWithoutSubscriptionInput
    upsert?: MemberUpsertWithoutSubscriptionInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutSubscriptionInput, MemberUpdateWithoutSubscriptionInput>, MemberUncheckedUpdateWithoutSubscriptionInput>
  }

  export type MembershipPlanUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<MembershipPlanCreateWithoutSubscriptionsInput, MembershipPlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: MembershipPlanCreateOrConnectWithoutSubscriptionsInput
    upsert?: MembershipPlanUpsertWithoutSubscriptionsInput
    connect?: MembershipPlanWhereUniqueInput
    update?: XOR<XOR<MembershipPlanUpdateToOneWithWhereWithoutSubscriptionsInput, MembershipPlanUpdateWithoutSubscriptionsInput>, MembershipPlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type MaintenanceLogCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<MaintenanceLogCreateWithoutEquipmentInput, MaintenanceLogUncheckedCreateWithoutEquipmentInput> | MaintenanceLogCreateWithoutEquipmentInput[] | MaintenanceLogUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: MaintenanceLogCreateOrConnectWithoutEquipmentInput | MaintenanceLogCreateOrConnectWithoutEquipmentInput[]
    createMany?: MaintenanceLogCreateManyEquipmentInputEnvelope
    connect?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
  }

  export type MaintenanceLogUncheckedCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<MaintenanceLogCreateWithoutEquipmentInput, MaintenanceLogUncheckedCreateWithoutEquipmentInput> | MaintenanceLogCreateWithoutEquipmentInput[] | MaintenanceLogUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: MaintenanceLogCreateOrConnectWithoutEquipmentInput | MaintenanceLogCreateOrConnectWithoutEquipmentInput[]
    createMany?: MaintenanceLogCreateManyEquipmentInputEnvelope
    connect?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumEquipmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.EquipmentStatus
  }

  export type MaintenanceLogUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<MaintenanceLogCreateWithoutEquipmentInput, MaintenanceLogUncheckedCreateWithoutEquipmentInput> | MaintenanceLogCreateWithoutEquipmentInput[] | MaintenanceLogUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: MaintenanceLogCreateOrConnectWithoutEquipmentInput | MaintenanceLogCreateOrConnectWithoutEquipmentInput[]
    upsert?: MaintenanceLogUpsertWithWhereUniqueWithoutEquipmentInput | MaintenanceLogUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: MaintenanceLogCreateManyEquipmentInputEnvelope
    set?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
    disconnect?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
    delete?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
    connect?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
    update?: MaintenanceLogUpdateWithWhereUniqueWithoutEquipmentInput | MaintenanceLogUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: MaintenanceLogUpdateManyWithWhereWithoutEquipmentInput | MaintenanceLogUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: MaintenanceLogScalarWhereInput | MaintenanceLogScalarWhereInput[]
  }

  export type MaintenanceLogUncheckedUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<MaintenanceLogCreateWithoutEquipmentInput, MaintenanceLogUncheckedCreateWithoutEquipmentInput> | MaintenanceLogCreateWithoutEquipmentInput[] | MaintenanceLogUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: MaintenanceLogCreateOrConnectWithoutEquipmentInput | MaintenanceLogCreateOrConnectWithoutEquipmentInput[]
    upsert?: MaintenanceLogUpsertWithWhereUniqueWithoutEquipmentInput | MaintenanceLogUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: MaintenanceLogCreateManyEquipmentInputEnvelope
    set?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
    disconnect?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
    delete?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
    connect?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
    update?: MaintenanceLogUpdateWithWhereUniqueWithoutEquipmentInput | MaintenanceLogUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: MaintenanceLogUpdateManyWithWhereWithoutEquipmentInput | MaintenanceLogUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: MaintenanceLogScalarWhereInput | MaintenanceLogScalarWhereInput[]
  }

  export type EquipmentCreateNestedOneWithoutMaintenanceLogsInput = {
    create?: XOR<EquipmentCreateWithoutMaintenanceLogsInput, EquipmentUncheckedCreateWithoutMaintenanceLogsInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutMaintenanceLogsInput
    connect?: EquipmentWhereUniqueInput
  }

  export type EnumMaintenanceTypeFieldUpdateOperationsInput = {
    set?: $Enums.MaintenanceType
  }

  export type EquipmentUpdateOneRequiredWithoutMaintenanceLogsNestedInput = {
    create?: XOR<EquipmentCreateWithoutMaintenanceLogsInput, EquipmentUncheckedCreateWithoutMaintenanceLogsInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutMaintenanceLogsInput
    upsert?: EquipmentUpsertWithoutMaintenanceLogsInput
    connect?: EquipmentWhereUniqueInput
    update?: XOR<XOR<EquipmentUpdateToOneWithWhereWithoutMaintenanceLogsInput, EquipmentUpdateWithoutMaintenanceLogsInput>, EquipmentUncheckedUpdateWithoutMaintenanceLogsInput>
  }

  export type WebhookEndpointCreateeventsInput = {
    set: string[]
  }

  export type WebhookEndpointUpdateeventsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type APIManagementCreatepermissionsInput = {
    set: string[]
  }

  export type APIManagementUpdatepermissionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AdministrativeProfileCreatedepartmentsInput = {
    set: string[]
  }

  export type AdministrativeProfileCreateresponsibilitiesInput = {
    set: string[]
  }

  export type AdministrativeProfileCreatecriticalPermissionsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutAdmin_profileInput = {
    create?: XOR<UserCreateWithoutAdmin_profileInput, UserUncheckedCreateWithoutAdmin_profileInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdmin_profileInput
    connect?: UserWhereUniqueInput
  }

  export type AdministrativeProfileUpdatedepartmentsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AdministrativeProfileUpdateresponsibilitiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AdministrativeProfileUpdatecriticalPermissionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutAdmin_profileNestedInput = {
    create?: XOR<UserCreateWithoutAdmin_profileInput, UserUncheckedCreateWithoutAdmin_profileInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdmin_profileInput
    upsert?: UserUpsertWithoutAdmin_profileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdmin_profileInput, UserUpdateWithoutAdmin_profileInput>, UserUncheckedUpdateWithoutAdmin_profileInput>
  }

  export type CustomRoleCreatepermissionsInput = {
    set: string[]
  }

  export type RoleHierarchyCreateNestedOneWithoutRoleInput = {
    create?: XOR<RoleHierarchyCreateWithoutRoleInput, RoleHierarchyUncheckedCreateWithoutRoleInput>
    connectOrCreate?: RoleHierarchyCreateOrConnectWithoutRoleInput
    connect?: RoleHierarchyWhereUniqueInput
  }

  export type RoleHierarchyUncheckedCreateNestedOneWithoutRoleInput = {
    create?: XOR<RoleHierarchyCreateWithoutRoleInput, RoleHierarchyUncheckedCreateWithoutRoleInput>
    connectOrCreate?: RoleHierarchyCreateOrConnectWithoutRoleInput
    connect?: RoleHierarchyWhereUniqueInput
  }

  export type CustomRoleUpdatepermissionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type RoleHierarchyUpdateOneWithoutRoleNestedInput = {
    create?: XOR<RoleHierarchyCreateWithoutRoleInput, RoleHierarchyUncheckedCreateWithoutRoleInput>
    connectOrCreate?: RoleHierarchyCreateOrConnectWithoutRoleInput
    upsert?: RoleHierarchyUpsertWithoutRoleInput
    disconnect?: RoleHierarchyWhereInput | boolean
    delete?: RoleHierarchyWhereInput | boolean
    connect?: RoleHierarchyWhereUniqueInput
    update?: XOR<XOR<RoleHierarchyUpdateToOneWithWhereWithoutRoleInput, RoleHierarchyUpdateWithoutRoleInput>, RoleHierarchyUncheckedUpdateWithoutRoleInput>
  }

  export type RoleHierarchyUncheckedUpdateOneWithoutRoleNestedInput = {
    create?: XOR<RoleHierarchyCreateWithoutRoleInput, RoleHierarchyUncheckedCreateWithoutRoleInput>
    connectOrCreate?: RoleHierarchyCreateOrConnectWithoutRoleInput
    upsert?: RoleHierarchyUpsertWithoutRoleInput
    disconnect?: RoleHierarchyWhereInput | boolean
    delete?: RoleHierarchyWhereInput | boolean
    connect?: RoleHierarchyWhereUniqueInput
    update?: XOR<XOR<RoleHierarchyUpdateToOneWithWhereWithoutRoleInput, RoleHierarchyUpdateWithoutRoleInput>, RoleHierarchyUncheckedUpdateWithoutRoleInput>
  }

  export type RoleHierarchyCreateNestedOneWithoutChildrenInput = {
    create?: XOR<RoleHierarchyCreateWithoutChildrenInput, RoleHierarchyUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: RoleHierarchyCreateOrConnectWithoutChildrenInput
    connect?: RoleHierarchyWhereUniqueInput
  }

  export type RoleHierarchyCreateNestedManyWithoutParentInput = {
    create?: XOR<RoleHierarchyCreateWithoutParentInput, RoleHierarchyUncheckedCreateWithoutParentInput> | RoleHierarchyCreateWithoutParentInput[] | RoleHierarchyUncheckedCreateWithoutParentInput[]
    connectOrCreate?: RoleHierarchyCreateOrConnectWithoutParentInput | RoleHierarchyCreateOrConnectWithoutParentInput[]
    createMany?: RoleHierarchyCreateManyParentInputEnvelope
    connect?: RoleHierarchyWhereUniqueInput | RoleHierarchyWhereUniqueInput[]
  }

  export type CustomRoleCreateNestedOneWithoutHierarchyInput = {
    create?: XOR<CustomRoleCreateWithoutHierarchyInput, CustomRoleUncheckedCreateWithoutHierarchyInput>
    connectOrCreate?: CustomRoleCreateOrConnectWithoutHierarchyInput
    connect?: CustomRoleWhereUniqueInput
  }

  export type RoleHierarchyUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<RoleHierarchyCreateWithoutParentInput, RoleHierarchyUncheckedCreateWithoutParentInput> | RoleHierarchyCreateWithoutParentInput[] | RoleHierarchyUncheckedCreateWithoutParentInput[]
    connectOrCreate?: RoleHierarchyCreateOrConnectWithoutParentInput | RoleHierarchyCreateOrConnectWithoutParentInput[]
    createMany?: RoleHierarchyCreateManyParentInputEnvelope
    connect?: RoleHierarchyWhereUniqueInput | RoleHierarchyWhereUniqueInput[]
  }

  export type RoleHierarchyUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<RoleHierarchyCreateWithoutChildrenInput, RoleHierarchyUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: RoleHierarchyCreateOrConnectWithoutChildrenInput
    upsert?: RoleHierarchyUpsertWithoutChildrenInput
    disconnect?: RoleHierarchyWhereInput | boolean
    delete?: RoleHierarchyWhereInput | boolean
    connect?: RoleHierarchyWhereUniqueInput
    update?: XOR<XOR<RoleHierarchyUpdateToOneWithWhereWithoutChildrenInput, RoleHierarchyUpdateWithoutChildrenInput>, RoleHierarchyUncheckedUpdateWithoutChildrenInput>
  }

  export type RoleHierarchyUpdateManyWithoutParentNestedInput = {
    create?: XOR<RoleHierarchyCreateWithoutParentInput, RoleHierarchyUncheckedCreateWithoutParentInput> | RoleHierarchyCreateWithoutParentInput[] | RoleHierarchyUncheckedCreateWithoutParentInput[]
    connectOrCreate?: RoleHierarchyCreateOrConnectWithoutParentInput | RoleHierarchyCreateOrConnectWithoutParentInput[]
    upsert?: RoleHierarchyUpsertWithWhereUniqueWithoutParentInput | RoleHierarchyUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: RoleHierarchyCreateManyParentInputEnvelope
    set?: RoleHierarchyWhereUniqueInput | RoleHierarchyWhereUniqueInput[]
    disconnect?: RoleHierarchyWhereUniqueInput | RoleHierarchyWhereUniqueInput[]
    delete?: RoleHierarchyWhereUniqueInput | RoleHierarchyWhereUniqueInput[]
    connect?: RoleHierarchyWhereUniqueInput | RoleHierarchyWhereUniqueInput[]
    update?: RoleHierarchyUpdateWithWhereUniqueWithoutParentInput | RoleHierarchyUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: RoleHierarchyUpdateManyWithWhereWithoutParentInput | RoleHierarchyUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: RoleHierarchyScalarWhereInput | RoleHierarchyScalarWhereInput[]
  }

  export type CustomRoleUpdateOneRequiredWithoutHierarchyNestedInput = {
    create?: XOR<CustomRoleCreateWithoutHierarchyInput, CustomRoleUncheckedCreateWithoutHierarchyInput>
    connectOrCreate?: CustomRoleCreateOrConnectWithoutHierarchyInput
    upsert?: CustomRoleUpsertWithoutHierarchyInput
    connect?: CustomRoleWhereUniqueInput
    update?: XOR<XOR<CustomRoleUpdateToOneWithWhereWithoutHierarchyInput, CustomRoleUpdateWithoutHierarchyInput>, CustomRoleUncheckedUpdateWithoutHierarchyInput>
  }

  export type RoleHierarchyUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<RoleHierarchyCreateWithoutParentInput, RoleHierarchyUncheckedCreateWithoutParentInput> | RoleHierarchyCreateWithoutParentInput[] | RoleHierarchyUncheckedCreateWithoutParentInput[]
    connectOrCreate?: RoleHierarchyCreateOrConnectWithoutParentInput | RoleHierarchyCreateOrConnectWithoutParentInput[]
    upsert?: RoleHierarchyUpsertWithWhereUniqueWithoutParentInput | RoleHierarchyUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: RoleHierarchyCreateManyParentInputEnvelope
    set?: RoleHierarchyWhereUniqueInput | RoleHierarchyWhereUniqueInput[]
    disconnect?: RoleHierarchyWhereUniqueInput | RoleHierarchyWhereUniqueInput[]
    delete?: RoleHierarchyWhereUniqueInput | RoleHierarchyWhereUniqueInput[]
    connect?: RoleHierarchyWhereUniqueInput | RoleHierarchyWhereUniqueInput[]
    update?: RoleHierarchyUpdateWithWhereUniqueWithoutParentInput | RoleHierarchyUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: RoleHierarchyUpdateManyWithWhereWithoutParentInput | RoleHierarchyUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: RoleHierarchyScalarWhereInput | RoleHierarchyScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPermission_auditsInput = {
    create?: XOR<UserCreateWithoutPermission_auditsInput, UserUncheckedCreateWithoutPermission_auditsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPermission_auditsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPermission_auditsNestedInput = {
    create?: XOR<UserCreateWithoutPermission_auditsInput, UserUncheckedCreateWithoutPermission_auditsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPermission_auditsInput
    upsert?: UserUpsertWithoutPermission_auditsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPermission_auditsInput, UserUpdateWithoutPermission_auditsInput>, UserUncheckedUpdateWithoutPermission_auditsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumMemberShipTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberShipType | EnumMemberShipTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MemberShipType[] | ListEnumMemberShipTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberShipType[] | ListEnumMemberShipTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberShipTypeFilter<$PrismaModel> | $Enums.MemberShipType
  }

  export type NestedEnumMemberShipTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberShipType | EnumMemberShipTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MemberShipType[] | ListEnumMemberShipTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberShipType[] | ListEnumMemberShipTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberShipTypeWithAggregatesFilter<$PrismaModel> | $Enums.MemberShipType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMemberShipTypeFilter<$PrismaModel>
    _max?: NestedEnumMemberShipTypeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumEquipmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentStatus | EnumEquipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentStatusFilter<$PrismaModel> | $Enums.EquipmentStatus
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumEquipmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentStatus | EnumEquipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.EquipmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEquipmentStatusFilter<$PrismaModel>
    _max?: NestedEnumEquipmentStatusFilter<$PrismaModel>
  }

  export type NestedEnumMaintenanceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceType | EnumMaintenanceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceType[] | ListEnumMaintenanceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceType[] | ListEnumMaintenanceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceTypeFilter<$PrismaModel> | $Enums.MaintenanceType
  }

  export type NestedEnumMaintenanceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceType | EnumMaintenanceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceType[] | ListEnumMaintenanceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceType[] | ListEnumMaintenanceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceTypeWithAggregatesFilter<$PrismaModel> | $Enums.MaintenanceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaintenanceTypeFilter<$PrismaModel>
    _max?: NestedEnumMaintenanceTypeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AdministrativeProfileCreateWithoutUserInput = {
    id?: string
    adminLevel?: string
    departments?: AdministrativeProfileCreatedepartmentsInput | string[]
    responsibilities?: AdministrativeProfileCreateresponsibilitiesInput | string[]
    criticalPermissions?: AdministrativeProfileCreatecriticalPermissionsInput | string[]
    emergencyContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdministrativeProfileUncheckedCreateWithoutUserInput = {
    id?: string
    adminLevel?: string
    departments?: AdministrativeProfileCreatedepartmentsInput | string[]
    responsibilities?: AdministrativeProfileCreateresponsibilitiesInput | string[]
    criticalPermissions?: AdministrativeProfileCreatecriticalPermissionsInput | string[]
    emergencyContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdministrativeProfileCreateOrConnectWithoutUserInput = {
    where: AdministrativeProfileWhereUniqueInput
    create: XOR<AdministrativeProfileCreateWithoutUserInput, AdministrativeProfileUncheckedCreateWithoutUserInput>
  }

  export type PermissionAuditCreateWithoutUserInput = {
    id?: string
    action: string
    permissionId: string
    oldValue?: string | null
    newValue: string
    reason?: string | null
    performedBy?: string | null
    createdAt?: Date | string
  }

  export type PermissionAuditUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    permissionId: string
    oldValue?: string | null
    newValue: string
    reason?: string | null
    performedBy?: string | null
    createdAt?: Date | string
  }

  export type PermissionAuditCreateOrConnectWithoutUserInput = {
    where: PermissionAuditWhereUniqueInput
    create: XOR<PermissionAuditCreateWithoutUserInput, PermissionAuditUncheckedCreateWithoutUserInput>
  }

  export type PermissionAuditCreateManyUserInputEnvelope = {
    data: PermissionAuditCreateManyUserInput | PermissionAuditCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserAccessLogCreateWithoutUserInput = {
    id?: string
    action: string
    ipAddress?: string | null
    userAgent?: string | null
    success: boolean
    details?: string | null
    createdAt?: Date | string
  }

  export type UserAccessLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    ipAddress?: string | null
    userAgent?: string | null
    success: boolean
    details?: string | null
    createdAt?: Date | string
  }

  export type UserAccessLogCreateOrConnectWithoutUserInput = {
    where: UserAccessLogWhereUniqueInput
    create: XOR<UserAccessLogCreateWithoutUserInput, UserAccessLogUncheckedCreateWithoutUserInput>
  }

  export type UserAccessLogCreateManyUserInputEnvelope = {
    data: UserAccessLogCreateManyUserInput | UserAccessLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserAddressCreateWithoutUserInput = {
    street: string
    city: string
    state: string
    postalCode: string
    country?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAddressUncheckedCreateWithoutUserInput = {
    id?: number
    street: string
    city: string
    state: string
    postalCode: string
    country?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAddressCreateOrConnectWithoutUserInput = {
    where: UserAddressWhereUniqueInput
    create: XOR<UserAddressCreateWithoutUserInput, UserAddressUncheckedCreateWithoutUserInput>
  }

  export type UserEmergencyContactCreateWithoutUserInput = {
    name: string
    relationship: string
    phone: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserEmergencyContactUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    relationship: string
    phone: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserEmergencyContactCreateOrConnectWithoutUserInput = {
    where: UserEmergencyContactWhereUniqueInput
    create: XOR<UserEmergencyContactCreateWithoutUserInput, UserEmergencyContactUncheckedCreateWithoutUserInput>
  }

  export type UserIPRestrictionCreateWithoutUserInput = {
    id?: string
    ipAddress: string
    type: string
    reason?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserIPRestrictionUncheckedCreateWithoutUserInput = {
    id?: string
    ipAddress: string
    type: string
    reason?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserIPRestrictionCreateOrConnectWithoutUserInput = {
    where: UserIPRestrictionWhereUniqueInput
    create: XOR<UserIPRestrictionCreateWithoutUserInput, UserIPRestrictionUncheckedCreateWithoutUserInput>
  }

  export type UserIPRestrictionCreateManyUserInputEnvelope = {
    data: UserIPRestrictionCreateManyUserInput | UserIPRestrictionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserNotificationSettingsCreateWithoutUserInput = {
    email_loginAlerts?: boolean
    email_securityUpdates?: boolean
    email_systemAnnouncements?: boolean
    email_marketingEmails?: boolean
    push_loginAlerts?: boolean
    push_securityUpdates?: boolean
    push_systemAnnouncements?: boolean
    push_marketingNotifications?: boolean
    sms_loginAlerts?: boolean
    sms_securityUpdates?: boolean
    sms_emergencyAlerts?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserNotificationSettingsUncheckedCreateWithoutUserInput = {
    id?: number
    email_loginAlerts?: boolean
    email_securityUpdates?: boolean
    email_systemAnnouncements?: boolean
    email_marketingEmails?: boolean
    push_loginAlerts?: boolean
    push_securityUpdates?: boolean
    push_systemAnnouncements?: boolean
    push_marketingNotifications?: boolean
    sms_loginAlerts?: boolean
    sms_securityUpdates?: boolean
    sms_emergencyAlerts?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserNotificationSettingsCreateOrConnectWithoutUserInput = {
    where: UserNotificationSettingsWhereUniqueInput
    create: XOR<UserNotificationSettingsCreateWithoutUserInput, UserNotificationSettingsUncheckedCreateWithoutUserInput>
  }

  export type UserPreferencesCreateWithoutUserInput = {
    theme?: string
    language?: string
    timezone?: string
    dateFormat?: string
    timeFormat?: string
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPreferencesUncheckedCreateWithoutUserInput = {
    id?: number
    theme?: string
    language?: string
    timezone?: string
    dateFormat?: string
    timeFormat?: string
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPreferencesCreateOrConnectWithoutUserInput = {
    where: UserPreferencesWhereUniqueInput
    create: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
  }

  export type UserPrivacySettingsCreateWithoutUserInput = {
    profileVisibility?: string
    showEmail?: boolean
    showPhone?: boolean
    showLocation?: boolean
    allowContact?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPrivacySettingsUncheckedCreateWithoutUserInput = {
    id?: number
    profileVisibility?: string
    showEmail?: boolean
    showPhone?: boolean
    showLocation?: boolean
    allowContact?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPrivacySettingsCreateOrConnectWithoutUserInput = {
    where: UserPrivacySettingsWhereUniqueInput
    create: XOR<UserPrivacySettingsCreateWithoutUserInput, UserPrivacySettingsUncheckedCreateWithoutUserInput>
  }

  export type UserSessionCreateWithoutUserInput = {
    id?: string
    token: string
    deviceType?: string | null
    deviceInfo?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    isActive?: boolean
    lastActivity?: Date | string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSessionUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    deviceType?: string | null
    deviceInfo?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    isActive?: boolean
    lastActivity?: Date | string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSessionCreateOrConnectWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionCreateManyUserInputEnvelope = {
    data: UserSessionCreateManyUserInput | UserSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserSocialMediaCreateWithoutUserInput = {
    linkedin?: string | null
    twitter?: string | null
    facebook?: string | null
    instagram?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSocialMediaUncheckedCreateWithoutUserInput = {
    id?: number
    linkedin?: string | null
    twitter?: string | null
    facebook?: string | null
    instagram?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSocialMediaCreateOrConnectWithoutUserInput = {
    where: UserSocialMediaWhereUniqueInput
    create: XOR<UserSocialMediaCreateWithoutUserInput, UserSocialMediaUncheckedCreateWithoutUserInput>
  }

  export type AdministrativeProfileUpsertWithoutUserInput = {
    update: XOR<AdministrativeProfileUpdateWithoutUserInput, AdministrativeProfileUncheckedUpdateWithoutUserInput>
    create: XOR<AdministrativeProfileCreateWithoutUserInput, AdministrativeProfileUncheckedCreateWithoutUserInput>
    where?: AdministrativeProfileWhereInput
  }

  export type AdministrativeProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: AdministrativeProfileWhereInput
    data: XOR<AdministrativeProfileUpdateWithoutUserInput, AdministrativeProfileUncheckedUpdateWithoutUserInput>
  }

  export type AdministrativeProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminLevel?: StringFieldUpdateOperationsInput | string
    departments?: AdministrativeProfileUpdatedepartmentsInput | string[]
    responsibilities?: AdministrativeProfileUpdateresponsibilitiesInput | string[]
    criticalPermissions?: AdministrativeProfileUpdatecriticalPermissionsInput | string[]
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdministrativeProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminLevel?: StringFieldUpdateOperationsInput | string
    departments?: AdministrativeProfileUpdatedepartmentsInput | string[]
    responsibilities?: AdministrativeProfileUpdateresponsibilitiesInput | string[]
    criticalPermissions?: AdministrativeProfileUpdatecriticalPermissionsInput | string[]
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionAuditUpsertWithWhereUniqueWithoutUserInput = {
    where: PermissionAuditWhereUniqueInput
    update: XOR<PermissionAuditUpdateWithoutUserInput, PermissionAuditUncheckedUpdateWithoutUserInput>
    create: XOR<PermissionAuditCreateWithoutUserInput, PermissionAuditUncheckedCreateWithoutUserInput>
  }

  export type PermissionAuditUpdateWithWhereUniqueWithoutUserInput = {
    where: PermissionAuditWhereUniqueInput
    data: XOR<PermissionAuditUpdateWithoutUserInput, PermissionAuditUncheckedUpdateWithoutUserInput>
  }

  export type PermissionAuditUpdateManyWithWhereWithoutUserInput = {
    where: PermissionAuditScalarWhereInput
    data: XOR<PermissionAuditUpdateManyMutationInput, PermissionAuditUncheckedUpdateManyWithoutUserInput>
  }

  export type PermissionAuditScalarWhereInput = {
    AND?: PermissionAuditScalarWhereInput | PermissionAuditScalarWhereInput[]
    OR?: PermissionAuditScalarWhereInput[]
    NOT?: PermissionAuditScalarWhereInput | PermissionAuditScalarWhereInput[]
    id?: StringFilter<"PermissionAudit"> | string
    userId?: IntFilter<"PermissionAudit"> | number
    action?: StringFilter<"PermissionAudit"> | string
    permissionId?: StringFilter<"PermissionAudit"> | string
    oldValue?: StringNullableFilter<"PermissionAudit"> | string | null
    newValue?: StringFilter<"PermissionAudit"> | string
    reason?: StringNullableFilter<"PermissionAudit"> | string | null
    performedBy?: StringNullableFilter<"PermissionAudit"> | string | null
    createdAt?: DateTimeFilter<"PermissionAudit"> | Date | string
  }

  export type UserAccessLogUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAccessLogWhereUniqueInput
    update: XOR<UserAccessLogUpdateWithoutUserInput, UserAccessLogUncheckedUpdateWithoutUserInput>
    create: XOR<UserAccessLogCreateWithoutUserInput, UserAccessLogUncheckedCreateWithoutUserInput>
  }

  export type UserAccessLogUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAccessLogWhereUniqueInput
    data: XOR<UserAccessLogUpdateWithoutUserInput, UserAccessLogUncheckedUpdateWithoutUserInput>
  }

  export type UserAccessLogUpdateManyWithWhereWithoutUserInput = {
    where: UserAccessLogScalarWhereInput
    data: XOR<UserAccessLogUpdateManyMutationInput, UserAccessLogUncheckedUpdateManyWithoutUserInput>
  }

  export type UserAccessLogScalarWhereInput = {
    AND?: UserAccessLogScalarWhereInput | UserAccessLogScalarWhereInput[]
    OR?: UserAccessLogScalarWhereInput[]
    NOT?: UserAccessLogScalarWhereInput | UserAccessLogScalarWhereInput[]
    id?: StringFilter<"UserAccessLog"> | string
    userId?: IntFilter<"UserAccessLog"> | number
    action?: StringFilter<"UserAccessLog"> | string
    ipAddress?: StringNullableFilter<"UserAccessLog"> | string | null
    userAgent?: StringNullableFilter<"UserAccessLog"> | string | null
    success?: BoolFilter<"UserAccessLog"> | boolean
    details?: StringNullableFilter<"UserAccessLog"> | string | null
    createdAt?: DateTimeFilter<"UserAccessLog"> | Date | string
  }

  export type UserAddressUpsertWithoutUserInput = {
    update: XOR<UserAddressUpdateWithoutUserInput, UserAddressUncheckedUpdateWithoutUserInput>
    create: XOR<UserAddressCreateWithoutUserInput, UserAddressUncheckedCreateWithoutUserInput>
    where?: UserAddressWhereInput
  }

  export type UserAddressUpdateToOneWithWhereWithoutUserInput = {
    where?: UserAddressWhereInput
    data: XOR<UserAddressUpdateWithoutUserInput, UserAddressUncheckedUpdateWithoutUserInput>
  }

  export type UserAddressUpdateWithoutUserInput = {
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAddressUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserEmergencyContactUpsertWithoutUserInput = {
    update: XOR<UserEmergencyContactUpdateWithoutUserInput, UserEmergencyContactUncheckedUpdateWithoutUserInput>
    create: XOR<UserEmergencyContactCreateWithoutUserInput, UserEmergencyContactUncheckedCreateWithoutUserInput>
    where?: UserEmergencyContactWhereInput
  }

  export type UserEmergencyContactUpdateToOneWithWhereWithoutUserInput = {
    where?: UserEmergencyContactWhereInput
    data: XOR<UserEmergencyContactUpdateWithoutUserInput, UserEmergencyContactUncheckedUpdateWithoutUserInput>
  }

  export type UserEmergencyContactUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserEmergencyContactUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserIPRestrictionUpsertWithWhereUniqueWithoutUserInput = {
    where: UserIPRestrictionWhereUniqueInput
    update: XOR<UserIPRestrictionUpdateWithoutUserInput, UserIPRestrictionUncheckedUpdateWithoutUserInput>
    create: XOR<UserIPRestrictionCreateWithoutUserInput, UserIPRestrictionUncheckedCreateWithoutUserInput>
  }

  export type UserIPRestrictionUpdateWithWhereUniqueWithoutUserInput = {
    where: UserIPRestrictionWhereUniqueInput
    data: XOR<UserIPRestrictionUpdateWithoutUserInput, UserIPRestrictionUncheckedUpdateWithoutUserInput>
  }

  export type UserIPRestrictionUpdateManyWithWhereWithoutUserInput = {
    where: UserIPRestrictionScalarWhereInput
    data: XOR<UserIPRestrictionUpdateManyMutationInput, UserIPRestrictionUncheckedUpdateManyWithoutUserInput>
  }

  export type UserIPRestrictionScalarWhereInput = {
    AND?: UserIPRestrictionScalarWhereInput | UserIPRestrictionScalarWhereInput[]
    OR?: UserIPRestrictionScalarWhereInput[]
    NOT?: UserIPRestrictionScalarWhereInput | UserIPRestrictionScalarWhereInput[]
    id?: StringFilter<"UserIPRestriction"> | string
    userId?: IntFilter<"UserIPRestriction"> | number
    ipAddress?: StringFilter<"UserIPRestriction"> | string
    type?: StringFilter<"UserIPRestriction"> | string
    reason?: StringNullableFilter<"UserIPRestriction"> | string | null
    expiresAt?: DateTimeNullableFilter<"UserIPRestriction"> | Date | string | null
    createdAt?: DateTimeFilter<"UserIPRestriction"> | Date | string
    updatedAt?: DateTimeFilter<"UserIPRestriction"> | Date | string
  }

  export type UserNotificationSettingsUpsertWithoutUserInput = {
    update: XOR<UserNotificationSettingsUpdateWithoutUserInput, UserNotificationSettingsUncheckedUpdateWithoutUserInput>
    create: XOR<UserNotificationSettingsCreateWithoutUserInput, UserNotificationSettingsUncheckedCreateWithoutUserInput>
    where?: UserNotificationSettingsWhereInput
  }

  export type UserNotificationSettingsUpdateToOneWithWhereWithoutUserInput = {
    where?: UserNotificationSettingsWhereInput
    data: XOR<UserNotificationSettingsUpdateWithoutUserInput, UserNotificationSettingsUncheckedUpdateWithoutUserInput>
  }

  export type UserNotificationSettingsUpdateWithoutUserInput = {
    email_loginAlerts?: BoolFieldUpdateOperationsInput | boolean
    email_securityUpdates?: BoolFieldUpdateOperationsInput | boolean
    email_systemAnnouncements?: BoolFieldUpdateOperationsInput | boolean
    email_marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    push_loginAlerts?: BoolFieldUpdateOperationsInput | boolean
    push_securityUpdates?: BoolFieldUpdateOperationsInput | boolean
    push_systemAnnouncements?: BoolFieldUpdateOperationsInput | boolean
    push_marketingNotifications?: BoolFieldUpdateOperationsInput | boolean
    sms_loginAlerts?: BoolFieldUpdateOperationsInput | boolean
    sms_securityUpdates?: BoolFieldUpdateOperationsInput | boolean
    sms_emergencyAlerts?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNotificationSettingsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    email_loginAlerts?: BoolFieldUpdateOperationsInput | boolean
    email_securityUpdates?: BoolFieldUpdateOperationsInput | boolean
    email_systemAnnouncements?: BoolFieldUpdateOperationsInput | boolean
    email_marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    push_loginAlerts?: BoolFieldUpdateOperationsInput | boolean
    push_securityUpdates?: BoolFieldUpdateOperationsInput | boolean
    push_systemAnnouncements?: BoolFieldUpdateOperationsInput | boolean
    push_marketingNotifications?: BoolFieldUpdateOperationsInput | boolean
    sms_loginAlerts?: BoolFieldUpdateOperationsInput | boolean
    sms_securityUpdates?: BoolFieldUpdateOperationsInput | boolean
    sms_emergencyAlerts?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferencesUpsertWithoutUserInput = {
    update: XOR<UserPreferencesUpdateWithoutUserInput, UserPreferencesUncheckedUpdateWithoutUserInput>
    create: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    where?: UserPreferencesWhereInput
  }

  export type UserPreferencesUpdateToOneWithWhereWithoutUserInput = {
    where?: UserPreferencesWhereInput
    data: XOR<UserPreferencesUpdateWithoutUserInput, UserPreferencesUncheckedUpdateWithoutUserInput>
  }

  export type UserPreferencesUpdateWithoutUserInput = {
    theme?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    dateFormat?: StringFieldUpdateOperationsInput | string
    timeFormat?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferencesUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    theme?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    dateFormat?: StringFieldUpdateOperationsInput | string
    timeFormat?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPrivacySettingsUpsertWithoutUserInput = {
    update: XOR<UserPrivacySettingsUpdateWithoutUserInput, UserPrivacySettingsUncheckedUpdateWithoutUserInput>
    create: XOR<UserPrivacySettingsCreateWithoutUserInput, UserPrivacySettingsUncheckedCreateWithoutUserInput>
    where?: UserPrivacySettingsWhereInput
  }

  export type UserPrivacySettingsUpdateToOneWithWhereWithoutUserInput = {
    where?: UserPrivacySettingsWhereInput
    data: XOR<UserPrivacySettingsUpdateWithoutUserInput, UserPrivacySettingsUncheckedUpdateWithoutUserInput>
  }

  export type UserPrivacySettingsUpdateWithoutUserInput = {
    profileVisibility?: StringFieldUpdateOperationsInput | string
    showEmail?: BoolFieldUpdateOperationsInput | boolean
    showPhone?: BoolFieldUpdateOperationsInput | boolean
    showLocation?: BoolFieldUpdateOperationsInput | boolean
    allowContact?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPrivacySettingsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    profileVisibility?: StringFieldUpdateOperationsInput | string
    showEmail?: BoolFieldUpdateOperationsInput | boolean
    showPhone?: BoolFieldUpdateOperationsInput | boolean
    showLocation?: BoolFieldUpdateOperationsInput | boolean
    allowContact?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    update: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    data: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
  }

  export type UserSessionUpdateManyWithWhereWithoutUserInput = {
    where: UserSessionScalarWhereInput
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type UserSessionScalarWhereInput = {
    AND?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    OR?: UserSessionScalarWhereInput[]
    NOT?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    id?: StringFilter<"UserSession"> | string
    userId?: IntFilter<"UserSession"> | number
    token?: StringFilter<"UserSession"> | string
    deviceType?: StringNullableFilter<"UserSession"> | string | null
    deviceInfo?: StringNullableFilter<"UserSession"> | string | null
    ipAddress?: StringNullableFilter<"UserSession"> | string | null
    userAgent?: StringNullableFilter<"UserSession"> | string | null
    isActive?: BoolFilter<"UserSession"> | boolean
    lastActivity?: DateTimeFilter<"UserSession"> | Date | string
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeFilter<"UserSession"> | Date | string
  }

  export type UserSocialMediaUpsertWithoutUserInput = {
    update: XOR<UserSocialMediaUpdateWithoutUserInput, UserSocialMediaUncheckedUpdateWithoutUserInput>
    create: XOR<UserSocialMediaCreateWithoutUserInput, UserSocialMediaUncheckedCreateWithoutUserInput>
    where?: UserSocialMediaWhereInput
  }

  export type UserSocialMediaUpdateToOneWithWhereWithoutUserInput = {
    where?: UserSocialMediaWhereInput
    data: XOR<UserSocialMediaUpdateWithoutUserInput, UserSocialMediaUncheckedUpdateWithoutUserInput>
  }

  export type UserSocialMediaUpdateWithoutUserInput = {
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSocialMediaUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutSessionsInput = {
    name: string
    username?: string | null
    email: string
    phone_number?: string | null
    password: string
    role?: string
    profile_picture?: string | null
    tokenVersion?: number
    created_at?: Date | string
    updated_at?: Date | string
    resetToken?: string | null
    resetTokenExp?: Date | string | null
    bio?: string | null
    dateOfBirth?: Date | string | null
    department?: string | null
    email_verified?: boolean
    gender?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    lockedUntil?: Date | string | null
    loginAttempts?: number
    position?: string | null
    admin_profile?: AdministrativeProfileCreateNestedOneWithoutUserInput
    permission_audits?: PermissionAuditCreateNestedManyWithoutUserInput
    access_logs?: UserAccessLogCreateNestedManyWithoutUserInput
    address?: UserAddressCreateNestedOneWithoutUserInput
    emergency_contact?: UserEmergencyContactCreateNestedOneWithoutUserInput
    ip_restrictions?: UserIPRestrictionCreateNestedManyWithoutUserInput
    notification_settings?: UserNotificationSettingsCreateNestedOneWithoutUserInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    privacy_settings?: UserPrivacySettingsCreateNestedOneWithoutUserInput
    social_media?: UserSocialMediaCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: number
    name: string
    username?: string | null
    email: string
    phone_number?: string | null
    password: string
    role?: string
    profile_picture?: string | null
    tokenVersion?: number
    created_at?: Date | string
    updated_at?: Date | string
    resetToken?: string | null
    resetTokenExp?: Date | string | null
    bio?: string | null
    dateOfBirth?: Date | string | null
    department?: string | null
    email_verified?: boolean
    gender?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    lockedUntil?: Date | string | null
    loginAttempts?: number
    position?: string | null
    admin_profile?: AdministrativeProfileUncheckedCreateNestedOneWithoutUserInput
    permission_audits?: PermissionAuditUncheckedCreateNestedManyWithoutUserInput
    access_logs?: UserAccessLogUncheckedCreateNestedManyWithoutUserInput
    address?: UserAddressUncheckedCreateNestedOneWithoutUserInput
    emergency_contact?: UserEmergencyContactUncheckedCreateNestedOneWithoutUserInput
    ip_restrictions?: UserIPRestrictionUncheckedCreateNestedManyWithoutUserInput
    notification_settings?: UserNotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    privacy_settings?: UserPrivacySettingsUncheckedCreateNestedOneWithoutUserInput
    social_media?: UserSocialMediaUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    position?: NullableStringFieldUpdateOperationsInput | string | null
    admin_profile?: AdministrativeProfileUpdateOneWithoutUserNestedInput
    permission_audits?: PermissionAuditUpdateManyWithoutUserNestedInput
    access_logs?: UserAccessLogUpdateManyWithoutUserNestedInput
    address?: UserAddressUpdateOneWithoutUserNestedInput
    emergency_contact?: UserEmergencyContactUpdateOneWithoutUserNestedInput
    ip_restrictions?: UserIPRestrictionUpdateManyWithoutUserNestedInput
    notification_settings?: UserNotificationSettingsUpdateOneWithoutUserNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    privacy_settings?: UserPrivacySettingsUpdateOneWithoutUserNestedInput
    social_media?: UserSocialMediaUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    position?: NullableStringFieldUpdateOperationsInput | string | null
    admin_profile?: AdministrativeProfileUncheckedUpdateOneWithoutUserNestedInput
    permission_audits?: PermissionAuditUncheckedUpdateManyWithoutUserNestedInput
    access_logs?: UserAccessLogUncheckedUpdateManyWithoutUserNestedInput
    address?: UserAddressUncheckedUpdateOneWithoutUserNestedInput
    emergency_contact?: UserEmergencyContactUncheckedUpdateOneWithoutUserNestedInput
    ip_restrictions?: UserIPRestrictionUncheckedUpdateManyWithoutUserNestedInput
    notification_settings?: UserNotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    privacy_settings?: UserPrivacySettingsUncheckedUpdateOneWithoutUserNestedInput
    social_media?: UserSocialMediaUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutAccess_logsInput = {
    name: string
    username?: string | null
    email: string
    phone_number?: string | null
    password: string
    role?: string
    profile_picture?: string | null
    tokenVersion?: number
    created_at?: Date | string
    updated_at?: Date | string
    resetToken?: string | null
    resetTokenExp?: Date | string | null
    bio?: string | null
    dateOfBirth?: Date | string | null
    department?: string | null
    email_verified?: boolean
    gender?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    lockedUntil?: Date | string | null
    loginAttempts?: number
    position?: string | null
    admin_profile?: AdministrativeProfileCreateNestedOneWithoutUserInput
    permission_audits?: PermissionAuditCreateNestedManyWithoutUserInput
    address?: UserAddressCreateNestedOneWithoutUserInput
    emergency_contact?: UserEmergencyContactCreateNestedOneWithoutUserInput
    ip_restrictions?: UserIPRestrictionCreateNestedManyWithoutUserInput
    notification_settings?: UserNotificationSettingsCreateNestedOneWithoutUserInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    privacy_settings?: UserPrivacySettingsCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    social_media?: UserSocialMediaCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccess_logsInput = {
    id?: number
    name: string
    username?: string | null
    email: string
    phone_number?: string | null
    password: string
    role?: string
    profile_picture?: string | null
    tokenVersion?: number
    created_at?: Date | string
    updated_at?: Date | string
    resetToken?: string | null
    resetTokenExp?: Date | string | null
    bio?: string | null
    dateOfBirth?: Date | string | null
    department?: string | null
    email_verified?: boolean
    gender?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    lockedUntil?: Date | string | null
    loginAttempts?: number
    position?: string | null
    admin_profile?: AdministrativeProfileUncheckedCreateNestedOneWithoutUserInput
    permission_audits?: PermissionAuditUncheckedCreateNestedManyWithoutUserInput
    address?: UserAddressUncheckedCreateNestedOneWithoutUserInput
    emergency_contact?: UserEmergencyContactUncheckedCreateNestedOneWithoutUserInput
    ip_restrictions?: UserIPRestrictionUncheckedCreateNestedManyWithoutUserInput
    notification_settings?: UserNotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    privacy_settings?: UserPrivacySettingsUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    social_media?: UserSocialMediaUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccess_logsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccess_logsInput, UserUncheckedCreateWithoutAccess_logsInput>
  }

  export type UserUpsertWithoutAccess_logsInput = {
    update: XOR<UserUpdateWithoutAccess_logsInput, UserUncheckedUpdateWithoutAccess_logsInput>
    create: XOR<UserCreateWithoutAccess_logsInput, UserUncheckedCreateWithoutAccess_logsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccess_logsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccess_logsInput, UserUncheckedUpdateWithoutAccess_logsInput>
  }

  export type UserUpdateWithoutAccess_logsInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    position?: NullableStringFieldUpdateOperationsInput | string | null
    admin_profile?: AdministrativeProfileUpdateOneWithoutUserNestedInput
    permission_audits?: PermissionAuditUpdateManyWithoutUserNestedInput
    address?: UserAddressUpdateOneWithoutUserNestedInput
    emergency_contact?: UserEmergencyContactUpdateOneWithoutUserNestedInput
    ip_restrictions?: UserIPRestrictionUpdateManyWithoutUserNestedInput
    notification_settings?: UserNotificationSettingsUpdateOneWithoutUserNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    privacy_settings?: UserPrivacySettingsUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    social_media?: UserSocialMediaUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccess_logsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    position?: NullableStringFieldUpdateOperationsInput | string | null
    admin_profile?: AdministrativeProfileUncheckedUpdateOneWithoutUserNestedInput
    permission_audits?: PermissionAuditUncheckedUpdateManyWithoutUserNestedInput
    address?: UserAddressUncheckedUpdateOneWithoutUserNestedInput
    emergency_contact?: UserEmergencyContactUncheckedUpdateOneWithoutUserNestedInput
    ip_restrictions?: UserIPRestrictionUncheckedUpdateManyWithoutUserNestedInput
    notification_settings?: UserNotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    privacy_settings?: UserPrivacySettingsUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    social_media?: UserSocialMediaUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutIp_restrictionsInput = {
    name: string
    username?: string | null
    email: string
    phone_number?: string | null
    password: string
    role?: string
    profile_picture?: string | null
    tokenVersion?: number
    created_at?: Date | string
    updated_at?: Date | string
    resetToken?: string | null
    resetTokenExp?: Date | string | null
    bio?: string | null
    dateOfBirth?: Date | string | null
    department?: string | null
    email_verified?: boolean
    gender?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    lockedUntil?: Date | string | null
    loginAttempts?: number
    position?: string | null
    admin_profile?: AdministrativeProfileCreateNestedOneWithoutUserInput
    permission_audits?: PermissionAuditCreateNestedManyWithoutUserInput
    access_logs?: UserAccessLogCreateNestedManyWithoutUserInput
    address?: UserAddressCreateNestedOneWithoutUserInput
    emergency_contact?: UserEmergencyContactCreateNestedOneWithoutUserInput
    notification_settings?: UserNotificationSettingsCreateNestedOneWithoutUserInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    privacy_settings?: UserPrivacySettingsCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    social_media?: UserSocialMediaCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutIp_restrictionsInput = {
    id?: number
    name: string
    username?: string | null
    email: string
    phone_number?: string | null
    password: string
    role?: string
    profile_picture?: string | null
    tokenVersion?: number
    created_at?: Date | string
    updated_at?: Date | string
    resetToken?: string | null
    resetTokenExp?: Date | string | null
    bio?: string | null
    dateOfBirth?: Date | string | null
    department?: string | null
    email_verified?: boolean
    gender?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    lockedUntil?: Date | string | null
    loginAttempts?: number
    position?: string | null
    admin_profile?: AdministrativeProfileUncheckedCreateNestedOneWithoutUserInput
    permission_audits?: PermissionAuditUncheckedCreateNestedManyWithoutUserInput
    access_logs?: UserAccessLogUncheckedCreateNestedManyWithoutUserInput
    address?: UserAddressUncheckedCreateNestedOneWithoutUserInput
    emergency_contact?: UserEmergencyContactUncheckedCreateNestedOneWithoutUserInput
    notification_settings?: UserNotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    privacy_settings?: UserPrivacySettingsUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    social_media?: UserSocialMediaUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutIp_restrictionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIp_restrictionsInput, UserUncheckedCreateWithoutIp_restrictionsInput>
  }

  export type UserUpsertWithoutIp_restrictionsInput = {
    update: XOR<UserUpdateWithoutIp_restrictionsInput, UserUncheckedUpdateWithoutIp_restrictionsInput>
    create: XOR<UserCreateWithoutIp_restrictionsInput, UserUncheckedCreateWithoutIp_restrictionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutIp_restrictionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutIp_restrictionsInput, UserUncheckedUpdateWithoutIp_restrictionsInput>
  }

  export type UserUpdateWithoutIp_restrictionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    position?: NullableStringFieldUpdateOperationsInput | string | null
    admin_profile?: AdministrativeProfileUpdateOneWithoutUserNestedInput
    permission_audits?: PermissionAuditUpdateManyWithoutUserNestedInput
    access_logs?: UserAccessLogUpdateManyWithoutUserNestedInput
    address?: UserAddressUpdateOneWithoutUserNestedInput
    emergency_contact?: UserEmergencyContactUpdateOneWithoutUserNestedInput
    notification_settings?: UserNotificationSettingsUpdateOneWithoutUserNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    privacy_settings?: UserPrivacySettingsUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    social_media?: UserSocialMediaUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutIp_restrictionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    position?: NullableStringFieldUpdateOperationsInput | string | null
    admin_profile?: AdministrativeProfileUncheckedUpdateOneWithoutUserNestedInput
    permission_audits?: PermissionAuditUncheckedUpdateManyWithoutUserNestedInput
    access_logs?: UserAccessLogUncheckedUpdateManyWithoutUserNestedInput
    address?: UserAddressUncheckedUpdateOneWithoutUserNestedInput
    emergency_contact?: UserEmergencyContactUncheckedUpdateOneWithoutUserNestedInput
    notification_settings?: UserNotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    privacy_settings?: UserPrivacySettingsUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    social_media?: UserSocialMediaUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutAddressInput = {
    name: string
    username?: string | null
    email: string
    phone_number?: string | null
    password: string
    role?: string
    profile_picture?: string | null
    tokenVersion?: number
    created_at?: Date | string
    updated_at?: Date | string
    resetToken?: string | null
    resetTokenExp?: Date | string | null
    bio?: string | null
    dateOfBirth?: Date | string | null
    department?: string | null
    email_verified?: boolean
    gender?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    lockedUntil?: Date | string | null
    loginAttempts?: number
    position?: string | null
    admin_profile?: AdministrativeProfileCreateNestedOneWithoutUserInput
    permission_audits?: PermissionAuditCreateNestedManyWithoutUserInput
    access_logs?: UserAccessLogCreateNestedManyWithoutUserInput
    emergency_contact?: UserEmergencyContactCreateNestedOneWithoutUserInput
    ip_restrictions?: UserIPRestrictionCreateNestedManyWithoutUserInput
    notification_settings?: UserNotificationSettingsCreateNestedOneWithoutUserInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    privacy_settings?: UserPrivacySettingsCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    social_media?: UserSocialMediaCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAddressInput = {
    id?: number
    name: string
    username?: string | null
    email: string
    phone_number?: string | null
    password: string
    role?: string
    profile_picture?: string | null
    tokenVersion?: number
    created_at?: Date | string
    updated_at?: Date | string
    resetToken?: string | null
    resetTokenExp?: Date | string | null
    bio?: string | null
    dateOfBirth?: Date | string | null
    department?: string | null
    email_verified?: boolean
    gender?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    lockedUntil?: Date | string | null
    loginAttempts?: number
    position?: string | null
    admin_profile?: AdministrativeProfileUncheckedCreateNestedOneWithoutUserInput
    permission_audits?: PermissionAuditUncheckedCreateNestedManyWithoutUserInput
    access_logs?: UserAccessLogUncheckedCreateNestedManyWithoutUserInput
    emergency_contact?: UserEmergencyContactUncheckedCreateNestedOneWithoutUserInput
    ip_restrictions?: UserIPRestrictionUncheckedCreateNestedManyWithoutUserInput
    notification_settings?: UserNotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    privacy_settings?: UserPrivacySettingsUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    social_media?: UserSocialMediaUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAddressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAddressInput, UserUncheckedCreateWithoutAddressInput>
  }

  export type UserUpsertWithoutAddressInput = {
    update: XOR<UserUpdateWithoutAddressInput, UserUncheckedUpdateWithoutAddressInput>
    create: XOR<UserCreateWithoutAddressInput, UserUncheckedCreateWithoutAddressInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAddressInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAddressInput, UserUncheckedUpdateWithoutAddressInput>
  }

  export type UserUpdateWithoutAddressInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    position?: NullableStringFieldUpdateOperationsInput | string | null
    admin_profile?: AdministrativeProfileUpdateOneWithoutUserNestedInput
    permission_audits?: PermissionAuditUpdateManyWithoutUserNestedInput
    access_logs?: UserAccessLogUpdateManyWithoutUserNestedInput
    emergency_contact?: UserEmergencyContactUpdateOneWithoutUserNestedInput
    ip_restrictions?: UserIPRestrictionUpdateManyWithoutUserNestedInput
    notification_settings?: UserNotificationSettingsUpdateOneWithoutUserNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    privacy_settings?: UserPrivacySettingsUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    social_media?: UserSocialMediaUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    position?: NullableStringFieldUpdateOperationsInput | string | null
    admin_profile?: AdministrativeProfileUncheckedUpdateOneWithoutUserNestedInput
    permission_audits?: PermissionAuditUncheckedUpdateManyWithoutUserNestedInput
    access_logs?: UserAccessLogUncheckedUpdateManyWithoutUserNestedInput
    emergency_contact?: UserEmergencyContactUncheckedUpdateOneWithoutUserNestedInput
    ip_restrictions?: UserIPRestrictionUncheckedUpdateManyWithoutUserNestedInput
    notification_settings?: UserNotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    privacy_settings?: UserPrivacySettingsUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    social_media?: UserSocialMediaUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutEmergency_contactInput = {
    name: string
    username?: string | null
    email: string
    phone_number?: string | null
    password: string
    role?: string
    profile_picture?: string | null
    tokenVersion?: number
    created_at?: Date | string
    updated_at?: Date | string
    resetToken?: string | null
    resetTokenExp?: Date | string | null
    bio?: string | null
    dateOfBirth?: Date | string | null
    department?: string | null
    email_verified?: boolean
    gender?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    lockedUntil?: Date | string | null
    loginAttempts?: number
    position?: string | null
    admin_profile?: AdministrativeProfileCreateNestedOneWithoutUserInput
    permission_audits?: PermissionAuditCreateNestedManyWithoutUserInput
    access_logs?: UserAccessLogCreateNestedManyWithoutUserInput
    address?: UserAddressCreateNestedOneWithoutUserInput
    ip_restrictions?: UserIPRestrictionCreateNestedManyWithoutUserInput
    notification_settings?: UserNotificationSettingsCreateNestedOneWithoutUserInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    privacy_settings?: UserPrivacySettingsCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    social_media?: UserSocialMediaCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEmergency_contactInput = {
    id?: number
    name: string
    username?: string | null
    email: string
    phone_number?: string | null
    password: string
    role?: string
    profile_picture?: string | null
    tokenVersion?: number
    created_at?: Date | string
    updated_at?: Date | string
    resetToken?: string | null
    resetTokenExp?: Date | string | null
    bio?: string | null
    dateOfBirth?: Date | string | null
    department?: string | null
    email_verified?: boolean
    gender?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    lockedUntil?: Date | string | null
    loginAttempts?: number
    position?: string | null
    admin_profile?: AdministrativeProfileUncheckedCreateNestedOneWithoutUserInput
    permission_audits?: PermissionAuditUncheckedCreateNestedManyWithoutUserInput
    access_logs?: UserAccessLogUncheckedCreateNestedManyWithoutUserInput
    address?: UserAddressUncheckedCreateNestedOneWithoutUserInput
    ip_restrictions?: UserIPRestrictionUncheckedCreateNestedManyWithoutUserInput
    notification_settings?: UserNotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    privacy_settings?: UserPrivacySettingsUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    social_media?: UserSocialMediaUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEmergency_contactInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmergency_contactInput, UserUncheckedCreateWithoutEmergency_contactInput>
  }

  export type UserUpsertWithoutEmergency_contactInput = {
    update: XOR<UserUpdateWithoutEmergency_contactInput, UserUncheckedUpdateWithoutEmergency_contactInput>
    create: XOR<UserCreateWithoutEmergency_contactInput, UserUncheckedCreateWithoutEmergency_contactInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmergency_contactInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmergency_contactInput, UserUncheckedUpdateWithoutEmergency_contactInput>
  }

  export type UserUpdateWithoutEmergency_contactInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    position?: NullableStringFieldUpdateOperationsInput | string | null
    admin_profile?: AdministrativeProfileUpdateOneWithoutUserNestedInput
    permission_audits?: PermissionAuditUpdateManyWithoutUserNestedInput
    access_logs?: UserAccessLogUpdateManyWithoutUserNestedInput
    address?: UserAddressUpdateOneWithoutUserNestedInput
    ip_restrictions?: UserIPRestrictionUpdateManyWithoutUserNestedInput
    notification_settings?: UserNotificationSettingsUpdateOneWithoutUserNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    privacy_settings?: UserPrivacySettingsUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    social_media?: UserSocialMediaUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEmergency_contactInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    position?: NullableStringFieldUpdateOperationsInput | string | null
    admin_profile?: AdministrativeProfileUncheckedUpdateOneWithoutUserNestedInput
    permission_audits?: PermissionAuditUncheckedUpdateManyWithoutUserNestedInput
    access_logs?: UserAccessLogUncheckedUpdateManyWithoutUserNestedInput
    address?: UserAddressUncheckedUpdateOneWithoutUserNestedInput
    ip_restrictions?: UserIPRestrictionUncheckedUpdateManyWithoutUserNestedInput
    notification_settings?: UserNotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    privacy_settings?: UserPrivacySettingsUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    social_media?: UserSocialMediaUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutSocial_mediaInput = {
    name: string
    username?: string | null
    email: string
    phone_number?: string | null
    password: string
    role?: string
    profile_picture?: string | null
    tokenVersion?: number
    created_at?: Date | string
    updated_at?: Date | string
    resetToken?: string | null
    resetTokenExp?: Date | string | null
    bio?: string | null
    dateOfBirth?: Date | string | null
    department?: string | null
    email_verified?: boolean
    gender?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    lockedUntil?: Date | string | null
    loginAttempts?: number
    position?: string | null
    admin_profile?: AdministrativeProfileCreateNestedOneWithoutUserInput
    permission_audits?: PermissionAuditCreateNestedManyWithoutUserInput
    access_logs?: UserAccessLogCreateNestedManyWithoutUserInput
    address?: UserAddressCreateNestedOneWithoutUserInput
    emergency_contact?: UserEmergencyContactCreateNestedOneWithoutUserInput
    ip_restrictions?: UserIPRestrictionCreateNestedManyWithoutUserInput
    notification_settings?: UserNotificationSettingsCreateNestedOneWithoutUserInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    privacy_settings?: UserPrivacySettingsCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSocial_mediaInput = {
    id?: number
    name: string
    username?: string | null
    email: string
    phone_number?: string | null
    password: string
    role?: string
    profile_picture?: string | null
    tokenVersion?: number
    created_at?: Date | string
    updated_at?: Date | string
    resetToken?: string | null
    resetTokenExp?: Date | string | null
    bio?: string | null
    dateOfBirth?: Date | string | null
    department?: string | null
    email_verified?: boolean
    gender?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    lockedUntil?: Date | string | null
    loginAttempts?: number
    position?: string | null
    admin_profile?: AdministrativeProfileUncheckedCreateNestedOneWithoutUserInput
    permission_audits?: PermissionAuditUncheckedCreateNestedManyWithoutUserInput
    access_logs?: UserAccessLogUncheckedCreateNestedManyWithoutUserInput
    address?: UserAddressUncheckedCreateNestedOneWithoutUserInput
    emergency_contact?: UserEmergencyContactUncheckedCreateNestedOneWithoutUserInput
    ip_restrictions?: UserIPRestrictionUncheckedCreateNestedManyWithoutUserInput
    notification_settings?: UserNotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    privacy_settings?: UserPrivacySettingsUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSocial_mediaInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSocial_mediaInput, UserUncheckedCreateWithoutSocial_mediaInput>
  }

  export type UserUpsertWithoutSocial_mediaInput = {
    update: XOR<UserUpdateWithoutSocial_mediaInput, UserUncheckedUpdateWithoutSocial_mediaInput>
    create: XOR<UserCreateWithoutSocial_mediaInput, UserUncheckedCreateWithoutSocial_mediaInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSocial_mediaInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSocial_mediaInput, UserUncheckedUpdateWithoutSocial_mediaInput>
  }

  export type UserUpdateWithoutSocial_mediaInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    position?: NullableStringFieldUpdateOperationsInput | string | null
    admin_profile?: AdministrativeProfileUpdateOneWithoutUserNestedInput
    permission_audits?: PermissionAuditUpdateManyWithoutUserNestedInput
    access_logs?: UserAccessLogUpdateManyWithoutUserNestedInput
    address?: UserAddressUpdateOneWithoutUserNestedInput
    emergency_contact?: UserEmergencyContactUpdateOneWithoutUserNestedInput
    ip_restrictions?: UserIPRestrictionUpdateManyWithoutUserNestedInput
    notification_settings?: UserNotificationSettingsUpdateOneWithoutUserNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    privacy_settings?: UserPrivacySettingsUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSocial_mediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    position?: NullableStringFieldUpdateOperationsInput | string | null
    admin_profile?: AdministrativeProfileUncheckedUpdateOneWithoutUserNestedInput
    permission_audits?: PermissionAuditUncheckedUpdateManyWithoutUserNestedInput
    access_logs?: UserAccessLogUncheckedUpdateManyWithoutUserNestedInput
    address?: UserAddressUncheckedUpdateOneWithoutUserNestedInput
    emergency_contact?: UserEmergencyContactUncheckedUpdateOneWithoutUserNestedInput
    ip_restrictions?: UserIPRestrictionUncheckedUpdateManyWithoutUserNestedInput
    notification_settings?: UserNotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    privacy_settings?: UserPrivacySettingsUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPreferencesInput = {
    name: string
    username?: string | null
    email: string
    phone_number?: string | null
    password: string
    role?: string
    profile_picture?: string | null
    tokenVersion?: number
    created_at?: Date | string
    updated_at?: Date | string
    resetToken?: string | null
    resetTokenExp?: Date | string | null
    bio?: string | null
    dateOfBirth?: Date | string | null
    department?: string | null
    email_verified?: boolean
    gender?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    lockedUntil?: Date | string | null
    loginAttempts?: number
    position?: string | null
    admin_profile?: AdministrativeProfileCreateNestedOneWithoutUserInput
    permission_audits?: PermissionAuditCreateNestedManyWithoutUserInput
    access_logs?: UserAccessLogCreateNestedManyWithoutUserInput
    address?: UserAddressCreateNestedOneWithoutUserInput
    emergency_contact?: UserEmergencyContactCreateNestedOneWithoutUserInput
    ip_restrictions?: UserIPRestrictionCreateNestedManyWithoutUserInput
    notification_settings?: UserNotificationSettingsCreateNestedOneWithoutUserInput
    privacy_settings?: UserPrivacySettingsCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    social_media?: UserSocialMediaCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPreferencesInput = {
    id?: number
    name: string
    username?: string | null
    email: string
    phone_number?: string | null
    password: string
    role?: string
    profile_picture?: string | null
    tokenVersion?: number
    created_at?: Date | string
    updated_at?: Date | string
    resetToken?: string | null
    resetTokenExp?: Date | string | null
    bio?: string | null
    dateOfBirth?: Date | string | null
    department?: string | null
    email_verified?: boolean
    gender?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    lockedUntil?: Date | string | null
    loginAttempts?: number
    position?: string | null
    admin_profile?: AdministrativeProfileUncheckedCreateNestedOneWithoutUserInput
    permission_audits?: PermissionAuditUncheckedCreateNestedManyWithoutUserInput
    access_logs?: UserAccessLogUncheckedCreateNestedManyWithoutUserInput
    address?: UserAddressUncheckedCreateNestedOneWithoutUserInput
    emergency_contact?: UserEmergencyContactUncheckedCreateNestedOneWithoutUserInput
    ip_restrictions?: UserIPRestrictionUncheckedCreateNestedManyWithoutUserInput
    notification_settings?: UserNotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    privacy_settings?: UserPrivacySettingsUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    social_media?: UserSocialMediaUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPreferencesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
  }

  export type UserUpsertWithoutPreferencesInput = {
    update: XOR<UserUpdateWithoutPreferencesInput, UserUncheckedUpdateWithoutPreferencesInput>
    create: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPreferencesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPreferencesInput, UserUncheckedUpdateWithoutPreferencesInput>
  }

  export type UserUpdateWithoutPreferencesInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    position?: NullableStringFieldUpdateOperationsInput | string | null
    admin_profile?: AdministrativeProfileUpdateOneWithoutUserNestedInput
    permission_audits?: PermissionAuditUpdateManyWithoutUserNestedInput
    access_logs?: UserAccessLogUpdateManyWithoutUserNestedInput
    address?: UserAddressUpdateOneWithoutUserNestedInput
    emergency_contact?: UserEmergencyContactUpdateOneWithoutUserNestedInput
    ip_restrictions?: UserIPRestrictionUpdateManyWithoutUserNestedInput
    notification_settings?: UserNotificationSettingsUpdateOneWithoutUserNestedInput
    privacy_settings?: UserPrivacySettingsUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    social_media?: UserSocialMediaUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPreferencesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    position?: NullableStringFieldUpdateOperationsInput | string | null
    admin_profile?: AdministrativeProfileUncheckedUpdateOneWithoutUserNestedInput
    permission_audits?: PermissionAuditUncheckedUpdateManyWithoutUserNestedInput
    access_logs?: UserAccessLogUncheckedUpdateManyWithoutUserNestedInput
    address?: UserAddressUncheckedUpdateOneWithoutUserNestedInput
    emergency_contact?: UserEmergencyContactUncheckedUpdateOneWithoutUserNestedInput
    ip_restrictions?: UserIPRestrictionUncheckedUpdateManyWithoutUserNestedInput
    notification_settings?: UserNotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    privacy_settings?: UserPrivacySettingsUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    social_media?: UserSocialMediaUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutNotification_settingsInput = {
    name: string
    username?: string | null
    email: string
    phone_number?: string | null
    password: string
    role?: string
    profile_picture?: string | null
    tokenVersion?: number
    created_at?: Date | string
    updated_at?: Date | string
    resetToken?: string | null
    resetTokenExp?: Date | string | null
    bio?: string | null
    dateOfBirth?: Date | string | null
    department?: string | null
    email_verified?: boolean
    gender?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    lockedUntil?: Date | string | null
    loginAttempts?: number
    position?: string | null
    admin_profile?: AdministrativeProfileCreateNestedOneWithoutUserInput
    permission_audits?: PermissionAuditCreateNestedManyWithoutUserInput
    access_logs?: UserAccessLogCreateNestedManyWithoutUserInput
    address?: UserAddressCreateNestedOneWithoutUserInput
    emergency_contact?: UserEmergencyContactCreateNestedOneWithoutUserInput
    ip_restrictions?: UserIPRestrictionCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    privacy_settings?: UserPrivacySettingsCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    social_media?: UserSocialMediaCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotification_settingsInput = {
    id?: number
    name: string
    username?: string | null
    email: string
    phone_number?: string | null
    password: string
    role?: string
    profile_picture?: string | null
    tokenVersion?: number
    created_at?: Date | string
    updated_at?: Date | string
    resetToken?: string | null
    resetTokenExp?: Date | string | null
    bio?: string | null
    dateOfBirth?: Date | string | null
    department?: string | null
    email_verified?: boolean
    gender?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    lockedUntil?: Date | string | null
    loginAttempts?: number
    position?: string | null
    admin_profile?: AdministrativeProfileUncheckedCreateNestedOneWithoutUserInput
    permission_audits?: PermissionAuditUncheckedCreateNestedManyWithoutUserInput
    access_logs?: UserAccessLogUncheckedCreateNestedManyWithoutUserInput
    address?: UserAddressUncheckedCreateNestedOneWithoutUserInput
    emergency_contact?: UserEmergencyContactUncheckedCreateNestedOneWithoutUserInput
    ip_restrictions?: UserIPRestrictionUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    privacy_settings?: UserPrivacySettingsUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    social_media?: UserSocialMediaUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotification_settingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotification_settingsInput, UserUncheckedCreateWithoutNotification_settingsInput>
  }

  export type UserUpsertWithoutNotification_settingsInput = {
    update: XOR<UserUpdateWithoutNotification_settingsInput, UserUncheckedUpdateWithoutNotification_settingsInput>
    create: XOR<UserCreateWithoutNotification_settingsInput, UserUncheckedCreateWithoutNotification_settingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotification_settingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotification_settingsInput, UserUncheckedUpdateWithoutNotification_settingsInput>
  }

  export type UserUpdateWithoutNotification_settingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    position?: NullableStringFieldUpdateOperationsInput | string | null
    admin_profile?: AdministrativeProfileUpdateOneWithoutUserNestedInput
    permission_audits?: PermissionAuditUpdateManyWithoutUserNestedInput
    access_logs?: UserAccessLogUpdateManyWithoutUserNestedInput
    address?: UserAddressUpdateOneWithoutUserNestedInput
    emergency_contact?: UserEmergencyContactUpdateOneWithoutUserNestedInput
    ip_restrictions?: UserIPRestrictionUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    privacy_settings?: UserPrivacySettingsUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    social_media?: UserSocialMediaUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotification_settingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    position?: NullableStringFieldUpdateOperationsInput | string | null
    admin_profile?: AdministrativeProfileUncheckedUpdateOneWithoutUserNestedInput
    permission_audits?: PermissionAuditUncheckedUpdateManyWithoutUserNestedInput
    access_logs?: UserAccessLogUncheckedUpdateManyWithoutUserNestedInput
    address?: UserAddressUncheckedUpdateOneWithoutUserNestedInput
    emergency_contact?: UserEmergencyContactUncheckedUpdateOneWithoutUserNestedInput
    ip_restrictions?: UserIPRestrictionUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    privacy_settings?: UserPrivacySettingsUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    social_media?: UserSocialMediaUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutPrivacy_settingsInput = {
    name: string
    username?: string | null
    email: string
    phone_number?: string | null
    password: string
    role?: string
    profile_picture?: string | null
    tokenVersion?: number
    created_at?: Date | string
    updated_at?: Date | string
    resetToken?: string | null
    resetTokenExp?: Date | string | null
    bio?: string | null
    dateOfBirth?: Date | string | null
    department?: string | null
    email_verified?: boolean
    gender?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    lockedUntil?: Date | string | null
    loginAttempts?: number
    position?: string | null
    admin_profile?: AdministrativeProfileCreateNestedOneWithoutUserInput
    permission_audits?: PermissionAuditCreateNestedManyWithoutUserInput
    access_logs?: UserAccessLogCreateNestedManyWithoutUserInput
    address?: UserAddressCreateNestedOneWithoutUserInput
    emergency_contact?: UserEmergencyContactCreateNestedOneWithoutUserInput
    ip_restrictions?: UserIPRestrictionCreateNestedManyWithoutUserInput
    notification_settings?: UserNotificationSettingsCreateNestedOneWithoutUserInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    social_media?: UserSocialMediaCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPrivacy_settingsInput = {
    id?: number
    name: string
    username?: string | null
    email: string
    phone_number?: string | null
    password: string
    role?: string
    profile_picture?: string | null
    tokenVersion?: number
    created_at?: Date | string
    updated_at?: Date | string
    resetToken?: string | null
    resetTokenExp?: Date | string | null
    bio?: string | null
    dateOfBirth?: Date | string | null
    department?: string | null
    email_verified?: boolean
    gender?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    lockedUntil?: Date | string | null
    loginAttempts?: number
    position?: string | null
    admin_profile?: AdministrativeProfileUncheckedCreateNestedOneWithoutUserInput
    permission_audits?: PermissionAuditUncheckedCreateNestedManyWithoutUserInput
    access_logs?: UserAccessLogUncheckedCreateNestedManyWithoutUserInput
    address?: UserAddressUncheckedCreateNestedOneWithoutUserInput
    emergency_contact?: UserEmergencyContactUncheckedCreateNestedOneWithoutUserInput
    ip_restrictions?: UserIPRestrictionUncheckedCreateNestedManyWithoutUserInput
    notification_settings?: UserNotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    social_media?: UserSocialMediaUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPrivacy_settingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPrivacy_settingsInput, UserUncheckedCreateWithoutPrivacy_settingsInput>
  }

  export type UserUpsertWithoutPrivacy_settingsInput = {
    update: XOR<UserUpdateWithoutPrivacy_settingsInput, UserUncheckedUpdateWithoutPrivacy_settingsInput>
    create: XOR<UserCreateWithoutPrivacy_settingsInput, UserUncheckedCreateWithoutPrivacy_settingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPrivacy_settingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPrivacy_settingsInput, UserUncheckedUpdateWithoutPrivacy_settingsInput>
  }

  export type UserUpdateWithoutPrivacy_settingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    position?: NullableStringFieldUpdateOperationsInput | string | null
    admin_profile?: AdministrativeProfileUpdateOneWithoutUserNestedInput
    permission_audits?: PermissionAuditUpdateManyWithoutUserNestedInput
    access_logs?: UserAccessLogUpdateManyWithoutUserNestedInput
    address?: UserAddressUpdateOneWithoutUserNestedInput
    emergency_contact?: UserEmergencyContactUpdateOneWithoutUserNestedInput
    ip_restrictions?: UserIPRestrictionUpdateManyWithoutUserNestedInput
    notification_settings?: UserNotificationSettingsUpdateOneWithoutUserNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    social_media?: UserSocialMediaUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPrivacy_settingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    position?: NullableStringFieldUpdateOperationsInput | string | null
    admin_profile?: AdministrativeProfileUncheckedUpdateOneWithoutUserNestedInput
    permission_audits?: PermissionAuditUncheckedUpdateManyWithoutUserNestedInput
    access_logs?: UserAccessLogUncheckedUpdateManyWithoutUserNestedInput
    address?: UserAddressUncheckedUpdateOneWithoutUserNestedInput
    emergency_contact?: UserEmergencyContactUncheckedUpdateOneWithoutUserNestedInput
    ip_restrictions?: UserIPRestrictionUncheckedUpdateManyWithoutUserNestedInput
    notification_settings?: UserNotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    social_media?: UserSocialMediaUncheckedUpdateOneWithoutUserNestedInput
  }

  export type AddressCreateWithoutMemberInput = {
    id?: string
    street: string
    city: string
    state: string
    zipCode: string
    country?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUncheckedCreateWithoutMemberInput = {
    id?: string
    street: string
    city: string
    state: string
    zipCode: string
    country?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressCreateOrConnectWithoutMemberInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutMemberInput, AddressUncheckedCreateWithoutMemberInput>
  }

  export type EmergencyContactCreateWithoutMemberInput = {
    id?: string
    name: string
    relationship: string
    phone: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmergencyContactUncheckedCreateWithoutMemberInput = {
    id?: string
    name: string
    relationship: string
    phone: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmergencyContactCreateOrConnectWithoutMemberInput = {
    where: EmergencyContactWhereUniqueInput
    create: XOR<EmergencyContactCreateWithoutMemberInput, EmergencyContactUncheckedCreateWithoutMemberInput>
  }

  export type InvoiceCreateWithoutMemberInput = {
    id?: string
    amount: number
    details: string
    createdAt?: Date | string
  }

  export type InvoiceUncheckedCreateWithoutMemberInput = {
    id?: string
    amount: number
    details: string
    createdAt?: Date | string
  }

  export type InvoiceCreateOrConnectWithoutMemberInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutMemberInput, InvoiceUncheckedCreateWithoutMemberInput>
  }

  export type InvoiceCreateManyMemberInputEnvelope = {
    data: InvoiceCreateManyMemberInput | InvoiceCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type MedicalInfoCreateWithoutMemberInput = {
    id?: string
    fitness_goals?: MedicalInfoCreatefitness_goalsInput | string[]
    health_conditions?: MedicalInfoCreatehealth_conditionsInput | string[]
    allergies?: MedicalInfoCreateallergiesInput | string[]
    medications?: MedicalInfoCreatemedicationsInput | string[]
    emergency_notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalInfoUncheckedCreateWithoutMemberInput = {
    id?: string
    fitness_goals?: MedicalInfoCreatefitness_goalsInput | string[]
    health_conditions?: MedicalInfoCreatehealth_conditionsInput | string[]
    allergies?: MedicalInfoCreateallergiesInput | string[]
    medications?: MedicalInfoCreatemedicationsInput | string[]
    emergency_notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalInfoCreateOrConnectWithoutMemberInput = {
    where: MedicalInfoWhereUniqueInput
    create: XOR<MedicalInfoCreateWithoutMemberInput, MedicalInfoUncheckedCreateWithoutMemberInput>
  }

  export type MemberAttendanceCreateWithoutMemberInput = {
    id?: string
    date: Date | string
    timeIn: Date | string
    timeOut?: Date | string | null
    duration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberAttendanceUncheckedCreateWithoutMemberInput = {
    id?: string
    date: Date | string
    timeIn: Date | string
    timeOut?: Date | string | null
    duration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberAttendanceCreateOrConnectWithoutMemberInput = {
    where: MemberAttendanceWhereUniqueInput
    create: XOR<MemberAttendanceCreateWithoutMemberInput, MemberAttendanceUncheckedCreateWithoutMemberInput>
  }

  export type MemberAttendanceCreateManyMemberInputEnvelope = {
    data: MemberAttendanceCreateManyMemberInput | MemberAttendanceCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type MemberCheckInCreateWithoutMemberInput = {
    id?: string
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    location?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberCheckInUncheckedCreateWithoutMemberInput = {
    id?: string
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    location?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberCheckInCreateOrConnectWithoutMemberInput = {
    where: MemberCheckInWhereUniqueInput
    create: XOR<MemberCheckInCreateWithoutMemberInput, MemberCheckInUncheckedCreateWithoutMemberInput>
  }

  export type MemberCheckInCreateManyMemberInputEnvelope = {
    data: MemberCheckInCreateManyMemberInput | MemberCheckInCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type MemberFitnessGoalCreateWithoutMemberInput = {
    id?: string
    goalType: string
    targetValue: number
    currentValue: number
    unit: string
    targetDate?: Date | string | null
    isCompleted?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberFitnessGoalUncheckedCreateWithoutMemberInput = {
    id?: string
    goalType: string
    targetValue: number
    currentValue: number
    unit: string
    targetDate?: Date | string | null
    isCompleted?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberFitnessGoalCreateOrConnectWithoutMemberInput = {
    where: MemberFitnessGoalWhereUniqueInput
    create: XOR<MemberFitnessGoalCreateWithoutMemberInput, MemberFitnessGoalUncheckedCreateWithoutMemberInput>
  }

  export type MemberFitnessGoalCreateManyMemberInputEnvelope = {
    data: MemberFitnessGoalCreateManyMemberInput | MemberFitnessGoalCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutMemberInput = {
    id?: string
    amount: number
    method: string
    createdAt?: Date | string
    status?: string
    description?: string | null
    reference?: string | null
    updatedAt?: Date | string
  }

  export type PaymentUncheckedCreateWithoutMemberInput = {
    id?: string
    amount: number
    method: string
    createdAt?: Date | string
    status?: string
    description?: string | null
    reference?: string | null
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutMemberInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutMemberInput, PaymentUncheckedCreateWithoutMemberInput>
  }

  export type PaymentCreateManyMemberInputEnvelope = {
    data: PaymentCreateManyMemberInput | PaymentCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutMemberInput = {
    id?: string
    startDate?: Date | string
    endDate: Date | string
    plan: MembershipPlanCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateWithoutMemberInput = {
    id?: string
    planId: string
    startDate?: Date | string
    endDate: Date | string
  }

  export type SubscriptionCreateOrConnectWithoutMemberInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutMemberInput, SubscriptionUncheckedCreateWithoutMemberInput>
  }

  export type SubscriptionCreateManyMemberInputEnvelope = {
    data: SubscriptionCreateManyMemberInput | SubscriptionCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type AddressUpsertWithoutMemberInput = {
    update: XOR<AddressUpdateWithoutMemberInput, AddressUncheckedUpdateWithoutMemberInput>
    create: XOR<AddressCreateWithoutMemberInput, AddressUncheckedCreateWithoutMemberInput>
    where?: AddressWhereInput
  }

  export type AddressUpdateToOneWithWhereWithoutMemberInput = {
    where?: AddressWhereInput
    data: XOR<AddressUpdateWithoutMemberInput, AddressUncheckedUpdateWithoutMemberInput>
  }

  export type AddressUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmergencyContactUpsertWithoutMemberInput = {
    update: XOR<EmergencyContactUpdateWithoutMemberInput, EmergencyContactUncheckedUpdateWithoutMemberInput>
    create: XOR<EmergencyContactCreateWithoutMemberInput, EmergencyContactUncheckedCreateWithoutMemberInput>
    where?: EmergencyContactWhereInput
  }

  export type EmergencyContactUpdateToOneWithWhereWithoutMemberInput = {
    where?: EmergencyContactWhereInput
    data: XOR<EmergencyContactUpdateWithoutMemberInput, EmergencyContactUncheckedUpdateWithoutMemberInput>
  }

  export type EmergencyContactUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmergencyContactUncheckedUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutMemberInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutMemberInput, InvoiceUncheckedUpdateWithoutMemberInput>
    create: XOR<InvoiceCreateWithoutMemberInput, InvoiceUncheckedCreateWithoutMemberInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutMemberInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutMemberInput, InvoiceUncheckedUpdateWithoutMemberInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutMemberInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutMemberInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: StringFilter<"Invoice"> | string
    memberId?: StringFilter<"Invoice"> | string
    amount?: FloatFilter<"Invoice"> | number
    details?: StringFilter<"Invoice"> | string
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
  }

  export type MedicalInfoUpsertWithoutMemberInput = {
    update: XOR<MedicalInfoUpdateWithoutMemberInput, MedicalInfoUncheckedUpdateWithoutMemberInput>
    create: XOR<MedicalInfoCreateWithoutMemberInput, MedicalInfoUncheckedCreateWithoutMemberInput>
    where?: MedicalInfoWhereInput
  }

  export type MedicalInfoUpdateToOneWithWhereWithoutMemberInput = {
    where?: MedicalInfoWhereInput
    data: XOR<MedicalInfoUpdateWithoutMemberInput, MedicalInfoUncheckedUpdateWithoutMemberInput>
  }

  export type MedicalInfoUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    fitness_goals?: MedicalInfoUpdatefitness_goalsInput | string[]
    health_conditions?: MedicalInfoUpdatehealth_conditionsInput | string[]
    allergies?: MedicalInfoUpdateallergiesInput | string[]
    medications?: MedicalInfoUpdatemedicationsInput | string[]
    emergency_notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalInfoUncheckedUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    fitness_goals?: MedicalInfoUpdatefitness_goalsInput | string[]
    health_conditions?: MedicalInfoUpdatehealth_conditionsInput | string[]
    allergies?: MedicalInfoUpdateallergiesInput | string[]
    medications?: MedicalInfoUpdatemedicationsInput | string[]
    emergency_notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberAttendanceUpsertWithWhereUniqueWithoutMemberInput = {
    where: MemberAttendanceWhereUniqueInput
    update: XOR<MemberAttendanceUpdateWithoutMemberInput, MemberAttendanceUncheckedUpdateWithoutMemberInput>
    create: XOR<MemberAttendanceCreateWithoutMemberInput, MemberAttendanceUncheckedCreateWithoutMemberInput>
  }

  export type MemberAttendanceUpdateWithWhereUniqueWithoutMemberInput = {
    where: MemberAttendanceWhereUniqueInput
    data: XOR<MemberAttendanceUpdateWithoutMemberInput, MemberAttendanceUncheckedUpdateWithoutMemberInput>
  }

  export type MemberAttendanceUpdateManyWithWhereWithoutMemberInput = {
    where: MemberAttendanceScalarWhereInput
    data: XOR<MemberAttendanceUpdateManyMutationInput, MemberAttendanceUncheckedUpdateManyWithoutMemberInput>
  }

  export type MemberAttendanceScalarWhereInput = {
    AND?: MemberAttendanceScalarWhereInput | MemberAttendanceScalarWhereInput[]
    OR?: MemberAttendanceScalarWhereInput[]
    NOT?: MemberAttendanceScalarWhereInput | MemberAttendanceScalarWhereInput[]
    id?: StringFilter<"MemberAttendance"> | string
    memberId?: StringFilter<"MemberAttendance"> | string
    date?: DateTimeFilter<"MemberAttendance"> | Date | string
    timeIn?: DateTimeFilter<"MemberAttendance"> | Date | string
    timeOut?: DateTimeNullableFilter<"MemberAttendance"> | Date | string | null
    duration?: IntNullableFilter<"MemberAttendance"> | number | null
    createdAt?: DateTimeFilter<"MemberAttendance"> | Date | string
    updatedAt?: DateTimeFilter<"MemberAttendance"> | Date | string
  }

  export type MemberCheckInUpsertWithWhereUniqueWithoutMemberInput = {
    where: MemberCheckInWhereUniqueInput
    update: XOR<MemberCheckInUpdateWithoutMemberInput, MemberCheckInUncheckedUpdateWithoutMemberInput>
    create: XOR<MemberCheckInCreateWithoutMemberInput, MemberCheckInUncheckedCreateWithoutMemberInput>
  }

  export type MemberCheckInUpdateWithWhereUniqueWithoutMemberInput = {
    where: MemberCheckInWhereUniqueInput
    data: XOR<MemberCheckInUpdateWithoutMemberInput, MemberCheckInUncheckedUpdateWithoutMemberInput>
  }

  export type MemberCheckInUpdateManyWithWhereWithoutMemberInput = {
    where: MemberCheckInScalarWhereInput
    data: XOR<MemberCheckInUpdateManyMutationInput, MemberCheckInUncheckedUpdateManyWithoutMemberInput>
  }

  export type MemberCheckInScalarWhereInput = {
    AND?: MemberCheckInScalarWhereInput | MemberCheckInScalarWhereInput[]
    OR?: MemberCheckInScalarWhereInput[]
    NOT?: MemberCheckInScalarWhereInput | MemberCheckInScalarWhereInput[]
    id?: StringFilter<"MemberCheckIn"> | string
    memberId?: StringFilter<"MemberCheckIn"> | string
    checkInTime?: DateTimeFilter<"MemberCheckIn"> | Date | string
    checkOutTime?: DateTimeNullableFilter<"MemberCheckIn"> | Date | string | null
    location?: StringNullableFilter<"MemberCheckIn"> | string | null
    notes?: StringNullableFilter<"MemberCheckIn"> | string | null
    createdAt?: DateTimeFilter<"MemberCheckIn"> | Date | string
    updatedAt?: DateTimeFilter<"MemberCheckIn"> | Date | string
  }

  export type MemberFitnessGoalUpsertWithWhereUniqueWithoutMemberInput = {
    where: MemberFitnessGoalWhereUniqueInput
    update: XOR<MemberFitnessGoalUpdateWithoutMemberInput, MemberFitnessGoalUncheckedUpdateWithoutMemberInput>
    create: XOR<MemberFitnessGoalCreateWithoutMemberInput, MemberFitnessGoalUncheckedCreateWithoutMemberInput>
  }

  export type MemberFitnessGoalUpdateWithWhereUniqueWithoutMemberInput = {
    where: MemberFitnessGoalWhereUniqueInput
    data: XOR<MemberFitnessGoalUpdateWithoutMemberInput, MemberFitnessGoalUncheckedUpdateWithoutMemberInput>
  }

  export type MemberFitnessGoalUpdateManyWithWhereWithoutMemberInput = {
    where: MemberFitnessGoalScalarWhereInput
    data: XOR<MemberFitnessGoalUpdateManyMutationInput, MemberFitnessGoalUncheckedUpdateManyWithoutMemberInput>
  }

  export type MemberFitnessGoalScalarWhereInput = {
    AND?: MemberFitnessGoalScalarWhereInput | MemberFitnessGoalScalarWhereInput[]
    OR?: MemberFitnessGoalScalarWhereInput[]
    NOT?: MemberFitnessGoalScalarWhereInput | MemberFitnessGoalScalarWhereInput[]
    id?: StringFilter<"MemberFitnessGoal"> | string
    memberId?: StringFilter<"MemberFitnessGoal"> | string
    goalType?: StringFilter<"MemberFitnessGoal"> | string
    targetValue?: FloatFilter<"MemberFitnessGoal"> | number
    currentValue?: FloatFilter<"MemberFitnessGoal"> | number
    unit?: StringFilter<"MemberFitnessGoal"> | string
    targetDate?: DateTimeNullableFilter<"MemberFitnessGoal"> | Date | string | null
    isCompleted?: BoolFilter<"MemberFitnessGoal"> | boolean
    notes?: StringNullableFilter<"MemberFitnessGoal"> | string | null
    createdAt?: DateTimeFilter<"MemberFitnessGoal"> | Date | string
    updatedAt?: DateTimeFilter<"MemberFitnessGoal"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutMemberInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutMemberInput, PaymentUncheckedUpdateWithoutMemberInput>
    create: XOR<PaymentCreateWithoutMemberInput, PaymentUncheckedCreateWithoutMemberInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutMemberInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutMemberInput, PaymentUncheckedUpdateWithoutMemberInput>
  }

  export type PaymentUpdateManyWithWhereWithoutMemberInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutMemberInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    memberId?: StringFilter<"Payment"> | string
    method?: StringFilter<"Payment"> | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    status?: StringFilter<"Payment"> | string
    description?: StringNullableFilter<"Payment"> | string | null
    reference?: StringNullableFilter<"Payment"> | string | null
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutMemberInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutMemberInput, SubscriptionUncheckedUpdateWithoutMemberInput>
    create: XOR<SubscriptionCreateWithoutMemberInput, SubscriptionUncheckedCreateWithoutMemberInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutMemberInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutMemberInput, SubscriptionUncheckedUpdateWithoutMemberInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutMemberInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutMemberInput>
  }

  export type SubscriptionScalarWhereInput = {
    AND?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    OR?: SubscriptionScalarWhereInput[]
    NOT?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    id?: StringFilter<"Subscription"> | string
    memberId?: StringFilter<"Subscription"> | string
    planId?: StringFilter<"Subscription"> | string
    startDate?: DateTimeFilter<"Subscription"> | Date | string
    endDate?: DateTimeFilter<"Subscription"> | Date | string
  }

  export type MemberCreateWithoutCheck_insInput = {
    id?: string
    name: string
    email: string
    phone_number?: string | null
    password: string
    age: number
    profile_picture?: string | null
    membershiptype: $Enums.MemberShipType
    createdAt?: Date | string
    updatedAt?: Date | string
    email_verification_expires?: Date | string | null
    email_verification_token?: string | null
    email_verified?: boolean
    terms_accepted?: boolean
    terms_accepted_at?: Date | string | null
    address?: AddressCreateNestedOneWithoutMemberInput
    emergency_contact?: EmergencyContactCreateNestedOneWithoutMemberInput
    invoices?: InvoiceCreateNestedManyWithoutMemberInput
    medical_info?: MedicalInfoCreateNestedOneWithoutMemberInput
    attendance?: MemberAttendanceCreateNestedManyWithoutMemberInput
    fitness_goals?: MemberFitnessGoalCreateNestedManyWithoutMemberInput
    payments?: PaymentCreateNestedManyWithoutMemberInput
    Subscription?: SubscriptionCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutCheck_insInput = {
    id?: string
    name: string
    email: string
    phone_number?: string | null
    password: string
    age: number
    profile_picture?: string | null
    membershiptype: $Enums.MemberShipType
    createdAt?: Date | string
    updatedAt?: Date | string
    email_verification_expires?: Date | string | null
    email_verification_token?: string | null
    email_verified?: boolean
    terms_accepted?: boolean
    terms_accepted_at?: Date | string | null
    address?: AddressUncheckedCreateNestedOneWithoutMemberInput
    emergency_contact?: EmergencyContactUncheckedCreateNestedOneWithoutMemberInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutMemberInput
    medical_info?: MedicalInfoUncheckedCreateNestedOneWithoutMemberInput
    attendance?: MemberAttendanceUncheckedCreateNestedManyWithoutMemberInput
    fitness_goals?: MemberFitnessGoalUncheckedCreateNestedManyWithoutMemberInput
    payments?: PaymentUncheckedCreateNestedManyWithoutMemberInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutCheck_insInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutCheck_insInput, MemberUncheckedCreateWithoutCheck_insInput>
  }

  export type MemberUpsertWithoutCheck_insInput = {
    update: XOR<MemberUpdateWithoutCheck_insInput, MemberUncheckedUpdateWithoutCheck_insInput>
    create: XOR<MemberCreateWithoutCheck_insInput, MemberUncheckedCreateWithoutCheck_insInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutCheck_insInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutCheck_insInput, MemberUncheckedUpdateWithoutCheck_insInput>
  }

  export type MemberUpdateWithoutCheck_insInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    membershiptype?: EnumMemberShipTypeFieldUpdateOperationsInput | $Enums.MemberShipType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verification_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: AddressUpdateOneWithoutMemberNestedInput
    emergency_contact?: EmergencyContactUpdateOneWithoutMemberNestedInput
    invoices?: InvoiceUpdateManyWithoutMemberNestedInput
    medical_info?: MedicalInfoUpdateOneWithoutMemberNestedInput
    attendance?: MemberAttendanceUpdateManyWithoutMemberNestedInput
    fitness_goals?: MemberFitnessGoalUpdateManyWithoutMemberNestedInput
    payments?: PaymentUpdateManyWithoutMemberNestedInput
    Subscription?: SubscriptionUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutCheck_insInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    membershiptype?: EnumMemberShipTypeFieldUpdateOperationsInput | $Enums.MemberShipType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verification_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: AddressUncheckedUpdateOneWithoutMemberNestedInput
    emergency_contact?: EmergencyContactUncheckedUpdateOneWithoutMemberNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutMemberNestedInput
    medical_info?: MedicalInfoUncheckedUpdateOneWithoutMemberNestedInput
    attendance?: MemberAttendanceUncheckedUpdateManyWithoutMemberNestedInput
    fitness_goals?: MemberFitnessGoalUncheckedUpdateManyWithoutMemberNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutMemberNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type MemberCreateWithoutAttendanceInput = {
    id?: string
    name: string
    email: string
    phone_number?: string | null
    password: string
    age: number
    profile_picture?: string | null
    membershiptype: $Enums.MemberShipType
    createdAt?: Date | string
    updatedAt?: Date | string
    email_verification_expires?: Date | string | null
    email_verification_token?: string | null
    email_verified?: boolean
    terms_accepted?: boolean
    terms_accepted_at?: Date | string | null
    address?: AddressCreateNestedOneWithoutMemberInput
    emergency_contact?: EmergencyContactCreateNestedOneWithoutMemberInput
    invoices?: InvoiceCreateNestedManyWithoutMemberInput
    medical_info?: MedicalInfoCreateNestedOneWithoutMemberInput
    check_ins?: MemberCheckInCreateNestedManyWithoutMemberInput
    fitness_goals?: MemberFitnessGoalCreateNestedManyWithoutMemberInput
    payments?: PaymentCreateNestedManyWithoutMemberInput
    Subscription?: SubscriptionCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutAttendanceInput = {
    id?: string
    name: string
    email: string
    phone_number?: string | null
    password: string
    age: number
    profile_picture?: string | null
    membershiptype: $Enums.MemberShipType
    createdAt?: Date | string
    updatedAt?: Date | string
    email_verification_expires?: Date | string | null
    email_verification_token?: string | null
    email_verified?: boolean
    terms_accepted?: boolean
    terms_accepted_at?: Date | string | null
    address?: AddressUncheckedCreateNestedOneWithoutMemberInput
    emergency_contact?: EmergencyContactUncheckedCreateNestedOneWithoutMemberInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutMemberInput
    medical_info?: MedicalInfoUncheckedCreateNestedOneWithoutMemberInput
    check_ins?: MemberCheckInUncheckedCreateNestedManyWithoutMemberInput
    fitness_goals?: MemberFitnessGoalUncheckedCreateNestedManyWithoutMemberInput
    payments?: PaymentUncheckedCreateNestedManyWithoutMemberInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutAttendanceInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutAttendanceInput, MemberUncheckedCreateWithoutAttendanceInput>
  }

  export type MemberUpsertWithoutAttendanceInput = {
    update: XOR<MemberUpdateWithoutAttendanceInput, MemberUncheckedUpdateWithoutAttendanceInput>
    create: XOR<MemberCreateWithoutAttendanceInput, MemberUncheckedCreateWithoutAttendanceInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutAttendanceInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutAttendanceInput, MemberUncheckedUpdateWithoutAttendanceInput>
  }

  export type MemberUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    membershiptype?: EnumMemberShipTypeFieldUpdateOperationsInput | $Enums.MemberShipType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verification_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: AddressUpdateOneWithoutMemberNestedInput
    emergency_contact?: EmergencyContactUpdateOneWithoutMemberNestedInput
    invoices?: InvoiceUpdateManyWithoutMemberNestedInput
    medical_info?: MedicalInfoUpdateOneWithoutMemberNestedInput
    check_ins?: MemberCheckInUpdateManyWithoutMemberNestedInput
    fitness_goals?: MemberFitnessGoalUpdateManyWithoutMemberNestedInput
    payments?: PaymentUpdateManyWithoutMemberNestedInput
    Subscription?: SubscriptionUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    membershiptype?: EnumMemberShipTypeFieldUpdateOperationsInput | $Enums.MemberShipType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verification_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: AddressUncheckedUpdateOneWithoutMemberNestedInput
    emergency_contact?: EmergencyContactUncheckedUpdateOneWithoutMemberNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutMemberNestedInput
    medical_info?: MedicalInfoUncheckedUpdateOneWithoutMemberNestedInput
    check_ins?: MemberCheckInUncheckedUpdateManyWithoutMemberNestedInput
    fitness_goals?: MemberFitnessGoalUncheckedUpdateManyWithoutMemberNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutMemberNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type MemberCreateWithoutFitness_goalsInput = {
    id?: string
    name: string
    email: string
    phone_number?: string | null
    password: string
    age: number
    profile_picture?: string | null
    membershiptype: $Enums.MemberShipType
    createdAt?: Date | string
    updatedAt?: Date | string
    email_verification_expires?: Date | string | null
    email_verification_token?: string | null
    email_verified?: boolean
    terms_accepted?: boolean
    terms_accepted_at?: Date | string | null
    address?: AddressCreateNestedOneWithoutMemberInput
    emergency_contact?: EmergencyContactCreateNestedOneWithoutMemberInput
    invoices?: InvoiceCreateNestedManyWithoutMemberInput
    medical_info?: MedicalInfoCreateNestedOneWithoutMemberInput
    attendance?: MemberAttendanceCreateNestedManyWithoutMemberInput
    check_ins?: MemberCheckInCreateNestedManyWithoutMemberInput
    payments?: PaymentCreateNestedManyWithoutMemberInput
    Subscription?: SubscriptionCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutFitness_goalsInput = {
    id?: string
    name: string
    email: string
    phone_number?: string | null
    password: string
    age: number
    profile_picture?: string | null
    membershiptype: $Enums.MemberShipType
    createdAt?: Date | string
    updatedAt?: Date | string
    email_verification_expires?: Date | string | null
    email_verification_token?: string | null
    email_verified?: boolean
    terms_accepted?: boolean
    terms_accepted_at?: Date | string | null
    address?: AddressUncheckedCreateNestedOneWithoutMemberInput
    emergency_contact?: EmergencyContactUncheckedCreateNestedOneWithoutMemberInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutMemberInput
    medical_info?: MedicalInfoUncheckedCreateNestedOneWithoutMemberInput
    attendance?: MemberAttendanceUncheckedCreateNestedManyWithoutMemberInput
    check_ins?: MemberCheckInUncheckedCreateNestedManyWithoutMemberInput
    payments?: PaymentUncheckedCreateNestedManyWithoutMemberInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutFitness_goalsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutFitness_goalsInput, MemberUncheckedCreateWithoutFitness_goalsInput>
  }

  export type MemberUpsertWithoutFitness_goalsInput = {
    update: XOR<MemberUpdateWithoutFitness_goalsInput, MemberUncheckedUpdateWithoutFitness_goalsInput>
    create: XOR<MemberCreateWithoutFitness_goalsInput, MemberUncheckedCreateWithoutFitness_goalsInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutFitness_goalsInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutFitness_goalsInput, MemberUncheckedUpdateWithoutFitness_goalsInput>
  }

  export type MemberUpdateWithoutFitness_goalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    membershiptype?: EnumMemberShipTypeFieldUpdateOperationsInput | $Enums.MemberShipType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verification_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: AddressUpdateOneWithoutMemberNestedInput
    emergency_contact?: EmergencyContactUpdateOneWithoutMemberNestedInput
    invoices?: InvoiceUpdateManyWithoutMemberNestedInput
    medical_info?: MedicalInfoUpdateOneWithoutMemberNestedInput
    attendance?: MemberAttendanceUpdateManyWithoutMemberNestedInput
    check_ins?: MemberCheckInUpdateManyWithoutMemberNestedInput
    payments?: PaymentUpdateManyWithoutMemberNestedInput
    Subscription?: SubscriptionUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutFitness_goalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    membershiptype?: EnumMemberShipTypeFieldUpdateOperationsInput | $Enums.MemberShipType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verification_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: AddressUncheckedUpdateOneWithoutMemberNestedInput
    emergency_contact?: EmergencyContactUncheckedUpdateOneWithoutMemberNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutMemberNestedInput
    medical_info?: MedicalInfoUncheckedUpdateOneWithoutMemberNestedInput
    attendance?: MemberAttendanceUncheckedUpdateManyWithoutMemberNestedInput
    check_ins?: MemberCheckInUncheckedUpdateManyWithoutMemberNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutMemberNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type MemberCreateWithoutAddressInput = {
    id?: string
    name: string
    email: string
    phone_number?: string | null
    password: string
    age: number
    profile_picture?: string | null
    membershiptype: $Enums.MemberShipType
    createdAt?: Date | string
    updatedAt?: Date | string
    email_verification_expires?: Date | string | null
    email_verification_token?: string | null
    email_verified?: boolean
    terms_accepted?: boolean
    terms_accepted_at?: Date | string | null
    emergency_contact?: EmergencyContactCreateNestedOneWithoutMemberInput
    invoices?: InvoiceCreateNestedManyWithoutMemberInput
    medical_info?: MedicalInfoCreateNestedOneWithoutMemberInput
    attendance?: MemberAttendanceCreateNestedManyWithoutMemberInput
    check_ins?: MemberCheckInCreateNestedManyWithoutMemberInput
    fitness_goals?: MemberFitnessGoalCreateNestedManyWithoutMemberInput
    payments?: PaymentCreateNestedManyWithoutMemberInput
    Subscription?: SubscriptionCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutAddressInput = {
    id?: string
    name: string
    email: string
    phone_number?: string | null
    password: string
    age: number
    profile_picture?: string | null
    membershiptype: $Enums.MemberShipType
    createdAt?: Date | string
    updatedAt?: Date | string
    email_verification_expires?: Date | string | null
    email_verification_token?: string | null
    email_verified?: boolean
    terms_accepted?: boolean
    terms_accepted_at?: Date | string | null
    emergency_contact?: EmergencyContactUncheckedCreateNestedOneWithoutMemberInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutMemberInput
    medical_info?: MedicalInfoUncheckedCreateNestedOneWithoutMemberInput
    attendance?: MemberAttendanceUncheckedCreateNestedManyWithoutMemberInput
    check_ins?: MemberCheckInUncheckedCreateNestedManyWithoutMemberInput
    fitness_goals?: MemberFitnessGoalUncheckedCreateNestedManyWithoutMemberInput
    payments?: PaymentUncheckedCreateNestedManyWithoutMemberInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutAddressInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutAddressInput, MemberUncheckedCreateWithoutAddressInput>
  }

  export type MemberUpsertWithoutAddressInput = {
    update: XOR<MemberUpdateWithoutAddressInput, MemberUncheckedUpdateWithoutAddressInput>
    create: XOR<MemberCreateWithoutAddressInput, MemberUncheckedCreateWithoutAddressInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutAddressInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutAddressInput, MemberUncheckedUpdateWithoutAddressInput>
  }

  export type MemberUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    membershiptype?: EnumMemberShipTypeFieldUpdateOperationsInput | $Enums.MemberShipType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verification_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergency_contact?: EmergencyContactUpdateOneWithoutMemberNestedInput
    invoices?: InvoiceUpdateManyWithoutMemberNestedInput
    medical_info?: MedicalInfoUpdateOneWithoutMemberNestedInput
    attendance?: MemberAttendanceUpdateManyWithoutMemberNestedInput
    check_ins?: MemberCheckInUpdateManyWithoutMemberNestedInput
    fitness_goals?: MemberFitnessGoalUpdateManyWithoutMemberNestedInput
    payments?: PaymentUpdateManyWithoutMemberNestedInput
    Subscription?: SubscriptionUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    membershiptype?: EnumMemberShipTypeFieldUpdateOperationsInput | $Enums.MemberShipType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verification_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergency_contact?: EmergencyContactUncheckedUpdateOneWithoutMemberNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutMemberNestedInput
    medical_info?: MedicalInfoUncheckedUpdateOneWithoutMemberNestedInput
    attendance?: MemberAttendanceUncheckedUpdateManyWithoutMemberNestedInput
    check_ins?: MemberCheckInUncheckedUpdateManyWithoutMemberNestedInput
    fitness_goals?: MemberFitnessGoalUncheckedUpdateManyWithoutMemberNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutMemberNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type MemberCreateWithoutEmergency_contactInput = {
    id?: string
    name: string
    email: string
    phone_number?: string | null
    password: string
    age: number
    profile_picture?: string | null
    membershiptype: $Enums.MemberShipType
    createdAt?: Date | string
    updatedAt?: Date | string
    email_verification_expires?: Date | string | null
    email_verification_token?: string | null
    email_verified?: boolean
    terms_accepted?: boolean
    terms_accepted_at?: Date | string | null
    address?: AddressCreateNestedOneWithoutMemberInput
    invoices?: InvoiceCreateNestedManyWithoutMemberInput
    medical_info?: MedicalInfoCreateNestedOneWithoutMemberInput
    attendance?: MemberAttendanceCreateNestedManyWithoutMemberInput
    check_ins?: MemberCheckInCreateNestedManyWithoutMemberInput
    fitness_goals?: MemberFitnessGoalCreateNestedManyWithoutMemberInput
    payments?: PaymentCreateNestedManyWithoutMemberInput
    Subscription?: SubscriptionCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutEmergency_contactInput = {
    id?: string
    name: string
    email: string
    phone_number?: string | null
    password: string
    age: number
    profile_picture?: string | null
    membershiptype: $Enums.MemberShipType
    createdAt?: Date | string
    updatedAt?: Date | string
    email_verification_expires?: Date | string | null
    email_verification_token?: string | null
    email_verified?: boolean
    terms_accepted?: boolean
    terms_accepted_at?: Date | string | null
    address?: AddressUncheckedCreateNestedOneWithoutMemberInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutMemberInput
    medical_info?: MedicalInfoUncheckedCreateNestedOneWithoutMemberInput
    attendance?: MemberAttendanceUncheckedCreateNestedManyWithoutMemberInput
    check_ins?: MemberCheckInUncheckedCreateNestedManyWithoutMemberInput
    fitness_goals?: MemberFitnessGoalUncheckedCreateNestedManyWithoutMemberInput
    payments?: PaymentUncheckedCreateNestedManyWithoutMemberInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutEmergency_contactInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutEmergency_contactInput, MemberUncheckedCreateWithoutEmergency_contactInput>
  }

  export type MemberUpsertWithoutEmergency_contactInput = {
    update: XOR<MemberUpdateWithoutEmergency_contactInput, MemberUncheckedUpdateWithoutEmergency_contactInput>
    create: XOR<MemberCreateWithoutEmergency_contactInput, MemberUncheckedCreateWithoutEmergency_contactInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutEmergency_contactInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutEmergency_contactInput, MemberUncheckedUpdateWithoutEmergency_contactInput>
  }

  export type MemberUpdateWithoutEmergency_contactInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    membershiptype?: EnumMemberShipTypeFieldUpdateOperationsInput | $Enums.MemberShipType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verification_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: AddressUpdateOneWithoutMemberNestedInput
    invoices?: InvoiceUpdateManyWithoutMemberNestedInput
    medical_info?: MedicalInfoUpdateOneWithoutMemberNestedInput
    attendance?: MemberAttendanceUpdateManyWithoutMemberNestedInput
    check_ins?: MemberCheckInUpdateManyWithoutMemberNestedInput
    fitness_goals?: MemberFitnessGoalUpdateManyWithoutMemberNestedInput
    payments?: PaymentUpdateManyWithoutMemberNestedInput
    Subscription?: SubscriptionUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutEmergency_contactInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    membershiptype?: EnumMemberShipTypeFieldUpdateOperationsInput | $Enums.MemberShipType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verification_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: AddressUncheckedUpdateOneWithoutMemberNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutMemberNestedInput
    medical_info?: MedicalInfoUncheckedUpdateOneWithoutMemberNestedInput
    attendance?: MemberAttendanceUncheckedUpdateManyWithoutMemberNestedInput
    check_ins?: MemberCheckInUncheckedUpdateManyWithoutMemberNestedInput
    fitness_goals?: MemberFitnessGoalUncheckedUpdateManyWithoutMemberNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutMemberNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type MemberCreateWithoutMedical_infoInput = {
    id?: string
    name: string
    email: string
    phone_number?: string | null
    password: string
    age: number
    profile_picture?: string | null
    membershiptype: $Enums.MemberShipType
    createdAt?: Date | string
    updatedAt?: Date | string
    email_verification_expires?: Date | string | null
    email_verification_token?: string | null
    email_verified?: boolean
    terms_accepted?: boolean
    terms_accepted_at?: Date | string | null
    address?: AddressCreateNestedOneWithoutMemberInput
    emergency_contact?: EmergencyContactCreateNestedOneWithoutMemberInput
    invoices?: InvoiceCreateNestedManyWithoutMemberInput
    attendance?: MemberAttendanceCreateNestedManyWithoutMemberInput
    check_ins?: MemberCheckInCreateNestedManyWithoutMemberInput
    fitness_goals?: MemberFitnessGoalCreateNestedManyWithoutMemberInput
    payments?: PaymentCreateNestedManyWithoutMemberInput
    Subscription?: SubscriptionCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutMedical_infoInput = {
    id?: string
    name: string
    email: string
    phone_number?: string | null
    password: string
    age: number
    profile_picture?: string | null
    membershiptype: $Enums.MemberShipType
    createdAt?: Date | string
    updatedAt?: Date | string
    email_verification_expires?: Date | string | null
    email_verification_token?: string | null
    email_verified?: boolean
    terms_accepted?: boolean
    terms_accepted_at?: Date | string | null
    address?: AddressUncheckedCreateNestedOneWithoutMemberInput
    emergency_contact?: EmergencyContactUncheckedCreateNestedOneWithoutMemberInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutMemberInput
    attendance?: MemberAttendanceUncheckedCreateNestedManyWithoutMemberInput
    check_ins?: MemberCheckInUncheckedCreateNestedManyWithoutMemberInput
    fitness_goals?: MemberFitnessGoalUncheckedCreateNestedManyWithoutMemberInput
    payments?: PaymentUncheckedCreateNestedManyWithoutMemberInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutMedical_infoInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutMedical_infoInput, MemberUncheckedCreateWithoutMedical_infoInput>
  }

  export type MemberUpsertWithoutMedical_infoInput = {
    update: XOR<MemberUpdateWithoutMedical_infoInput, MemberUncheckedUpdateWithoutMedical_infoInput>
    create: XOR<MemberCreateWithoutMedical_infoInput, MemberUncheckedCreateWithoutMedical_infoInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutMedical_infoInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutMedical_infoInput, MemberUncheckedUpdateWithoutMedical_infoInput>
  }

  export type MemberUpdateWithoutMedical_infoInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    membershiptype?: EnumMemberShipTypeFieldUpdateOperationsInput | $Enums.MemberShipType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verification_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: AddressUpdateOneWithoutMemberNestedInput
    emergency_contact?: EmergencyContactUpdateOneWithoutMemberNestedInput
    invoices?: InvoiceUpdateManyWithoutMemberNestedInput
    attendance?: MemberAttendanceUpdateManyWithoutMemberNestedInput
    check_ins?: MemberCheckInUpdateManyWithoutMemberNestedInput
    fitness_goals?: MemberFitnessGoalUpdateManyWithoutMemberNestedInput
    payments?: PaymentUpdateManyWithoutMemberNestedInput
    Subscription?: SubscriptionUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutMedical_infoInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    membershiptype?: EnumMemberShipTypeFieldUpdateOperationsInput | $Enums.MemberShipType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verification_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: AddressUncheckedUpdateOneWithoutMemberNestedInput
    emergency_contact?: EmergencyContactUncheckedUpdateOneWithoutMemberNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutMemberNestedInput
    attendance?: MemberAttendanceUncheckedUpdateManyWithoutMemberNestedInput
    check_ins?: MemberCheckInUncheckedUpdateManyWithoutMemberNestedInput
    fitness_goals?: MemberFitnessGoalUncheckedUpdateManyWithoutMemberNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutMemberNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type MemberCreateWithoutPaymentsInput = {
    id?: string
    name: string
    email: string
    phone_number?: string | null
    password: string
    age: number
    profile_picture?: string | null
    membershiptype: $Enums.MemberShipType
    createdAt?: Date | string
    updatedAt?: Date | string
    email_verification_expires?: Date | string | null
    email_verification_token?: string | null
    email_verified?: boolean
    terms_accepted?: boolean
    terms_accepted_at?: Date | string | null
    address?: AddressCreateNestedOneWithoutMemberInput
    emergency_contact?: EmergencyContactCreateNestedOneWithoutMemberInput
    invoices?: InvoiceCreateNestedManyWithoutMemberInput
    medical_info?: MedicalInfoCreateNestedOneWithoutMemberInput
    attendance?: MemberAttendanceCreateNestedManyWithoutMemberInput
    check_ins?: MemberCheckInCreateNestedManyWithoutMemberInput
    fitness_goals?: MemberFitnessGoalCreateNestedManyWithoutMemberInput
    Subscription?: SubscriptionCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutPaymentsInput = {
    id?: string
    name: string
    email: string
    phone_number?: string | null
    password: string
    age: number
    profile_picture?: string | null
    membershiptype: $Enums.MemberShipType
    createdAt?: Date | string
    updatedAt?: Date | string
    email_verification_expires?: Date | string | null
    email_verification_token?: string | null
    email_verified?: boolean
    terms_accepted?: boolean
    terms_accepted_at?: Date | string | null
    address?: AddressUncheckedCreateNestedOneWithoutMemberInput
    emergency_contact?: EmergencyContactUncheckedCreateNestedOneWithoutMemberInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutMemberInput
    medical_info?: MedicalInfoUncheckedCreateNestedOneWithoutMemberInput
    attendance?: MemberAttendanceUncheckedCreateNestedManyWithoutMemberInput
    check_ins?: MemberCheckInUncheckedCreateNestedManyWithoutMemberInput
    fitness_goals?: MemberFitnessGoalUncheckedCreateNestedManyWithoutMemberInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutPaymentsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutPaymentsInput, MemberUncheckedCreateWithoutPaymentsInput>
  }

  export type MemberUpsertWithoutPaymentsInput = {
    update: XOR<MemberUpdateWithoutPaymentsInput, MemberUncheckedUpdateWithoutPaymentsInput>
    create: XOR<MemberCreateWithoutPaymentsInput, MemberUncheckedCreateWithoutPaymentsInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutPaymentsInput, MemberUncheckedUpdateWithoutPaymentsInput>
  }

  export type MemberUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    membershiptype?: EnumMemberShipTypeFieldUpdateOperationsInput | $Enums.MemberShipType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verification_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: AddressUpdateOneWithoutMemberNestedInput
    emergency_contact?: EmergencyContactUpdateOneWithoutMemberNestedInput
    invoices?: InvoiceUpdateManyWithoutMemberNestedInput
    medical_info?: MedicalInfoUpdateOneWithoutMemberNestedInput
    attendance?: MemberAttendanceUpdateManyWithoutMemberNestedInput
    check_ins?: MemberCheckInUpdateManyWithoutMemberNestedInput
    fitness_goals?: MemberFitnessGoalUpdateManyWithoutMemberNestedInput
    Subscription?: SubscriptionUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    membershiptype?: EnumMemberShipTypeFieldUpdateOperationsInput | $Enums.MemberShipType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verification_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: AddressUncheckedUpdateOneWithoutMemberNestedInput
    emergency_contact?: EmergencyContactUncheckedUpdateOneWithoutMemberNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutMemberNestedInput
    medical_info?: MedicalInfoUncheckedUpdateOneWithoutMemberNestedInput
    attendance?: MemberAttendanceUncheckedUpdateManyWithoutMemberNestedInput
    check_ins?: MemberCheckInUncheckedUpdateManyWithoutMemberNestedInput
    fitness_goals?: MemberFitnessGoalUncheckedUpdateManyWithoutMemberNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type MemberCreateWithoutInvoicesInput = {
    id?: string
    name: string
    email: string
    phone_number?: string | null
    password: string
    age: number
    profile_picture?: string | null
    membershiptype: $Enums.MemberShipType
    createdAt?: Date | string
    updatedAt?: Date | string
    email_verification_expires?: Date | string | null
    email_verification_token?: string | null
    email_verified?: boolean
    terms_accepted?: boolean
    terms_accepted_at?: Date | string | null
    address?: AddressCreateNestedOneWithoutMemberInput
    emergency_contact?: EmergencyContactCreateNestedOneWithoutMemberInput
    medical_info?: MedicalInfoCreateNestedOneWithoutMemberInput
    attendance?: MemberAttendanceCreateNestedManyWithoutMemberInput
    check_ins?: MemberCheckInCreateNestedManyWithoutMemberInput
    fitness_goals?: MemberFitnessGoalCreateNestedManyWithoutMemberInput
    payments?: PaymentCreateNestedManyWithoutMemberInput
    Subscription?: SubscriptionCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutInvoicesInput = {
    id?: string
    name: string
    email: string
    phone_number?: string | null
    password: string
    age: number
    profile_picture?: string | null
    membershiptype: $Enums.MemberShipType
    createdAt?: Date | string
    updatedAt?: Date | string
    email_verification_expires?: Date | string | null
    email_verification_token?: string | null
    email_verified?: boolean
    terms_accepted?: boolean
    terms_accepted_at?: Date | string | null
    address?: AddressUncheckedCreateNestedOneWithoutMemberInput
    emergency_contact?: EmergencyContactUncheckedCreateNestedOneWithoutMemberInput
    medical_info?: MedicalInfoUncheckedCreateNestedOneWithoutMemberInput
    attendance?: MemberAttendanceUncheckedCreateNestedManyWithoutMemberInput
    check_ins?: MemberCheckInUncheckedCreateNestedManyWithoutMemberInput
    fitness_goals?: MemberFitnessGoalUncheckedCreateNestedManyWithoutMemberInput
    payments?: PaymentUncheckedCreateNestedManyWithoutMemberInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutInvoicesInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutInvoicesInput, MemberUncheckedCreateWithoutInvoicesInput>
  }

  export type MemberUpsertWithoutInvoicesInput = {
    update: XOR<MemberUpdateWithoutInvoicesInput, MemberUncheckedUpdateWithoutInvoicesInput>
    create: XOR<MemberCreateWithoutInvoicesInput, MemberUncheckedCreateWithoutInvoicesInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutInvoicesInput, MemberUncheckedUpdateWithoutInvoicesInput>
  }

  export type MemberUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    membershiptype?: EnumMemberShipTypeFieldUpdateOperationsInput | $Enums.MemberShipType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verification_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: AddressUpdateOneWithoutMemberNestedInput
    emergency_contact?: EmergencyContactUpdateOneWithoutMemberNestedInput
    medical_info?: MedicalInfoUpdateOneWithoutMemberNestedInput
    attendance?: MemberAttendanceUpdateManyWithoutMemberNestedInput
    check_ins?: MemberCheckInUpdateManyWithoutMemberNestedInput
    fitness_goals?: MemberFitnessGoalUpdateManyWithoutMemberNestedInput
    payments?: PaymentUpdateManyWithoutMemberNestedInput
    Subscription?: SubscriptionUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    membershiptype?: EnumMemberShipTypeFieldUpdateOperationsInput | $Enums.MemberShipType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verification_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: AddressUncheckedUpdateOneWithoutMemberNestedInput
    emergency_contact?: EmergencyContactUncheckedUpdateOneWithoutMemberNestedInput
    medical_info?: MedicalInfoUncheckedUpdateOneWithoutMemberNestedInput
    attendance?: MemberAttendanceUncheckedUpdateManyWithoutMemberNestedInput
    check_ins?: MemberCheckInUncheckedUpdateManyWithoutMemberNestedInput
    fitness_goals?: MemberFitnessGoalUncheckedUpdateManyWithoutMemberNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutMemberNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type SubscriptionCreateWithoutPlanInput = {
    id?: string
    startDate?: Date | string
    endDate: Date | string
    member: MemberCreateNestedOneWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutPlanInput = {
    id?: string
    memberId: string
    startDate?: Date | string
    endDate: Date | string
  }

  export type SubscriptionCreateOrConnectWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type SubscriptionCreateManyPlanInputEnvelope = {
    data: SubscriptionCreateManyPlanInput | SubscriptionCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutPlanInput, SubscriptionUncheckedUpdateWithoutPlanInput>
    create: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutPlanInput, SubscriptionUncheckedUpdateWithoutPlanInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutPlanInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutPlanInput>
  }

  export type MemberCreateWithoutSubscriptionInput = {
    id?: string
    name: string
    email: string
    phone_number?: string | null
    password: string
    age: number
    profile_picture?: string | null
    membershiptype: $Enums.MemberShipType
    createdAt?: Date | string
    updatedAt?: Date | string
    email_verification_expires?: Date | string | null
    email_verification_token?: string | null
    email_verified?: boolean
    terms_accepted?: boolean
    terms_accepted_at?: Date | string | null
    address?: AddressCreateNestedOneWithoutMemberInput
    emergency_contact?: EmergencyContactCreateNestedOneWithoutMemberInput
    invoices?: InvoiceCreateNestedManyWithoutMemberInput
    medical_info?: MedicalInfoCreateNestedOneWithoutMemberInput
    attendance?: MemberAttendanceCreateNestedManyWithoutMemberInput
    check_ins?: MemberCheckInCreateNestedManyWithoutMemberInput
    fitness_goals?: MemberFitnessGoalCreateNestedManyWithoutMemberInput
    payments?: PaymentCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    name: string
    email: string
    phone_number?: string | null
    password: string
    age: number
    profile_picture?: string | null
    membershiptype: $Enums.MemberShipType
    createdAt?: Date | string
    updatedAt?: Date | string
    email_verification_expires?: Date | string | null
    email_verification_token?: string | null
    email_verified?: boolean
    terms_accepted?: boolean
    terms_accepted_at?: Date | string | null
    address?: AddressUncheckedCreateNestedOneWithoutMemberInput
    emergency_contact?: EmergencyContactUncheckedCreateNestedOneWithoutMemberInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutMemberInput
    medical_info?: MedicalInfoUncheckedCreateNestedOneWithoutMemberInput
    attendance?: MemberAttendanceUncheckedCreateNestedManyWithoutMemberInput
    check_ins?: MemberCheckInUncheckedCreateNestedManyWithoutMemberInput
    fitness_goals?: MemberFitnessGoalUncheckedCreateNestedManyWithoutMemberInput
    payments?: PaymentUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutSubscriptionInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutSubscriptionInput, MemberUncheckedCreateWithoutSubscriptionInput>
  }

  export type MembershipPlanCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    price: number
    duration: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipPlanUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    price: number
    duration: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipPlanCreateOrConnectWithoutSubscriptionsInput = {
    where: MembershipPlanWhereUniqueInput
    create: XOR<MembershipPlanCreateWithoutSubscriptionsInput, MembershipPlanUncheckedCreateWithoutSubscriptionsInput>
  }

  export type MemberUpsertWithoutSubscriptionInput = {
    update: XOR<MemberUpdateWithoutSubscriptionInput, MemberUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<MemberCreateWithoutSubscriptionInput, MemberUncheckedCreateWithoutSubscriptionInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutSubscriptionInput, MemberUncheckedUpdateWithoutSubscriptionInput>
  }

  export type MemberUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    membershiptype?: EnumMemberShipTypeFieldUpdateOperationsInput | $Enums.MemberShipType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verification_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: AddressUpdateOneWithoutMemberNestedInput
    emergency_contact?: EmergencyContactUpdateOneWithoutMemberNestedInput
    invoices?: InvoiceUpdateManyWithoutMemberNestedInput
    medical_info?: MedicalInfoUpdateOneWithoutMemberNestedInput
    attendance?: MemberAttendanceUpdateManyWithoutMemberNestedInput
    check_ins?: MemberCheckInUpdateManyWithoutMemberNestedInput
    fitness_goals?: MemberFitnessGoalUpdateManyWithoutMemberNestedInput
    payments?: PaymentUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    membershiptype?: EnumMemberShipTypeFieldUpdateOperationsInput | $Enums.MemberShipType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verification_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    terms_accepted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: AddressUncheckedUpdateOneWithoutMemberNestedInput
    emergency_contact?: EmergencyContactUncheckedUpdateOneWithoutMemberNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutMemberNestedInput
    medical_info?: MedicalInfoUncheckedUpdateOneWithoutMemberNestedInput
    attendance?: MemberAttendanceUncheckedUpdateManyWithoutMemberNestedInput
    check_ins?: MemberCheckInUncheckedUpdateManyWithoutMemberNestedInput
    fitness_goals?: MemberFitnessGoalUncheckedUpdateManyWithoutMemberNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type MembershipPlanUpsertWithoutSubscriptionsInput = {
    update: XOR<MembershipPlanUpdateWithoutSubscriptionsInput, MembershipPlanUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<MembershipPlanCreateWithoutSubscriptionsInput, MembershipPlanUncheckedCreateWithoutSubscriptionsInput>
    where?: MembershipPlanWhereInput
  }

  export type MembershipPlanUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: MembershipPlanWhereInput
    data: XOR<MembershipPlanUpdateWithoutSubscriptionsInput, MembershipPlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type MembershipPlanUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipPlanUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceLogCreateWithoutEquipmentInput = {
    id?: string
    type: $Enums.MaintenanceType
    description: string
    cost?: number | null
    performedBy?: string | null
    performedAt?: Date | string
    nextDue?: Date | string | null
  }

  export type MaintenanceLogUncheckedCreateWithoutEquipmentInput = {
    id?: string
    type: $Enums.MaintenanceType
    description: string
    cost?: number | null
    performedBy?: string | null
    performedAt?: Date | string
    nextDue?: Date | string | null
  }

  export type MaintenanceLogCreateOrConnectWithoutEquipmentInput = {
    where: MaintenanceLogWhereUniqueInput
    create: XOR<MaintenanceLogCreateWithoutEquipmentInput, MaintenanceLogUncheckedCreateWithoutEquipmentInput>
  }

  export type MaintenanceLogCreateManyEquipmentInputEnvelope = {
    data: MaintenanceLogCreateManyEquipmentInput | MaintenanceLogCreateManyEquipmentInput[]
    skipDuplicates?: boolean
  }

  export type MaintenanceLogUpsertWithWhereUniqueWithoutEquipmentInput = {
    where: MaintenanceLogWhereUniqueInput
    update: XOR<MaintenanceLogUpdateWithoutEquipmentInput, MaintenanceLogUncheckedUpdateWithoutEquipmentInput>
    create: XOR<MaintenanceLogCreateWithoutEquipmentInput, MaintenanceLogUncheckedCreateWithoutEquipmentInput>
  }

  export type MaintenanceLogUpdateWithWhereUniqueWithoutEquipmentInput = {
    where: MaintenanceLogWhereUniqueInput
    data: XOR<MaintenanceLogUpdateWithoutEquipmentInput, MaintenanceLogUncheckedUpdateWithoutEquipmentInput>
  }

  export type MaintenanceLogUpdateManyWithWhereWithoutEquipmentInput = {
    where: MaintenanceLogScalarWhereInput
    data: XOR<MaintenanceLogUpdateManyMutationInput, MaintenanceLogUncheckedUpdateManyWithoutEquipmentInput>
  }

  export type MaintenanceLogScalarWhereInput = {
    AND?: MaintenanceLogScalarWhereInput | MaintenanceLogScalarWhereInput[]
    OR?: MaintenanceLogScalarWhereInput[]
    NOT?: MaintenanceLogScalarWhereInput | MaintenanceLogScalarWhereInput[]
    id?: StringFilter<"MaintenanceLog"> | string
    equipmentId?: StringFilter<"MaintenanceLog"> | string
    type?: EnumMaintenanceTypeFilter<"MaintenanceLog"> | $Enums.MaintenanceType
    description?: StringFilter<"MaintenanceLog"> | string
    cost?: FloatNullableFilter<"MaintenanceLog"> | number | null
    performedBy?: StringNullableFilter<"MaintenanceLog"> | string | null
    performedAt?: DateTimeFilter<"MaintenanceLog"> | Date | string
    nextDue?: DateTimeNullableFilter<"MaintenanceLog"> | Date | string | null
  }

  export type EquipmentCreateWithoutMaintenanceLogsInput = {
    id?: string
    name: string
    type: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    available?: number
    brand?: string | null
    category: string
    cost?: number | null
    description?: string | null
    imageUrl?: string | null
    inUse?: number
    lastMaintenance?: Date | string | null
    location?: string | null
    maintenance?: boolean
    model?: string | null
    nextMaintenance?: Date | string | null
    purchaseDate?: Date | string | null
    serialNumber?: string | null
    status?: $Enums.EquipmentStatus
    warrantyExpiry?: Date | string | null
  }

  export type EquipmentUncheckedCreateWithoutMaintenanceLogsInput = {
    id?: string
    name: string
    type: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    available?: number
    brand?: string | null
    category: string
    cost?: number | null
    description?: string | null
    imageUrl?: string | null
    inUse?: number
    lastMaintenance?: Date | string | null
    location?: string | null
    maintenance?: boolean
    model?: string | null
    nextMaintenance?: Date | string | null
    purchaseDate?: Date | string | null
    serialNumber?: string | null
    status?: $Enums.EquipmentStatus
    warrantyExpiry?: Date | string | null
  }

  export type EquipmentCreateOrConnectWithoutMaintenanceLogsInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutMaintenanceLogsInput, EquipmentUncheckedCreateWithoutMaintenanceLogsInput>
  }

  export type EquipmentUpsertWithoutMaintenanceLogsInput = {
    update: XOR<EquipmentUpdateWithoutMaintenanceLogsInput, EquipmentUncheckedUpdateWithoutMaintenanceLogsInput>
    create: XOR<EquipmentCreateWithoutMaintenanceLogsInput, EquipmentUncheckedCreateWithoutMaintenanceLogsInput>
    where?: EquipmentWhereInput
  }

  export type EquipmentUpdateToOneWithWhereWithoutMaintenanceLogsInput = {
    where?: EquipmentWhereInput
    data: XOR<EquipmentUpdateWithoutMaintenanceLogsInput, EquipmentUncheckedUpdateWithoutMaintenanceLogsInput>
  }

  export type EquipmentUpdateWithoutMaintenanceLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    available?: IntFieldUpdateOperationsInput | number
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    inUse?: IntFieldUpdateOperationsInput | number
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    maintenance?: BoolFieldUpdateOperationsInput | boolean
    model?: NullableStringFieldUpdateOperationsInput | string | null
    nextMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    warrantyExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EquipmentUncheckedUpdateWithoutMaintenanceLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    available?: IntFieldUpdateOperationsInput | number
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    inUse?: IntFieldUpdateOperationsInput | number
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    maintenance?: BoolFieldUpdateOperationsInput | boolean
    model?: NullableStringFieldUpdateOperationsInput | string | null
    nextMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    warrantyExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateWithoutAdmin_profileInput = {
    name: string
    username?: string | null
    email: string
    phone_number?: string | null
    password: string
    role?: string
    profile_picture?: string | null
    tokenVersion?: number
    created_at?: Date | string
    updated_at?: Date | string
    resetToken?: string | null
    resetTokenExp?: Date | string | null
    bio?: string | null
    dateOfBirth?: Date | string | null
    department?: string | null
    email_verified?: boolean
    gender?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    lockedUntil?: Date | string | null
    loginAttempts?: number
    position?: string | null
    permission_audits?: PermissionAuditCreateNestedManyWithoutUserInput
    access_logs?: UserAccessLogCreateNestedManyWithoutUserInput
    address?: UserAddressCreateNestedOneWithoutUserInput
    emergency_contact?: UserEmergencyContactCreateNestedOneWithoutUserInput
    ip_restrictions?: UserIPRestrictionCreateNestedManyWithoutUserInput
    notification_settings?: UserNotificationSettingsCreateNestedOneWithoutUserInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    privacy_settings?: UserPrivacySettingsCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    social_media?: UserSocialMediaCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdmin_profileInput = {
    id?: number
    name: string
    username?: string | null
    email: string
    phone_number?: string | null
    password: string
    role?: string
    profile_picture?: string | null
    tokenVersion?: number
    created_at?: Date | string
    updated_at?: Date | string
    resetToken?: string | null
    resetTokenExp?: Date | string | null
    bio?: string | null
    dateOfBirth?: Date | string | null
    department?: string | null
    email_verified?: boolean
    gender?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    lockedUntil?: Date | string | null
    loginAttempts?: number
    position?: string | null
    permission_audits?: PermissionAuditUncheckedCreateNestedManyWithoutUserInput
    access_logs?: UserAccessLogUncheckedCreateNestedManyWithoutUserInput
    address?: UserAddressUncheckedCreateNestedOneWithoutUserInput
    emergency_contact?: UserEmergencyContactUncheckedCreateNestedOneWithoutUserInput
    ip_restrictions?: UserIPRestrictionUncheckedCreateNestedManyWithoutUserInput
    notification_settings?: UserNotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    privacy_settings?: UserPrivacySettingsUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    social_media?: UserSocialMediaUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdmin_profileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdmin_profileInput, UserUncheckedCreateWithoutAdmin_profileInput>
  }

  export type UserUpsertWithoutAdmin_profileInput = {
    update: XOR<UserUpdateWithoutAdmin_profileInput, UserUncheckedUpdateWithoutAdmin_profileInput>
    create: XOR<UserCreateWithoutAdmin_profileInput, UserUncheckedCreateWithoutAdmin_profileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdmin_profileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdmin_profileInput, UserUncheckedUpdateWithoutAdmin_profileInput>
  }

  export type UserUpdateWithoutAdmin_profileInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    position?: NullableStringFieldUpdateOperationsInput | string | null
    permission_audits?: PermissionAuditUpdateManyWithoutUserNestedInput
    access_logs?: UserAccessLogUpdateManyWithoutUserNestedInput
    address?: UserAddressUpdateOneWithoutUserNestedInput
    emergency_contact?: UserEmergencyContactUpdateOneWithoutUserNestedInput
    ip_restrictions?: UserIPRestrictionUpdateManyWithoutUserNestedInput
    notification_settings?: UserNotificationSettingsUpdateOneWithoutUserNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    privacy_settings?: UserPrivacySettingsUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    social_media?: UserSocialMediaUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdmin_profileInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    position?: NullableStringFieldUpdateOperationsInput | string | null
    permission_audits?: PermissionAuditUncheckedUpdateManyWithoutUserNestedInput
    access_logs?: UserAccessLogUncheckedUpdateManyWithoutUserNestedInput
    address?: UserAddressUncheckedUpdateOneWithoutUserNestedInput
    emergency_contact?: UserEmergencyContactUncheckedUpdateOneWithoutUserNestedInput
    ip_restrictions?: UserIPRestrictionUncheckedUpdateManyWithoutUserNestedInput
    notification_settings?: UserNotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    privacy_settings?: UserPrivacySettingsUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    social_media?: UserSocialMediaUncheckedUpdateOneWithoutUserNestedInput
  }

  export type RoleHierarchyCreateWithoutRoleInput = {
    id?: string
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: RoleHierarchyCreateNestedOneWithoutChildrenInput
    children?: RoleHierarchyCreateNestedManyWithoutParentInput
  }

  export type RoleHierarchyUncheckedCreateWithoutRoleInput = {
    id?: string
    parentId?: string | null
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: RoleHierarchyUncheckedCreateNestedManyWithoutParentInput
  }

  export type RoleHierarchyCreateOrConnectWithoutRoleInput = {
    where: RoleHierarchyWhereUniqueInput
    create: XOR<RoleHierarchyCreateWithoutRoleInput, RoleHierarchyUncheckedCreateWithoutRoleInput>
  }

  export type RoleHierarchyUpsertWithoutRoleInput = {
    update: XOR<RoleHierarchyUpdateWithoutRoleInput, RoleHierarchyUncheckedUpdateWithoutRoleInput>
    create: XOR<RoleHierarchyCreateWithoutRoleInput, RoleHierarchyUncheckedCreateWithoutRoleInput>
    where?: RoleHierarchyWhereInput
  }

  export type RoleHierarchyUpdateToOneWithWhereWithoutRoleInput = {
    where?: RoleHierarchyWhereInput
    data: XOR<RoleHierarchyUpdateWithoutRoleInput, RoleHierarchyUncheckedUpdateWithoutRoleInput>
  }

  export type RoleHierarchyUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: RoleHierarchyUpdateOneWithoutChildrenNestedInput
    children?: RoleHierarchyUpdateManyWithoutParentNestedInput
  }

  export type RoleHierarchyUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: RoleHierarchyUncheckedUpdateManyWithoutParentNestedInput
  }

  export type RoleHierarchyCreateWithoutChildrenInput = {
    id?: string
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: RoleHierarchyCreateNestedOneWithoutChildrenInput
    role: CustomRoleCreateNestedOneWithoutHierarchyInput
  }

  export type RoleHierarchyUncheckedCreateWithoutChildrenInput = {
    id?: string
    roleId: string
    parentId?: string | null
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleHierarchyCreateOrConnectWithoutChildrenInput = {
    where: RoleHierarchyWhereUniqueInput
    create: XOR<RoleHierarchyCreateWithoutChildrenInput, RoleHierarchyUncheckedCreateWithoutChildrenInput>
  }

  export type RoleHierarchyCreateWithoutParentInput = {
    id?: string
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: RoleHierarchyCreateNestedManyWithoutParentInput
    role: CustomRoleCreateNestedOneWithoutHierarchyInput
  }

  export type RoleHierarchyUncheckedCreateWithoutParentInput = {
    id?: string
    roleId: string
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: RoleHierarchyUncheckedCreateNestedManyWithoutParentInput
  }

  export type RoleHierarchyCreateOrConnectWithoutParentInput = {
    where: RoleHierarchyWhereUniqueInput
    create: XOR<RoleHierarchyCreateWithoutParentInput, RoleHierarchyUncheckedCreateWithoutParentInput>
  }

  export type RoleHierarchyCreateManyParentInputEnvelope = {
    data: RoleHierarchyCreateManyParentInput | RoleHierarchyCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type CustomRoleCreateWithoutHierarchyInput = {
    id?: string
    name: string
    description?: string | null
    permissions?: CustomRoleCreatepermissionsInput | string[]
    parentRole?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomRoleUncheckedCreateWithoutHierarchyInput = {
    id?: string
    name: string
    description?: string | null
    permissions?: CustomRoleCreatepermissionsInput | string[]
    parentRole?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomRoleCreateOrConnectWithoutHierarchyInput = {
    where: CustomRoleWhereUniqueInput
    create: XOR<CustomRoleCreateWithoutHierarchyInput, CustomRoleUncheckedCreateWithoutHierarchyInput>
  }

  export type RoleHierarchyUpsertWithoutChildrenInput = {
    update: XOR<RoleHierarchyUpdateWithoutChildrenInput, RoleHierarchyUncheckedUpdateWithoutChildrenInput>
    create: XOR<RoleHierarchyCreateWithoutChildrenInput, RoleHierarchyUncheckedCreateWithoutChildrenInput>
    where?: RoleHierarchyWhereInput
  }

  export type RoleHierarchyUpdateToOneWithWhereWithoutChildrenInput = {
    where?: RoleHierarchyWhereInput
    data: XOR<RoleHierarchyUpdateWithoutChildrenInput, RoleHierarchyUncheckedUpdateWithoutChildrenInput>
  }

  export type RoleHierarchyUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: RoleHierarchyUpdateOneWithoutChildrenNestedInput
    role?: CustomRoleUpdateOneRequiredWithoutHierarchyNestedInput
  }

  export type RoleHierarchyUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleHierarchyUpsertWithWhereUniqueWithoutParentInput = {
    where: RoleHierarchyWhereUniqueInput
    update: XOR<RoleHierarchyUpdateWithoutParentInput, RoleHierarchyUncheckedUpdateWithoutParentInput>
    create: XOR<RoleHierarchyCreateWithoutParentInput, RoleHierarchyUncheckedCreateWithoutParentInput>
  }

  export type RoleHierarchyUpdateWithWhereUniqueWithoutParentInput = {
    where: RoleHierarchyWhereUniqueInput
    data: XOR<RoleHierarchyUpdateWithoutParentInput, RoleHierarchyUncheckedUpdateWithoutParentInput>
  }

  export type RoleHierarchyUpdateManyWithWhereWithoutParentInput = {
    where: RoleHierarchyScalarWhereInput
    data: XOR<RoleHierarchyUpdateManyMutationInput, RoleHierarchyUncheckedUpdateManyWithoutParentInput>
  }

  export type RoleHierarchyScalarWhereInput = {
    AND?: RoleHierarchyScalarWhereInput | RoleHierarchyScalarWhereInput[]
    OR?: RoleHierarchyScalarWhereInput[]
    NOT?: RoleHierarchyScalarWhereInput | RoleHierarchyScalarWhereInput[]
    id?: StringFilter<"RoleHierarchy"> | string
    roleId?: StringFilter<"RoleHierarchy"> | string
    parentId?: StringNullableFilter<"RoleHierarchy"> | string | null
    level?: IntFilter<"RoleHierarchy"> | number
    createdAt?: DateTimeFilter<"RoleHierarchy"> | Date | string
    updatedAt?: DateTimeFilter<"RoleHierarchy"> | Date | string
  }

  export type CustomRoleUpsertWithoutHierarchyInput = {
    update: XOR<CustomRoleUpdateWithoutHierarchyInput, CustomRoleUncheckedUpdateWithoutHierarchyInput>
    create: XOR<CustomRoleCreateWithoutHierarchyInput, CustomRoleUncheckedCreateWithoutHierarchyInput>
    where?: CustomRoleWhereInput
  }

  export type CustomRoleUpdateToOneWithWhereWithoutHierarchyInput = {
    where?: CustomRoleWhereInput
    data: XOR<CustomRoleUpdateWithoutHierarchyInput, CustomRoleUncheckedUpdateWithoutHierarchyInput>
  }

  export type CustomRoleUpdateWithoutHierarchyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: CustomRoleUpdatepermissionsInput | string[]
    parentRole?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomRoleUncheckedUpdateWithoutHierarchyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: CustomRoleUpdatepermissionsInput | string[]
    parentRole?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutPermission_auditsInput = {
    name: string
    username?: string | null
    email: string
    phone_number?: string | null
    password: string
    role?: string
    profile_picture?: string | null
    tokenVersion?: number
    created_at?: Date | string
    updated_at?: Date | string
    resetToken?: string | null
    resetTokenExp?: Date | string | null
    bio?: string | null
    dateOfBirth?: Date | string | null
    department?: string | null
    email_verified?: boolean
    gender?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    lockedUntil?: Date | string | null
    loginAttempts?: number
    position?: string | null
    admin_profile?: AdministrativeProfileCreateNestedOneWithoutUserInput
    access_logs?: UserAccessLogCreateNestedManyWithoutUserInput
    address?: UserAddressCreateNestedOneWithoutUserInput
    emergency_contact?: UserEmergencyContactCreateNestedOneWithoutUserInput
    ip_restrictions?: UserIPRestrictionCreateNestedManyWithoutUserInput
    notification_settings?: UserNotificationSettingsCreateNestedOneWithoutUserInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    privacy_settings?: UserPrivacySettingsCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    social_media?: UserSocialMediaCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPermission_auditsInput = {
    id?: number
    name: string
    username?: string | null
    email: string
    phone_number?: string | null
    password: string
    role?: string
    profile_picture?: string | null
    tokenVersion?: number
    created_at?: Date | string
    updated_at?: Date | string
    resetToken?: string | null
    resetTokenExp?: Date | string | null
    bio?: string | null
    dateOfBirth?: Date | string | null
    department?: string | null
    email_verified?: boolean
    gender?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    lockedUntil?: Date | string | null
    loginAttempts?: number
    position?: string | null
    admin_profile?: AdministrativeProfileUncheckedCreateNestedOneWithoutUserInput
    access_logs?: UserAccessLogUncheckedCreateNestedManyWithoutUserInput
    address?: UserAddressUncheckedCreateNestedOneWithoutUserInput
    emergency_contact?: UserEmergencyContactUncheckedCreateNestedOneWithoutUserInput
    ip_restrictions?: UserIPRestrictionUncheckedCreateNestedManyWithoutUserInput
    notification_settings?: UserNotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    privacy_settings?: UserPrivacySettingsUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    social_media?: UserSocialMediaUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPermission_auditsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPermission_auditsInput, UserUncheckedCreateWithoutPermission_auditsInput>
  }

  export type UserUpsertWithoutPermission_auditsInput = {
    update: XOR<UserUpdateWithoutPermission_auditsInput, UserUncheckedUpdateWithoutPermission_auditsInput>
    create: XOR<UserCreateWithoutPermission_auditsInput, UserUncheckedCreateWithoutPermission_auditsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPermission_auditsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPermission_auditsInput, UserUncheckedUpdateWithoutPermission_auditsInput>
  }

  export type UserUpdateWithoutPermission_auditsInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    position?: NullableStringFieldUpdateOperationsInput | string | null
    admin_profile?: AdministrativeProfileUpdateOneWithoutUserNestedInput
    access_logs?: UserAccessLogUpdateManyWithoutUserNestedInput
    address?: UserAddressUpdateOneWithoutUserNestedInput
    emergency_contact?: UserEmergencyContactUpdateOneWithoutUserNestedInput
    ip_restrictions?: UserIPRestrictionUpdateManyWithoutUserNestedInput
    notification_settings?: UserNotificationSettingsUpdateOneWithoutUserNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    privacy_settings?: UserPrivacySettingsUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    social_media?: UserSocialMediaUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPermission_auditsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    position?: NullableStringFieldUpdateOperationsInput | string | null
    admin_profile?: AdministrativeProfileUncheckedUpdateOneWithoutUserNestedInput
    access_logs?: UserAccessLogUncheckedUpdateManyWithoutUserNestedInput
    address?: UserAddressUncheckedUpdateOneWithoutUserNestedInput
    emergency_contact?: UserEmergencyContactUncheckedUpdateOneWithoutUserNestedInput
    ip_restrictions?: UserIPRestrictionUncheckedUpdateManyWithoutUserNestedInput
    notification_settings?: UserNotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    privacy_settings?: UserPrivacySettingsUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    social_media?: UserSocialMediaUncheckedUpdateOneWithoutUserNestedInput
  }

  export type PermissionAuditCreateManyUserInput = {
    id?: string
    action: string
    permissionId: string
    oldValue?: string | null
    newValue: string
    reason?: string | null
    performedBy?: string | null
    createdAt?: Date | string
  }

  export type UserAccessLogCreateManyUserInput = {
    id?: string
    action: string
    ipAddress?: string | null
    userAgent?: string | null
    success: boolean
    details?: string | null
    createdAt?: Date | string
  }

  export type UserIPRestrictionCreateManyUserInput = {
    id?: string
    ipAddress: string
    type: string
    reason?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSessionCreateManyUserInput = {
    id?: string
    token: string
    deviceType?: string | null
    deviceInfo?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    isActive?: boolean
    lastActivity?: Date | string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionAuditUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionAuditUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionAuditUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAccessLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAccessLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAccessLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserIPRestrictionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserIPRestrictionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserIPRestrictionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateManyMemberInput = {
    id?: string
    amount: number
    details: string
    createdAt?: Date | string
  }

  export type MemberAttendanceCreateManyMemberInput = {
    id?: string
    date: Date | string
    timeIn: Date | string
    timeOut?: Date | string | null
    duration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberCheckInCreateManyMemberInput = {
    id?: string
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    location?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberFitnessGoalCreateManyMemberInput = {
    id?: string
    goalType: string
    targetValue: number
    currentValue: number
    unit: string
    targetDate?: Date | string | null
    isCompleted?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyMemberInput = {
    id?: string
    amount: number
    method: string
    createdAt?: Date | string
    status?: string
    description?: string | null
    reference?: string | null
    updatedAt?: Date | string
  }

  export type SubscriptionCreateManyMemberInput = {
    id?: string
    planId: string
    startDate?: Date | string
    endDate: Date | string
  }

  export type InvoiceUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    details?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    details?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    details?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberAttendanceUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    timeIn?: DateTimeFieldUpdateOperationsInput | Date | string
    timeOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberAttendanceUncheckedUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    timeIn?: DateTimeFieldUpdateOperationsInput | Date | string
    timeOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberAttendanceUncheckedUpdateManyWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    timeIn?: DateTimeFieldUpdateOperationsInput | Date | string
    timeOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberCheckInUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberCheckInUncheckedUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberCheckInUncheckedUpdateManyWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberFitnessGoalUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalType?: StringFieldUpdateOperationsInput | string
    targetValue?: FloatFieldUpdateOperationsInput | number
    currentValue?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberFitnessGoalUncheckedUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalType?: StringFieldUpdateOperationsInput | string
    targetValue?: FloatFieldUpdateOperationsInput | number
    currentValue?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberFitnessGoalUncheckedUpdateManyWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalType?: StringFieldUpdateOperationsInput | string
    targetValue?: FloatFieldUpdateOperationsInput | number
    currentValue?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: MembershipPlanUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateManyPlanInput = {
    id?: string
    memberId: string
    startDate?: Date | string
    endDate: Date | string
  }

  export type SubscriptionUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    member?: MemberUpdateOneRequiredWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceLogCreateManyEquipmentInput = {
    id?: string
    type: $Enums.MaintenanceType
    description: string
    cost?: number | null
    performedBy?: string | null
    performedAt?: Date | string
    nextDue?: Date | string | null
  }

  export type MaintenanceLogUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMaintenanceTypeFieldUpdateOperationsInput | $Enums.MaintenanceType
    description?: StringFieldUpdateOperationsInput | string
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MaintenanceLogUncheckedUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMaintenanceTypeFieldUpdateOperationsInput | $Enums.MaintenanceType
    description?: StringFieldUpdateOperationsInput | string
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MaintenanceLogUncheckedUpdateManyWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMaintenanceTypeFieldUpdateOperationsInput | $Enums.MaintenanceType
    description?: StringFieldUpdateOperationsInput | string
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoleHierarchyCreateManyParentInput = {
    id?: string
    roleId: string
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleHierarchyUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: RoleHierarchyUpdateManyWithoutParentNestedInput
    role?: CustomRoleUpdateOneRequiredWithoutHierarchyNestedInput
  }

  export type RoleHierarchyUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: RoleHierarchyUncheckedUpdateManyWithoutParentNestedInput
  }

  export type RoleHierarchyUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}